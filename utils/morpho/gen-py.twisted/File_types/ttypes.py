#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:twisted
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class File_type:
  video = 0
  audio = 1
  picture = 2
  stolen_card_list = 3
  diagnostic_info = 4
  language = 5
  SSL_component = 6
  firmware_upgrade = 7

  _VALUES_TO_NAMES = {
    0: "video",
    1: "audio",
    2: "picture",
    3: "stolen_card_list",
    4: "diagnostic_info",
    5: "language",
    6: "SSL_component",
    7: "firmware_upgrade",
  }

  _NAMES_TO_VALUES = {
    "video": 0,
    "audio": 1,
    "picture": 2,
    "stolen_card_list": 3,
    "diagnostic_info": 4,
    "language": 5,
    "SSL_component": 6,
    "firmware_upgrade": 7,
  }

class File_subtype:
  no_subtype = 0
  audio_verification_failed = 1
  audio_verification_succeeded = 2
  audio_message_attention = 3
  audio_tamper = 4
  audio_test = 5
  picture_dynamic_message = 6
  picture_wallpaper = 7
  SSL_profile_0 = 8
  SSL_profile_1 = 9

  _VALUES_TO_NAMES = {
    0: "no_subtype",
    1: "audio_verification_failed",
    2: "audio_verification_succeeded",
    3: "audio_message_attention",
    4: "audio_tamper",
    5: "audio_test",
    6: "picture_dynamic_message",
    7: "picture_wallpaper",
    8: "SSL_profile_0",
    9: "SSL_profile_1",
  }

  _NAMES_TO_VALUES = {
    "no_subtype": 0,
    "audio_verification_failed": 1,
    "audio_verification_succeeded": 2,
    "audio_message_attention": 3,
    "audio_tamper": 4,
    "audio_test": 5,
    "picture_dynamic_message": 6,
    "picture_wallpaper": 7,
    "SSL_profile_0": 8,
    "SSL_profile_1": 9,
  }

class File_action:
  nothing = 0
  play = 1

  _VALUES_TO_NAMES = {
    0: "nothing",
    1: "play",
  }

  _NAMES_TO_VALUES = {
    "nothing": 0,
    "play": 1,
  }


class File_details:
  """
  Attributes:
   - type
   - subtype
   - name_UTF8
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.I32, 'subtype', None, None, ), # 2
    (3, TType.STRING, 'name_UTF8', None, None, ), # 3
  )

  def __init__(self, type=None, subtype=None, name_UTF8=None,):
    self.type = type
    self.subtype = subtype
    self.name_UTF8 = name_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.subtype = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('File_details')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.subtype is not None:
      oprot.writeFieldBegin('subtype', TType.I32, 2)
      oprot.writeI32(self.subtype)
      oprot.writeFieldEnd()
    if self.name_UTF8 is not None:
      oprot.writeFieldBegin('name_UTF8', TType.STRING, 3)
      oprot.writeString(self.name_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class File_chunk:
  """
  Attributes:
   - index: File index of the data present in this chunk
   - is_last: Set to true if this chunk is the last, false otherwise
   - data: File data
   - action: Action performed after transfer
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
    (2, TType.BOOL, 'is_last', None, None, ), # 2
    (3, TType.STRING, 'data', None, None, ), # 3
    (4, TType.I32, 'action', None, None, ), # 4
  )

  def __init__(self, index=None, is_last=None, data=None, action=None,):
    self.index = index
    self.is_last = is_last
    self.data = data
    self.action = action

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.is_last = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.data = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('File_chunk')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.is_last is not None:
      oprot.writeFieldBegin('is_last', TType.BOOL, 2)
      oprot.writeBool(self.is_last)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 3)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 4)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
