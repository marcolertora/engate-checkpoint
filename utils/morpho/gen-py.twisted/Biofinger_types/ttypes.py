#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:twisted
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import Generic_types.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Biofinger_failure_cause:
  """
  Enumeration representing of the biometric operation failure.
  """
  Biofinger_matching_no_hit = 0
  Biofinger_matching_FFD = 1
  Biofinger_matching_moist_finger = 2
  Biofinger_enrollment_bad_quality = 3

  _VALUES_TO_NAMES = {
    0: "Biofinger_matching_no_hit",
    1: "Biofinger_matching_FFD",
    2: "Biofinger_matching_moist_finger",
    3: "Biofinger_enrollment_bad_quality",
  }

  _NAMES_TO_VALUES = {
    "Biofinger_matching_no_hit": 0,
    "Biofinger_matching_FFD": 1,
    "Biofinger_matching_moist_finger": 2,
    "Biofinger_enrollment_bad_quality": 3,
  }

class Biofinger_command:
  """
  Enumeration representing the finger position/command event sent by the sensor.
  """
  biofinger_move_no_finger = 0
  biofinger_move_finger_up = 1
  biofinger_move_finger_down = 2
  biofinger_move_finger_left = 3
  biofinger_move_finger_right = 4
  biofinger_press_finger_harder = 5
  biofinger_latent = 6
  biofinger_remove_finger = 7
  biofinger_finger_ok = 8
  biofinger_finger_detected = 9
  biofinger_finger_misplaced = 10
  biofinger_live_ok = 11

  _VALUES_TO_NAMES = {
    0: "biofinger_move_no_finger",
    1: "biofinger_move_finger_up",
    2: "biofinger_move_finger_down",
    3: "biofinger_move_finger_left",
    4: "biofinger_move_finger_right",
    5: "biofinger_press_finger_harder",
    6: "biofinger_latent",
    7: "biofinger_remove_finger",
    8: "biofinger_finger_ok",
    9: "biofinger_finger_detected",
    10: "biofinger_finger_misplaced",
    11: "biofinger_live_ok",
  }

  _NAMES_TO_VALUES = {
    "biofinger_move_no_finger": 0,
    "biofinger_move_finger_up": 1,
    "biofinger_move_finger_down": 2,
    "biofinger_move_finger_left": 3,
    "biofinger_move_finger_right": 4,
    "biofinger_press_finger_harder": 5,
    "biofinger_latent": 6,
    "biofinger_remove_finger": 7,
    "biofinger_finger_ok": 8,
    "biofinger_finger_detected": 9,
    "biofinger_finger_misplaced": 10,
    "biofinger_live_ok": 11,
  }

class Biofinger_compression_type:
  """
  Enumeration representing compression used in an exported image.
  """
  null_algo = 0
  v1_algo = 1
  wsq_algo = 2

  _VALUES_TO_NAMES = {
    0: "null_algo",
    1: "v1_algo",
    2: "wsq_algo",
  }

  _NAMES_TO_VALUES = {
    "null_algo": 0,
    "v1_algo": 1,
    "wsq_algo": 2,
  }

class Biofinger_template_type:
  """
  Enumeration representing the format handled by the sensor in biometric operations.
  """
  pkcompv2 = 0
  pkmat = 1
  ansi378_2004 = 2
  iso19794_2_fmc_cs = 3
  iso19794_2_fmc_ns = 4
  iso19794_2_fmr = 5
  iso19794_2_fmc_cs_aa = 6
  minex_a = 7
  din_v66400_cs = 8
  din_v66400_cs_aa = 9
  multimodal = 10
  bioscrypt = 11
  pklite = 12

  _VALUES_TO_NAMES = {
    0: "pkcompv2",
    1: "pkmat",
    2: "ansi378_2004",
    3: "iso19794_2_fmc_cs",
    4: "iso19794_2_fmc_ns",
    5: "iso19794_2_fmr",
    6: "iso19794_2_fmc_cs_aa",
    7: "minex_a",
    8: "din_v66400_cs",
    9: "din_v66400_cs_aa",
    10: "multimodal",
    11: "bioscrypt",
    12: "pklite",
  }

  _NAMES_TO_VALUES = {
    "pkcompv2": 0,
    "pkmat": 1,
    "ansi378_2004": 2,
    "iso19794_2_fmc_cs": 3,
    "iso19794_2_fmc_ns": 4,
    "iso19794_2_fmr": 5,
    "iso19794_2_fmc_cs_aa": 6,
    "minex_a": 7,
    "din_v66400_cs": 8,
    "din_v66400_cs_aa": 9,
    "multimodal": 10,
    "bioscrypt": 11,
    "pklite": 12,
  }

class Biofinger_async_event:
  """
  Enumeration representing the events that can be monitored.
  """
  finger_positions = 0
  low_resol_live_images = 1
  enrollment_steps = 2
  high_resol_captures_image = 3
  captures_quality = 4
  live_quality = 5

  _VALUES_TO_NAMES = {
    0: "finger_positions",
    1: "low_resol_live_images",
    2: "enrollment_steps",
    3: "high_resol_captures_image",
    4: "captures_quality",
    5: "live_quality",
  }

  _NAMES_TO_VALUES = {
    "finger_positions": 0,
    "low_resol_live_images": 1,
    "enrollment_steps": 2,
    "high_resol_captures_image": 3,
    "captures_quality": 4,
    "live_quality": 5,
  }

class Biofinger_sensor_security_level:
  """
  Enumeration representing the MSI/FVP security level to use.
  """
  MSIFFD_low = 0
  MSIFFD_medium = 1
  MSIFFD_high = 2
  FVP_standard = 3
  FVP_medium = 4
  FVP_high = 5

  _VALUES_TO_NAMES = {
    0: "MSIFFD_low",
    1: "MSIFFD_medium",
    2: "MSIFFD_high",
    3: "FVP_standard",
    4: "FVP_medium",
    5: "FVP_high",
  }

  _NAMES_TO_VALUES = {
    "MSIFFD_low": 0,
    "MSIFFD_medium": 1,
    "MSIFFD_high": 2,
    "FVP_standard": 3,
    "FVP_medium": 4,
    "FVP_high": 5,
  }

class Biofinger_sensor_matching_strategy:
  """
  Enumeration representing the matching strategy to apply.
  """
  standard_strategy = 0
  advanced_strategy = 1

  _VALUES_TO_NAMES = {
    0: "standard_strategy",
    1: "advanced_strategy",
  }

  _NAMES_TO_VALUES = {
    "standard_strategy": 0,
    "advanced_strategy": 1,
  }

class Enrollment_type:
  """
  Enumeration representing the operation of the enrollment process.
  """
  store = 0
  transfer = 1
  both = 2

  _VALUES_TO_NAMES = {
    0: "store",
    1: "transfer",
    2: "both",
  }

  _NAMES_TO_VALUES = {
    "store": 0,
    "transfer": 1,
    "both": 2,
  }


class Biofinger_control_final_result:
  """
  Attributes:
   - success: Indicate matching result.</br>
  True for hit, false for error or no hit.
   - cause: Indicate the cause of the error.</br>
  Present if success field is false.
   - matching_score: If success field if true, score of the matching operation. </br>
  It shall have been requested in the request.
   - matching_template_number: If success field is true, number of the finger that matched with captured one (see Biofinger_control_optional_param::require_matching_score).
   - user_ID_UTF8: User ID.</br>
  It is filled once the user ID is known, whatever the final result is.
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
    (2, TType.I32, 'cause', None, None, ), # 2
    (3, TType.BYTE, 'matching_score', None, None, ), # 3
    (4, TType.BYTE, 'matching_template_number', None, None, ), # 4
    (5, TType.STRING, 'user_ID_UTF8', None, None, ), # 5
  )

  def __init__(self, success=None, cause=None, matching_score=None, matching_template_number=None, user_ID_UTF8=None,):
    self.success = success
    self.cause = cause
    self.matching_score = matching_score
    self.matching_template_number = matching_template_number
    self.user_ID_UTF8 = user_ID_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cause = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.matching_score = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.matching_template_number = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.user_ID_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Biofinger_control_final_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.cause is not None:
      oprot.writeFieldBegin('cause', TType.I32, 2)
      oprot.writeI32(self.cause)
      oprot.writeFieldEnd()
    if self.matching_score is not None:
      oprot.writeFieldBegin('matching_score', TType.BYTE, 3)
      oprot.writeByte(self.matching_score)
      oprot.writeFieldEnd()
    if self.matching_template_number is not None:
      oprot.writeFieldBegin('matching_template_number', TType.BYTE, 4)
      oprot.writeByte(self.matching_template_number)
      oprot.writeFieldEnd()
    if self.user_ID_UTF8 is not None:
      oprot.writeFieldBegin('user_ID_UTF8', TType.STRING, 5)
      oprot.writeString(self.user_ID_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.success is None:
      raise TProtocol.TProtocolException(message='Required field success is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Biofinger_callback_command:
  """
  Attributes:
   - command: Finger placement modification required, or finger data acquisition completed.</br>
  Sent as intermediate reply of biometric command.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'command', None, None, ), # 1
  )

  def __init__(self, command=None,):
    self.command = command

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.command = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Biofinger_callback_command')
    if self.command is not None:
      oprot.writeFieldBegin('command', TType.I32, 1)
      oprot.writeI32(self.command)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.command is None:
      raise TProtocol.TProtocolException(message='Required field command is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Biofinger_sensor_image:
  """
  Attributes:
   - width_in_pix: Width of the image in pixels.
   - height_in_pix: Height of the image in pixels.
   - horizontal_resol_dpi: Horizontal resolution of the image in dot per inch.
   - vertical_resol_dpi: Vertical resolution of the image in dot per inch.
   - compression_type: Compression algorithm used on the image.
   - image_data: Image's binary data.
   - bits_per_pixel: Number of bits per pixel for the image.</br>
  Present in intermediate replies' images of biometric commands.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'width_in_pix', None, None, ), # 1
    (2, TType.I32, 'height_in_pix', None, None, ), # 2
    (3, TType.I32, 'horizontal_resol_dpi', None, None, ), # 3
    (4, TType.I32, 'vertical_resol_dpi', None, None, ), # 4
    (5, TType.I32, 'compression_type', None, None, ), # 5
    (6, TType.STRING, 'image_data', None, None, ), # 6
    (7, TType.BYTE, 'bits_per_pixel', None, None, ), # 7
  )

  def __init__(self, width_in_pix=None, height_in_pix=None, horizontal_resol_dpi=None, vertical_resol_dpi=None, compression_type=None, image_data=None, bits_per_pixel=None,):
    self.width_in_pix = width_in_pix
    self.height_in_pix = height_in_pix
    self.horizontal_resol_dpi = horizontal_resol_dpi
    self.vertical_resol_dpi = vertical_resol_dpi
    self.compression_type = compression_type
    self.image_data = image_data
    self.bits_per_pixel = bits_per_pixel

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.width_in_pix = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.height_in_pix = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.horizontal_resol_dpi = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.vertical_resol_dpi = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.compression_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.image_data = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BYTE:
          self.bits_per_pixel = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Biofinger_sensor_image')
    if self.width_in_pix is not None:
      oprot.writeFieldBegin('width_in_pix', TType.I32, 1)
      oprot.writeI32(self.width_in_pix)
      oprot.writeFieldEnd()
    if self.height_in_pix is not None:
      oprot.writeFieldBegin('height_in_pix', TType.I32, 2)
      oprot.writeI32(self.height_in_pix)
      oprot.writeFieldEnd()
    if self.horizontal_resol_dpi is not None:
      oprot.writeFieldBegin('horizontal_resol_dpi', TType.I32, 3)
      oprot.writeI32(self.horizontal_resol_dpi)
      oprot.writeFieldEnd()
    if self.vertical_resol_dpi is not None:
      oprot.writeFieldBegin('vertical_resol_dpi', TType.I32, 4)
      oprot.writeI32(self.vertical_resol_dpi)
      oprot.writeFieldEnd()
    if self.compression_type is not None:
      oprot.writeFieldBegin('compression_type', TType.I32, 5)
      oprot.writeI32(self.compression_type)
      oprot.writeFieldEnd()
    if self.image_data is not None:
      oprot.writeFieldBegin('image_data', TType.STRING, 6)
      oprot.writeString(self.image_data)
      oprot.writeFieldEnd()
    if self.bits_per_pixel is not None:
      oprot.writeFieldBegin('bits_per_pixel', TType.BYTE, 7)
      oprot.writeByte(self.bits_per_pixel)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.width_in_pix is None:
      raise TProtocol.TProtocolException(message='Required field width_in_pix is unset!')
    if self.height_in_pix is None:
      raise TProtocol.TProtocolException(message='Required field height_in_pix is unset!')
    if self.horizontal_resol_dpi is None:
      raise TProtocol.TProtocolException(message='Required field horizontal_resol_dpi is unset!')
    if self.vertical_resol_dpi is None:
      raise TProtocol.TProtocolException(message='Required field vertical_resol_dpi is unset!')
    if self.compression_type is None:
      raise TProtocol.TProtocolException(message='Required field compression_type is unset!')
    if self.image_data is None:
      raise TProtocol.TProtocolException(message='Required field image_data is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class User_templates:
  """
  Attributes:
   - template_type: Type of the template.
   - template_data: Ttemplate data.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'template_type', None, None, ), # 1
    (2, TType.STRING, 'template_data', None, None, ), # 2
  )

  def __init__(self, template_type=None, template_data=None,):
    self.template_type = template_type
    self.template_data = template_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.template_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.template_data = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('User_templates')
    if self.template_type is not None:
      oprot.writeFieldBegin('template_type', TType.I32, 1)
      oprot.writeI32(self.template_type)
      oprot.writeFieldEnd()
    if self.template_data is not None:
      oprot.writeFieldBegin('template_data', TType.STRING, 2)
      oprot.writeString(self.template_data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.template_type is None:
      raise TProtocol.TProtocolException(message='Required field template_type is unset!')
    if self.template_data is None:
      raise TProtocol.TProtocolException(message='Required field template_data is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Biofinger_enroll_final_result:
  """
  Attributes:
   - success: Indicate enrollment result.</br>
  True for success, false for error.
   - cause: Indicate the cause of the error.</br>
  Present if success field is false.
   - fp_templates: Binary fingerprint templates of the user.</br>
  Present if success is true and templates are required in the command.
   - fv_templates: Binary fingervein templates of the user.</br>
  Present if success is true and templates are required in the command.
   - best_finger_images: Binary result best images of the fingers.</br>
  Present if success is true and images are required in the command (see Biofinger_enrolloptional_param::require_best_fingers_images).</br>
  1 image per finger.
   - finger_qualities: Result qualities of the captured fingers.</br>
  Present if success is true and final qualities are required in the command (see Biofinger_enroll_optional_param::require_fingers_qualities).</br>
  1 quality per finger.
   - security_compatibilities: Indicate if the enrolled templates complies with sensor security level.</br>
  Present if requested in the command (see Biofinger_enroll_optional_param::require_security_compatibilty).</br>
  1 parameter per finger.
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
    (2, TType.I32, 'cause', None, None, ), # 2
    (3, TType.LIST, 'fp_templates', (TType.STRUCT,(User_templates, User_templates.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'fv_templates', (TType.STRUCT,(User_templates, User_templates.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'best_finger_images', (TType.STRUCT,(Biofinger_sensor_image, Biofinger_sensor_image.thrift_spec)), None, ), # 5
    (6, TType.LIST, 'finger_qualities', (TType.BYTE,None), None, ), # 6
    (7, TType.LIST, 'security_compatibilities', (TType.I16,None), None, ), # 7
  )

  def __init__(self, success=None, cause=None, fp_templates=None, fv_templates=None, best_finger_images=None, finger_qualities=None, security_compatibilities=None,):
    self.success = success
    self.cause = cause
    self.fp_templates = fp_templates
    self.fv_templates = fv_templates
    self.best_finger_images = best_finger_images
    self.finger_qualities = finger_qualities
    self.security_compatibilities = security_compatibilities

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cause = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.fp_templates = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = User_templates()
            _elem5.read(iprot)
            self.fp_templates.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fv_templates = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = User_templates()
            _elem11.read(iprot)
            self.fv_templates.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.best_finger_images = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = Biofinger_sensor_image()
            _elem17.read(iprot)
            self.best_finger_images.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.finger_qualities = []
          (_etype21, _size18) = iprot.readListBegin()
          for _i22 in xrange(_size18):
            _elem23 = iprot.readByte();
            self.finger_qualities.append(_elem23)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.security_compatibilities = []
          (_etype27, _size24) = iprot.readListBegin()
          for _i28 in xrange(_size24):
            _elem29 = iprot.readI16();
            self.security_compatibilities.append(_elem29)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Biofinger_enroll_final_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.cause is not None:
      oprot.writeFieldBegin('cause', TType.I32, 2)
      oprot.writeI32(self.cause)
      oprot.writeFieldEnd()
    if self.fp_templates is not None:
      oprot.writeFieldBegin('fp_templates', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.fp_templates))
      for iter30 in self.fp_templates:
        iter30.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fv_templates is not None:
      oprot.writeFieldBegin('fv_templates', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.fv_templates))
      for iter31 in self.fv_templates:
        iter31.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.best_finger_images is not None:
      oprot.writeFieldBegin('best_finger_images', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.best_finger_images))
      for iter32 in self.best_finger_images:
        iter32.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.finger_qualities is not None:
      oprot.writeFieldBegin('finger_qualities', TType.LIST, 6)
      oprot.writeListBegin(TType.BYTE, len(self.finger_qualities))
      for iter33 in self.finger_qualities:
        oprot.writeByte(iter33)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.security_compatibilities is not None:
      oprot.writeFieldBegin('security_compatibilities', TType.LIST, 7)
      oprot.writeListBegin(TType.I16, len(self.security_compatibilities))
      for iter34 in self.security_compatibilities:
        oprot.writeI16(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.success is None:
      raise TProtocol.TProtocolException(message='Required field success is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Biofinger_callback_enrollment_step:
  """
  Attributes:
   - current_finger: Current finger number for the enrollment process (starting to 1).
   - total_finger: Total number of fingers for the enrollment process.
   - current_capture: Current capture of the current finger (starting to 1).
   - total_capture: Total number of captures for one finger.
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'current_finger', None, None, ), # 1
    (2, TType.BYTE, 'total_finger', None, None, ), # 2
    (3, TType.BYTE, 'current_capture', None, None, ), # 3
    (4, TType.BYTE, 'total_capture', None, None, ), # 4
  )

  def __init__(self, current_finger=None, total_finger=None, current_capture=None, total_capture=None,):
    self.current_finger = current_finger
    self.total_finger = total_finger
    self.current_capture = current_capture
    self.total_capture = total_capture

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.current_finger = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.total_finger = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.current_capture = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.total_capture = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Biofinger_callback_enrollment_step')
    if self.current_finger is not None:
      oprot.writeFieldBegin('current_finger', TType.BYTE, 1)
      oprot.writeByte(self.current_finger)
      oprot.writeFieldEnd()
    if self.total_finger is not None:
      oprot.writeFieldBegin('total_finger', TType.BYTE, 2)
      oprot.writeByte(self.total_finger)
      oprot.writeFieldEnd()
    if self.current_capture is not None:
      oprot.writeFieldBegin('current_capture', TType.BYTE, 3)
      oprot.writeByte(self.current_capture)
      oprot.writeFieldEnd()
    if self.total_capture is not None:
      oprot.writeFieldBegin('total_capture', TType.BYTE, 4)
      oprot.writeByte(self.total_capture)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.current_finger is None:
      raise TProtocol.TProtocolException(message='Required field current_finger is unset!')
    if self.total_finger is None:
      raise TProtocol.TProtocolException(message='Required field total_finger is unset!')
    if self.current_capture is None:
      raise TProtocol.TProtocolException(message='Required field current_capture is unset!')
    if self.total_capture is None:
      raise TProtocol.TProtocolException(message='Required field total_capture is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Biofinger_enroll_operation_reply:
  """
  Attributes:
   - final_result: Final reply of authenticate/identify command. </br>
  If final_result is present, none of the other fields shall be
  present.
   - cb_bio_command: Intermediate reply that is used to:
  <ul>
  <li>indicate that there is a wrongly placed finger on the sensor, and then the action that the user has to perform.</li>
  <li>provide information about the state of the fingerprint process (fingerprint wait started, fingerprint acquisition completed).</li>
  </ul>
  It shall have been requested in the command (see @a Biofinger_async_event::finger_positions).
   - cb_low_resol_live_image: Intermediate reply that is used to transmit images from the sensor whatever there is a fingerprint or not.</br>
  The terminal sends live images in low resolution until the end of the fingerprint acquisition process, with a reduced size to provide a convenient image throughput.</br>
  It shall have been requested in the command (see @a Biofinger_async_event::low_resol_live_images).
   - cb_enroll_step: Intermediate reply that is used to indicate the enrollment process steps.</br>
  For example, during the enrollment of one finger with three images, the terminal sends three messages (enrollment of finger 1 of 1, acquisition 1, 2 and 3).</br>
  It shall have been requested in the command (see @a Biofinger_async_event::enrollment_steps).
   - cb_high_resol_capture_image: Intermediate reply that is used to transmit only one image: the image of the current capture (May be several capture per finger).</br>
  It shall have been requested in the command (see @a Biofinger_async_event::high_resol_captures_image).
   - cb_capture_quality: Intermediate reply that is used to provide the quality value of the capture (May be several capture per finger).</br>
  It shall have been requested in the command (see @a Biofinger_async_event::captures_quality).
   - cb_live_quality: Intermediate reply that is used to provide the quality note of the live fingerprint image, which is calculated by the presence detection function.</br>
  It shall have been requested in the command (see @a Biofinger_async_event::live_quality).
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'final_result', (Biofinger_enroll_final_result, Biofinger_enroll_final_result.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'cb_bio_command', (Biofinger_callback_command, Biofinger_callback_command.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'cb_low_resol_live_image', (Biofinger_sensor_image, Biofinger_sensor_image.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'cb_enroll_step', (Biofinger_callback_enrollment_step, Biofinger_callback_enrollment_step.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'cb_high_resol_capture_image', (Biofinger_sensor_image, Biofinger_sensor_image.thrift_spec), None, ), # 5
    (6, TType.I32, 'cb_capture_quality', None, None, ), # 6
    (7, TType.I32, 'cb_live_quality', None, None, ), # 7
  )

  def __init__(self, final_result=None, cb_bio_command=None, cb_low_resol_live_image=None, cb_enroll_step=None, cb_high_resol_capture_image=None, cb_capture_quality=None, cb_live_quality=None,):
    self.final_result = final_result
    self.cb_bio_command = cb_bio_command
    self.cb_low_resol_live_image = cb_low_resol_live_image
    self.cb_enroll_step = cb_enroll_step
    self.cb_high_resol_capture_image = cb_high_resol_capture_image
    self.cb_capture_quality = cb_capture_quality
    self.cb_live_quality = cb_live_quality

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.final_result = Biofinger_enroll_final_result()
          self.final_result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.cb_bio_command = Biofinger_callback_command()
          self.cb_bio_command.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.cb_low_resol_live_image = Biofinger_sensor_image()
          self.cb_low_resol_live_image.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.cb_enroll_step = Biofinger_callback_enrollment_step()
          self.cb_enroll_step.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.cb_high_resol_capture_image = Biofinger_sensor_image()
          self.cb_high_resol_capture_image.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.cb_capture_quality = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.cb_live_quality = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Biofinger_enroll_operation_reply')
    if self.final_result is not None:
      oprot.writeFieldBegin('final_result', TType.STRUCT, 1)
      self.final_result.write(oprot)
      oprot.writeFieldEnd()
    if self.cb_bio_command is not None:
      oprot.writeFieldBegin('cb_bio_command', TType.STRUCT, 2)
      self.cb_bio_command.write(oprot)
      oprot.writeFieldEnd()
    if self.cb_low_resol_live_image is not None:
      oprot.writeFieldBegin('cb_low_resol_live_image', TType.STRUCT, 3)
      self.cb_low_resol_live_image.write(oprot)
      oprot.writeFieldEnd()
    if self.cb_enroll_step is not None:
      oprot.writeFieldBegin('cb_enroll_step', TType.STRUCT, 4)
      self.cb_enroll_step.write(oprot)
      oprot.writeFieldEnd()
    if self.cb_high_resol_capture_image is not None:
      oprot.writeFieldBegin('cb_high_resol_capture_image', TType.STRUCT, 5)
      self.cb_high_resol_capture_image.write(oprot)
      oprot.writeFieldEnd()
    if self.cb_capture_quality is not None:
      oprot.writeFieldBegin('cb_capture_quality', TType.I32, 6)
      oprot.writeI32(self.cb_capture_quality)
      oprot.writeFieldEnd()
    if self.cb_live_quality is not None:
      oprot.writeFieldBegin('cb_live_quality', TType.I32, 7)
      oprot.writeI32(self.cb_live_quality)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Biofinger_control_operation_reply:
  """
  Attributes:
   - final_result: Final reply of authenticate/identify command. </br>
  If final_result is present, none of the other fields shall be
  present.
   - cb_bio_command: Intermediate reply that is used to:
  <ul>
  <li>indicate that there is a wrongly placed finger on the sensor, and then the action that the user has to perform.</li>
  <li>provide information about the state of the fingerprint process (fingerprint wait started, fingerprint acquisition completed).</li>
  </ul>
  It shall have been requested in the request (see @a Biofinger_async_event::finger_positions).
   - cb_low_resol_live_image: Intermediate reply that is used to transmit images from the sensor whatever there is a fingerprint or not.</br>
  The terminal sends live images in low resolution until the end of the fingerprint acquisition process, with a reduced size to provide a convenient image throughput.</br>
  It shall have been requested in the command (see @a Biofinger_async_event::low_resol_live_images).
   - cb_high_resol_capture_image: Intermediate reply that is used to transmit only one image: the image of the current capture (May be several capture per finger).</br>
  It shall have been requested in the command (see @a Biofinger_async_event::high_resol_captures_image).
   - cb_capture_quality: Intermediate reply that is used to provide the quality value of the acquired fingerprint image.</br>
  It shall have been requested in the command (see @a Biofinger_async_event::captures_quality).
   - cb_live_quality: Intermediate reply that is used to provide the quality note of the live fingerprint image, which is calculated by the presence detection function.</br>
  It shall have been requested in the command (see @a Biofinger_async_event::live_quality).
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'final_result', (Biofinger_control_final_result, Biofinger_control_final_result.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'cb_bio_command', (Biofinger_callback_command, Biofinger_callback_command.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'cb_low_resol_live_image', (Biofinger_sensor_image, Biofinger_sensor_image.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'cb_high_resol_capture_image', (Biofinger_sensor_image, Biofinger_sensor_image.thrift_spec), None, ), # 4
    (5, TType.I32, 'cb_capture_quality', None, None, ), # 5
    (6, TType.I32, 'cb_live_quality', None, None, ), # 6
  )

  def __init__(self, final_result=None, cb_bio_command=None, cb_low_resol_live_image=None, cb_high_resol_capture_image=None, cb_capture_quality=None, cb_live_quality=None,):
    self.final_result = final_result
    self.cb_bio_command = cb_bio_command
    self.cb_low_resol_live_image = cb_low_resol_live_image
    self.cb_high_resol_capture_image = cb_high_resol_capture_image
    self.cb_capture_quality = cb_capture_quality
    self.cb_live_quality = cb_live_quality

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.final_result = Biofinger_control_final_result()
          self.final_result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.cb_bio_command = Biofinger_callback_command()
          self.cb_bio_command.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.cb_low_resol_live_image = Biofinger_sensor_image()
          self.cb_low_resol_live_image.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.cb_high_resol_capture_image = Biofinger_sensor_image()
          self.cb_high_resol_capture_image.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.cb_capture_quality = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.cb_live_quality = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Biofinger_control_operation_reply')
    if self.final_result is not None:
      oprot.writeFieldBegin('final_result', TType.STRUCT, 1)
      self.final_result.write(oprot)
      oprot.writeFieldEnd()
    if self.cb_bio_command is not None:
      oprot.writeFieldBegin('cb_bio_command', TType.STRUCT, 2)
      self.cb_bio_command.write(oprot)
      oprot.writeFieldEnd()
    if self.cb_low_resol_live_image is not None:
      oprot.writeFieldBegin('cb_low_resol_live_image', TType.STRUCT, 3)
      self.cb_low_resol_live_image.write(oprot)
      oprot.writeFieldEnd()
    if self.cb_high_resol_capture_image is not None:
      oprot.writeFieldBegin('cb_high_resol_capture_image', TType.STRUCT, 4)
      self.cb_high_resol_capture_image.write(oprot)
      oprot.writeFieldEnd()
    if self.cb_capture_quality is not None:
      oprot.writeFieldBegin('cb_capture_quality', TType.I32, 5)
      oprot.writeI32(self.cb_capture_quality)
      oprot.writeFieldEnd()
    if self.cb_live_quality is not None:
      oprot.writeFieldBegin('cb_live_quality', TType.I32, 6)
      oprot.writeI32(self.cb_live_quality)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Biofinger_control_optional_param:
  """
  Attributes:
   - events: List of event to subscribe to.
   - require_matching_score: Matching score is required in final answer.
   - security_level: On MSI or VP equipped terminals, indicate the security level to use for the operation.
   - coder: Shall not be used.
   - detection_mode: Shall not be used.
   - matching_strategy: Shall not be used, right now.
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'events', (TType.I32,None), None, ), # 1
    (2, TType.BOOL, 'require_matching_score', None, None, ), # 2
    (3, TType.I32, 'security_level', None, None, ), # 3
    (4, TType.I32, 'coder', None, None, ), # 4
    (5, TType.I32, 'detection_mode', None, None, ), # 5
    (6, TType.I32, 'matching_strategy', None, None, ), # 6
  )

  def __init__(self, events=None, require_matching_score=None, security_level=None, coder=None, detection_mode=None, matching_strategy=None,):
    self.events = events
    self.require_matching_score = require_matching_score
    self.security_level = security_level
    self.coder = coder
    self.detection_mode = detection_mode
    self.matching_strategy = matching_strategy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.events = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = iprot.readI32();
            self.events.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.require_matching_score = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.security_level = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.coder = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.detection_mode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.matching_strategy = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Biofinger_control_optional_param')
    if self.events is not None:
      oprot.writeFieldBegin('events', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.events))
      for iter41 in self.events:
        oprot.writeI32(iter41)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.require_matching_score is not None:
      oprot.writeFieldBegin('require_matching_score', TType.BOOL, 2)
      oprot.writeBool(self.require_matching_score)
      oprot.writeFieldEnd()
    if self.security_level is not None:
      oprot.writeFieldBegin('security_level', TType.I32, 3)
      oprot.writeI32(self.security_level)
      oprot.writeFieldEnd()
    if self.coder is not None:
      oprot.writeFieldBegin('coder', TType.I32, 4)
      oprot.writeI32(self.coder)
      oprot.writeFieldEnd()
    if self.detection_mode is not None:
      oprot.writeFieldBegin('detection_mode', TType.I32, 5)
      oprot.writeI32(self.detection_mode)
      oprot.writeFieldEnd()
    if self.matching_strategy is not None:
      oprot.writeFieldBegin('matching_strategy', TType.I32, 6)
      oprot.writeI32(self.matching_strategy)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Biofinger_enroll_optional_param:
  """
  Attributes:
   - events: List of event to subscribe to.
   - fp_template_format: Specify the format of the fingerprint templates to be exported.
   - fv_template_format: Specify the format of the fingervein templates to be exported. (FingerVein-equipped terminals only)
   - require_best_fingers_images: Best image of each captured fingers is required in the reply.
   - require_latent: Require latent detection.</br>
  Not recommanded for standard enrollment.
  TODO: Will be removed if Enroll CBI API does not allow it
   - security_level: On MSI or VP equipped terminals, indicate the security level to use for the operation.
   - coder: Shall not be used.
   - detection_mode: Shall no be used.
   - require_fingers_qualities: Quality of each captured fingers is required in the reply.
   - require_security_compatibilty: Compliance with sensor security level is required in the reply.
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'events', (TType.I32,None), None, ), # 1
    (2, TType.I32, 'fp_template_format', None, None, ), # 2
    (3, TType.I32, 'fv_template_format', None, None, ), # 3
    (4, TType.BOOL, 'require_best_fingers_images', None, None, ), # 4
    (5, TType.BOOL, 'require_latent', None, None, ), # 5
    (6, TType.I32, 'security_level', None, None, ), # 6
    (7, TType.I32, 'coder', None, None, ), # 7
    (8, TType.I32, 'detection_mode', None, None, ), # 8
    (9, TType.BOOL, 'require_fingers_qualities', None, None, ), # 9
    (10, TType.BOOL, 'require_security_compatibilty', None, None, ), # 10
  )

  def __init__(self, events=None, fp_template_format=None, fv_template_format=None, require_best_fingers_images=None, require_latent=None, security_level=None, coder=None, detection_mode=None, require_fingers_qualities=None, require_security_compatibilty=None,):
    self.events = events
    self.fp_template_format = fp_template_format
    self.fv_template_format = fv_template_format
    self.require_best_fingers_images = require_best_fingers_images
    self.require_latent = require_latent
    self.security_level = security_level
    self.coder = coder
    self.detection_mode = detection_mode
    self.require_fingers_qualities = require_fingers_qualities
    self.require_security_compatibilty = require_security_compatibilty

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.events = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readI32();
            self.events.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.fp_template_format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.fv_template_format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.require_best_fingers_images = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.require_latent = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.security_level = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.coder = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.detection_mode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.require_fingers_qualities = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.require_security_compatibilty = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Biofinger_enroll_optional_param')
    if self.events is not None:
      oprot.writeFieldBegin('events', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.events))
      for iter48 in self.events:
        oprot.writeI32(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fp_template_format is not None:
      oprot.writeFieldBegin('fp_template_format', TType.I32, 2)
      oprot.writeI32(self.fp_template_format)
      oprot.writeFieldEnd()
    if self.fv_template_format is not None:
      oprot.writeFieldBegin('fv_template_format', TType.I32, 3)
      oprot.writeI32(self.fv_template_format)
      oprot.writeFieldEnd()
    if self.require_best_fingers_images is not None:
      oprot.writeFieldBegin('require_best_fingers_images', TType.BOOL, 4)
      oprot.writeBool(self.require_best_fingers_images)
      oprot.writeFieldEnd()
    if self.require_latent is not None:
      oprot.writeFieldBegin('require_latent', TType.BOOL, 5)
      oprot.writeBool(self.require_latent)
      oprot.writeFieldEnd()
    if self.security_level is not None:
      oprot.writeFieldBegin('security_level', TType.I32, 6)
      oprot.writeI32(self.security_level)
      oprot.writeFieldEnd()
    if self.coder is not None:
      oprot.writeFieldBegin('coder', TType.I32, 7)
      oprot.writeI32(self.coder)
      oprot.writeFieldEnd()
    if self.detection_mode is not None:
      oprot.writeFieldBegin('detection_mode', TType.I32, 8)
      oprot.writeI32(self.detection_mode)
      oprot.writeFieldEnd()
    if self.require_fingers_qualities is not None:
      oprot.writeFieldBegin('require_fingers_qualities', TType.BOOL, 9)
      oprot.writeBool(self.require_fingers_qualities)
      oprot.writeFieldEnd()
    if self.require_security_compatibilty is not None:
      oprot.writeFieldBegin('require_security_compatibilty', TType.BOOL, 10)
      oprot.writeBool(self.require_security_compatibilty)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Misplaced_finger_error(TException):
  """
  The finger was misplaced or has been withdrawn during finger acquisition performed.</br>
  On FingerVein-equipped terminals only.

  Attributes:
   - err_code: Error code that represents the error.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Misplaced_finger_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Unsupported_format_error(TException):
  """
  The format of the fingerprint template is not supported, or the fingerprint data does not match its type.

  Attributes:
   - err_code: Error code that represents the error.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Unsupported_format_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Incompatible_ref_error(TException):
  """
  A reference template does not match sensor security policy.

  Attributes:
   - err_code: Error code that represents the error.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Incompatible_ref_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Duplicated_finger_error(TException):
  """
  User uses a finger more than once.

  Attributes:
   - err_code: Error code that represents the error.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Duplicated_finger_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
