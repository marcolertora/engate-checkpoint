# -*- encoding: utf-8 -*-
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:twisted
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import Generic_types.ttypes
import Security_types.ttypes
import Biofinger_types.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Cls_card_type:
  """
  Contactless card type.
  """
  mifare_classic = 0
  mifare_aes = 1
  mifare_desfire_3des = 2
  mifare_desfire_aes = 3
  iclass = 4
  l1_site_key = 5
  rsa1024 = 6

  _VALUES_TO_NAMES = {
    0: "mifare_classic",
    1: "mifare_aes",
    2: "mifare_desfire_3des",
    3: "mifare_desfire_aes",
    4: "iclass",
    5: "l1_site_key",
    6: "rsa1024",
  }

  _NAMES_TO_VALUES = {
    "mifare_classic": 0,
    "mifare_aes": 1,
    "mifare_desfire_3des": 2,
    "mifare_desfire_aes": 3,
    "iclass": 4,
    "l1_site_key": 5,
    "rsa1024": 6,
  }

class Cls_iso14443_layer:
  """
  Contactless card information.
  """
  level_3 = 0
  level_4 = 1

  _VALUES_TO_NAMES = {
    0: "level_3",
    1: "level_4",
  }

  _NAMES_TO_VALUES = {
    "level_3": 0,
    "level_4": 1,
  }

class Cls_iso14443_type:
  type_A = 0
  type_B = 1

  _VALUES_TO_NAMES = {
    0: "type_A",
    1: "type_B",
  }

  _NAMES_TO_VALUES = {
    "type_A": 0,
    "type_B": 1,
  }

class Cls_algo:
  """
  Contactless key algorithm
  """
  algo_crypto1 = 0
  algo_legacy3des = 1
  algo_aes128 = 2

  _VALUES_TO_NAMES = {
    0: "algo_crypto1",
    1: "algo_legacy3des",
    2: "algo_aes128",
  }

  _NAMES_TO_VALUES = {
    "algo_crypto1": 0,
    "algo_legacy3des": 1,
    "algo_aes128": 2,
  }

class Cls_diversify_algo:
  """
  List of supported diversification algorithms
  """
  diversify_morpho = 0
  diversify_bioscrypt = 1

  _VALUES_TO_NAMES = {
    0: "diversify_morpho",
    1: "diversify_bioscrypt",
  }

  _NAMES_TO_VALUES = {
    "diversify_morpho": 0,
    "diversify_bioscrypt": 1,
  }

class Cls_desfire_file_security:
  """
  Defines the level of security for the communication with the reader
  (according to DESFire MF3ICD81 functional specification).
  """
  plain_comm = 0
  macing = 1
  full_enciphered = 2

  _VALUES_TO_NAMES = {
    0: "plain_comm",
    1: "macing",
    2: "full_enciphered",
  }

  _NAMES_TO_VALUES = {
    "plain_comm": 0,
    "macing": 1,
    "full_enciphered": 2,
  }

class Cls_desfire_app_key:
  """
  DESFire file access right
  """
  access_right_master_app_key = 0
  access_right_key_1 = 1
  access_right_key_2 = 2
  access_right_key_3 = 3
  access_right_key_4 = 4
  access_right_key_5 = 5
  access_right_key_6 = 6
  access_right_key_7 = 7
  access_right_key_8 = 8
  access_right_key_9 = 9
  access_right_key_10 = 10
  access_right_key_11 = 11
  access_right_key_12 = 12
  access_right_key_13 = 13
  access_right_always = 14
  access_right_never = 15

  _VALUES_TO_NAMES = {
    0: "access_right_master_app_key",
    1: "access_right_key_1",
    2: "access_right_key_2",
    3: "access_right_key_3",
    4: "access_right_key_4",
    5: "access_right_key_5",
    6: "access_right_key_6",
    7: "access_right_key_7",
    8: "access_right_key_8",
    9: "access_right_key_9",
    10: "access_right_key_10",
    11: "access_right_key_11",
    12: "access_right_key_12",
    13: "access_right_key_13",
    14: "access_right_always",
    15: "access_right_never",
  }

  _NAMES_TO_VALUES = {
    "access_right_master_app_key": 0,
    "access_right_key_1": 1,
    "access_right_key_2": 2,
    "access_right_key_3": 3,
    "access_right_key_4": 4,
    "access_right_key_5": 5,
    "access_right_key_6": 6,
    "access_right_key_7": 7,
    "access_right_key_8": 8,
    "access_right_key_9": 9,
    "access_right_key_10": 10,
    "access_right_key_11": 11,
    "access_right_key_12": 12,
    "access_right_key_13": 13,
    "access_right_always": 14,
    "access_right_never": 15,
  }

class Cls_mifare_security_policy:
  """
  MIFARE security policy
  """
  mifare_key_A = 0
  mifare_key_B = 1
  mifare_key_A_then_B = 2

  _VALUES_TO_NAMES = {
    0: "mifare_key_A",
    1: "mifare_key_B",
    2: "mifare_key_A_then_B",
  }

  _NAMES_TO_VALUES = {
    "mifare_key_A": 0,
    "mifare_key_B": 1,
    "mifare_key_A_then_B": 2,
  }

class Cls_card_mode:
  id_only = 0
  bio = 1
  pin = 2
  pin_bio = 3

  _VALUES_TO_NAMES = {
    0: "id_only",
    1: "bio",
    2: "pin",
    3: "pin_bio",
  }

  _NAMES_TO_VALUES = {
    "id_only": 0,
    "bio": 1,
    "pin": 2,
    "pin_bio": 3,
  }

class cls_authent_user_checks:
  biometric = 0
  PIN = 1
  BIOPIN = 2

  _VALUES_TO_NAMES = {
    0: "biometric",
    1: "PIN",
    2: "BIOPIN",
  }

  _NAMES_TO_VALUES = {
    "biometric": 0,
    "PIN": 1,
    "BIOPIN": 2,
  }

class cls_authent_user_final_result:
  verification_succeeded = 0
  PIN_verification_failed = 1
  BIOPIN_verification_failed = 2
  biometric_verification_failed = 3

  _VALUES_TO_NAMES = {
    0: "verification_succeeded",
    1: "PIN_verification_failed",
    2: "BIOPIN_verification_failed",
    3: "biometric_verification_failed",
  }

  _NAMES_TO_VALUES = {
    "verification_succeeded": 0,
    "PIN_verification_failed": 1,
    "BIOPIN_verification_failed": 2,
    "biometric_verification_failed": 3,
  }


class Cls_iso14443_card:
  """
  Attributes:
   - iso14443_layer: Indicates if the detected card is compliant to level 3 or 4 of ISO14443 standard
   - iso14443_type: Indicates if the detected card is an ISO14443 B or A card
   - serial_number: Serial number of detected card
   - user_id_string: Serial number of detected card in string format
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'iso14443_layer', None, None, ), # 1
    (2, TType.I32, 'iso14443_type', None, None, ), # 2
    (3, TType.STRING, 'serial_number', None, None, ), # 3
    (4, TType.STRING, 'user_id_string', None, None, ), # 4
  )

  def __init__(self, iso14443_layer=None, iso14443_type=None, serial_number=None, user_id_string=None,):
    self.iso14443_layer = iso14443_layer
    self.iso14443_type = iso14443_type
    self.serial_number = serial_number
    self.user_id_string = user_id_string

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.iso14443_layer = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.iso14443_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.serial_number = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.user_id_string = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_iso14443_card')
    if self.iso14443_layer is not None:
      oprot.writeFieldBegin('iso14443_layer', TType.I32, 1)
      oprot.writeI32(self.iso14443_layer)
      oprot.writeFieldEnd()
    if self.iso14443_type is not None:
      oprot.writeFieldBegin('iso14443_type', TType.I32, 2)
      oprot.writeI32(self.iso14443_type)
      oprot.writeFieldEnd()
    if self.serial_number is not None:
      oprot.writeFieldBegin('serial_number', TType.STRING, 3)
      oprot.writeString(self.serial_number)
      oprot.writeFieldEnd()
    if self.user_id_string is not None:
      oprot.writeFieldBegin('user_id_string', TType.STRING, 4)
      oprot.writeString(self.user_id_string)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.iso14443_layer is None:
      raise TProtocol.TProtocolException(message='Required field iso14443_layer is unset!')
    if self.iso14443_type is None:
      raise TProtocol.TProtocolException(message='Required field iso14443_type is unset!')
    if self.serial_number is None:
      raise TProtocol.TProtocolException(message='Required field serial_number is unset!')
    if self.user_id_string is None:
      raise TProtocol.TProtocolException(message='Required field user_id_string is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_prox_card:
  """
  Attributes:
   - serial_number: Serial number of detected card(User ID extracted from complete wiegand string), e.g. format of binary data is, For decimal number 12 it's equivalent binary(i.e. 1100) and each bit should be in seperate byte(i.e. 0x01, 0x01, 0x00, 0x00)
   - wiegand_string: Whole wiegand string of detected card
   - user_id: user id in string format for ex "12345"
   - port_id: port id from which data came
   - protocol_type: 0 for wiegand protocol & 1 for clock&data protocol
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'serial_number', None, None, ), # 1
    (2, TType.STRING, 'wiegand_string', None, None, ), # 2
    (3, TType.STRING, 'user_id', None, None, ), # 3
    (4, TType.I16, 'port_id', None, None, ), # 4
    (5, TType.I32, 'protocol_type', None, None, ), # 5
  )

  def __init__(self, serial_number=None, wiegand_string=None, user_id=None, port_id=None, protocol_type=None,):
    self.serial_number = serial_number
    self.wiegand_string = wiegand_string
    self.user_id = user_id
    self.port_id = port_id
    self.protocol_type = protocol_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.serial_number = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.wiegand_string = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.port_id = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.protocol_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_prox_card')
    if self.serial_number is not None:
      oprot.writeFieldBegin('serial_number', TType.STRING, 1)
      oprot.writeString(self.serial_number)
      oprot.writeFieldEnd()
    if self.wiegand_string is not None:
      oprot.writeFieldBegin('wiegand_string', TType.STRING, 2)
      oprot.writeString(self.wiegand_string)
      oprot.writeFieldEnd()
    if self.user_id is not None:
      oprot.writeFieldBegin('user_id', TType.STRING, 3)
      oprot.writeString(self.user_id)
      oprot.writeFieldEnd()
    if self.port_id is not None:
      oprot.writeFieldBegin('port_id', TType.I16, 4)
      oprot.writeI16(self.port_id)
      oprot.writeFieldEnd()
    if self.protocol_type is not None:
      oprot.writeFieldBegin('protocol_type', TType.I32, 5)
      oprot.writeI32(self.protocol_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.serial_number is None:
      raise TProtocol.TProtocolException(message='Required field serial_number is unset!')
    if self.wiegand_string is None:
      raise TProtocol.TProtocolException(message='Required field wiegand_string is unset!')
    if self.user_id is None:
      raise TProtocol.TProtocolException(message='Required field user_id is unset!')
    if self.port_id is None:
      raise TProtocol.TProtocolException(message='Required field port_id is unset!')
    if self.protocol_type is None:
      raise TProtocol.TProtocolException(message='Required field protocol_type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_card_info:
  """
  Contains information about detected card


  The card can be ISO14443 compliant or a Prox card. But not both.

  Attributes:
   - iso14443_card
   - prox_card
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'iso14443_card', (Cls_iso14443_card, Cls_iso14443_card.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'prox_card', (Cls_prox_card, Cls_prox_card.thrift_spec), None, ), # 2
  )

  def __init__(self, iso14443_card=None, prox_card=None,):
    self.iso14443_card = iso14443_card
    self.prox_card = prox_card

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.iso14443_card = Cls_iso14443_card()
          self.iso14443_card.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.prox_card = Cls_prox_card()
          self.prox_card.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_card_info')
    if self.iso14443_card is not None:
      oprot.writeFieldBegin('iso14443_card', TType.STRUCT, 1)
      self.iso14443_card.write(oprot)
      oprot.writeFieldEnd()
    if self.prox_card is not None:
      oprot.writeFieldBegin('prox_card', TType.STRUCT, 2)
      self.prox_card.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_info:
  """
  Attributes:
   - card_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'card_info', (Cls_card_info, Cls_card_info.thrift_spec), None, ), # 1
  )

  def __init__(self, card_info=None,):
    self.card_info = card_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.card_info = Cls_card_info()
          self.card_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_info')
    if self.card_info is not None:
      oprot.writeFieldBegin('card_info', TType.STRUCT, 1)
      self.card_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.card_info is None:
      raise TProtocol.TProtocolException(message='Required field card_info is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_key_iclass:
  """
  iClass contactless key.

  Attributes:
   - index: Sector index (0 to 8).<br/>
  Index 0 to 7 for BOOK 0<br/>
  Index 8 for BOOK 1<br/>
   - key_1: Value of the key 1 (8 bytes).
   - key_2: Value of the key 2 (8 bytes).
   - validity_start: Key validity start date (Only date is used. Time is not used).
   - validity_duration: Key validity duration (in days).<br/>
  If 0, then infinite time to live duration (default value).
   - version: Key version.<br/>
  For a key, if the version is different from 0,
  the version for a new value to set must be superior to the previous one.<br/>
  If not present, 0 will be used as default value.

  Version range: 0 to 255
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'index', None, None, ), # 1
    (2, TType.STRING, 'key_1', None, None, ), # 2
    (3, TType.STRING, 'key_2', None, None, ), # 3
    (4, TType.STRUCT, 'validity_start', (Generic_types.ttypes.Date_time, Generic_types.ttypes.Date_time.thrift_spec), None, ), # 4
    (5, TType.I32, 'validity_duration', None, None, ), # 5
    (6, TType.I32, 'version', None, None, ), # 6
  )

  def __init__(self, index=None, key_1=None, key_2=None, validity_start=None, validity_duration=None, version=None,):
    self.index = index
    self.key_1 = key_1
    self.key_2 = key_2
    self.validity_start = validity_start
    self.validity_duration = validity_duration
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.index = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key_1 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key_2 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.validity_start = Generic_types.ttypes.Date_time()
          self.validity_start.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.validity_duration = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_key_iclass')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.BYTE, 1)
      oprot.writeByte(self.index)
      oprot.writeFieldEnd()
    if self.key_1 is not None:
      oprot.writeFieldBegin('key_1', TType.STRING, 2)
      oprot.writeString(self.key_1)
      oprot.writeFieldEnd()
    if self.key_2 is not None:
      oprot.writeFieldBegin('key_2', TType.STRING, 3)
      oprot.writeString(self.key_2)
      oprot.writeFieldEnd()
    if self.validity_start is not None:
      oprot.writeFieldBegin('validity_start', TType.STRUCT, 4)
      self.validity_start.write(oprot)
      oprot.writeFieldEnd()
    if self.validity_duration is not None:
      oprot.writeFieldBegin('validity_duration', TType.I32, 5)
      oprot.writeI32(self.validity_duration)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 6)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.index is None:
      raise TProtocol.TProtocolException(message='Required field index is unset!')
    if self.validity_start is None:
      raise TProtocol.TProtocolException(message='Required field validity_start is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_key_mifare:
  """
  Mifare Classic and Plus contactless key.<br/>
  At least one of the key (A or B) must be provided.

  Attributes:
   - algo: Key algorithm.<br/>
  Valid algo: algo_crypto1, algo_aes128
   - index: Sector index (0 to 39).
   - keyA: Value of the key A (6 bytes), if algo is algo_crypto1.<br/>
  Value of the key A (16 bytes), if algo is algo_aes128.
   - keyB: Value of the key B (6 bytes), if algo is algo_crypto1.<br/>
  Value of the key B (16 bytes), if algo is algo_aes128.
   - validity_start: Key validity start date (Only date is used. Time is not used).
   - validity_duration: Key validity duration (in days).<br/>
  If 0, then infinite time to live duration (default value).
   - version: Key version.<br/>
  For a key, if the version is different from 0,
  the version for a new value to set must be superior to the previous one.<br/>
  If not present, 0 will be used as default value.

  Version range: 0 to 255
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'algo', None, None, ), # 1
    (2, TType.BYTE, 'index', None, None, ), # 2
    (3, TType.STRING, 'keyA', None, None, ), # 3
    (4, TType.STRING, 'keyB', None, None, ), # 4
    (5, TType.STRUCT, 'validity_start', (Generic_types.ttypes.Date_time, Generic_types.ttypes.Date_time.thrift_spec), None, ), # 5
    (6, TType.I32, 'validity_duration', None, None, ), # 6
    (7, TType.I32, 'version', None, None, ), # 7
  )

  def __init__(self, algo=None, index=None, keyA=None, keyB=None, validity_start=None, validity_duration=None, version=None,):
    self.algo = algo
    self.index = index
    self.keyA = keyA
    self.keyB = keyB
    self.validity_start = validity_start
    self.validity_duration = validity_duration
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.algo = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.index = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.keyA = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.keyB = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.validity_start = Generic_types.ttypes.Date_time()
          self.validity_start.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.validity_duration = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_key_mifare')
    if self.algo is not None:
      oprot.writeFieldBegin('algo', TType.I32, 1)
      oprot.writeI32(self.algo)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.BYTE, 2)
      oprot.writeByte(self.index)
      oprot.writeFieldEnd()
    if self.keyA is not None:
      oprot.writeFieldBegin('keyA', TType.STRING, 3)
      oprot.writeString(self.keyA)
      oprot.writeFieldEnd()
    if self.keyB is not None:
      oprot.writeFieldBegin('keyB', TType.STRING, 4)
      oprot.writeString(self.keyB)
      oprot.writeFieldEnd()
    if self.validity_start is not None:
      oprot.writeFieldBegin('validity_start', TType.STRUCT, 5)
      self.validity_start.write(oprot)
      oprot.writeFieldEnd()
    if self.validity_duration is not None:
      oprot.writeFieldBegin('validity_duration', TType.I32, 6)
      oprot.writeI32(self.validity_duration)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 7)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.algo is None:
      raise TProtocol.TProtocolException(message='Required field algo is unset!')
    if self.index is None:
      raise TProtocol.TProtocolException(message='Required field index is unset!')
    if self.validity_start is None:
      raise TProtocol.TProtocolException(message='Required field validity_start is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_key_desfire:
  """
  DESFire contactless key

  Attributes:
   - algo: Key algorithm.<br/>
  Valid algo: algo_legacy3des, algo_aes128
   - id: ID of the key inside the terminal secure container.<br/>
  List of the IDs used when reading/writing a MorphoAccess card:

  <br/><b>DESFire Morpho cards</b>
  <table><tr><th>ID</th><th>Description</th></tr>
  <tr><td>    0      </td><td>    Master PICC key.         </td></tr>
  <tr><td>    1      </td><td>    Application master key.  </td></tr>
  <tr><td>    2      </td><td>    File read key.           </td></tr>
  </table>

  <br/><b>DESFire ADP cards</b>
  <table><tr><th>ID</th><th>Description</th></tr>
  <tr><td>    3      </td><td>    Master PICC key.         </td></tr>
  <tr><td>    4      </td><td>    Application master key.  </td></tr>
  <tr><td>    5      </td><td>    ID file read key.        </td></tr>
  <tr><td>    6      </td><td>    ID file write key.       </td></tr>
  <tr><td>    7      </td><td>    BIO file read key.       </td></tr>
  <tr><td>    8      </td><td>    BIO file write key.      </td></tr>
  <tr><td>    9      </td><td>    PIN file read key.       </td></tr>
  <tr><td>    10     </td><td>    PIN file write key.      </td></tr>
  <tr><td>    11     </td><td>    Template cipher key.     </td></tr>
  </table>

  <br/>
  If algo = algo_aes128
  ID Range: 0 to 15<br/>
  <br/>
  If algo = algo_legacy3des
  ID Range: 0 to 16<br/>
  Key with id = 16 will be used to decrypt ADP cards
   - data: Value of the key (16 bytes).
   - validity_start: Key validity start date (Only date is used. Time is not used).
   - validity_duration: Key validity duration (in days).<br/>
  If 0, then infinite time to live duration (default value).
   - version: Key version.<br/>
  For a key, if the version is different from 0,
  the version for a new value to set must be superior to the previous one.<br/>
  If not present, 0 will be used as default value.

  Version range: 0 to 255
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'algo', None, None, ), # 1
    (2, TType.I32, 'id', None, None, ), # 2
    (3, TType.STRING, 'data', None, None, ), # 3
    (4, TType.STRUCT, 'validity_start', (Generic_types.ttypes.Date_time, Generic_types.ttypes.Date_time.thrift_spec), None, ), # 4
    (5, TType.I32, 'validity_duration', None, None, ), # 5
    (6, TType.I32, 'version', None, None, ), # 6
  )

  def __init__(self, algo=None, id=None, data=None, validity_start=None, validity_duration=None, version=None,):
    self.algo = algo
    self.id = id
    self.data = data
    self.validity_start = validity_start
    self.validity_duration = validity_duration
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.algo = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.data = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.validity_start = Generic_types.ttypes.Date_time()
          self.validity_start.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.validity_duration = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_key_desfire')
    if self.algo is not None:
      oprot.writeFieldBegin('algo', TType.I32, 1)
      oprot.writeI32(self.algo)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 2)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 3)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    if self.validity_start is not None:
      oprot.writeFieldBegin('validity_start', TType.STRUCT, 4)
      self.validity_start.write(oprot)
      oprot.writeFieldEnd()
    if self.validity_duration is not None:
      oprot.writeFieldBegin('validity_duration', TType.I32, 5)
      oprot.writeI32(self.validity_duration)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 6)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.algo is None:
      raise TProtocol.TProtocolException(message='Required field algo is unset!')
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.data is None:
      raise TProtocol.TProtocolException(message='Required field data is unset!')
    if self.validity_start is None:
      raise TProtocol.TProtocolException(message='Required field validity_start is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_key_l1:
  """
  L1 site key

  Attributes:
   - index: Sector index (0 or 1). 0 - Primary key, 1 - Secondary key
   - data: Value of the key (16 bytes).
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'index', None, None, ), # 1
    (2, TType.STRING, 'data', None, None, ), # 2
  )

  def __init__(self, index=None, data=None,):
    self.index = index
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.index = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.data = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_key_l1')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.BYTE, 1)
      oprot.writeByte(self.index)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 2)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.index is None:
      raise TProtocol.TProtocolException(message='Required field index is unset!')
    if self.data is None:
      raise TProtocol.TProtocolException(message='Required field data is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_key_rsa:
  """
  RSA key structure.<br/>


  Attributes:
   - index: Index (0 to 15).
   - private_exp: Value of the private exponent (128 bytes).
   - modulo: Value of the modulo (128 bytes).
   - public_exp: Value of the public exponent (4 bytes).
   - validity_start: Key validity start date (Only date is used. Time is not used).
   - validity_duration: Key validity duration (in days).<br/>
  If 0, then infinite time to live duration (default value).
   - version: Key version.<br/>
  For a key, if the version is different from 0,
  the version for a new value to set must be superior to the previous one.<br/>
  If not present, 0 will be used as default value.

  Version range: 0 to 255
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'index', None, None, ), # 1
    (2, TType.STRING, 'private_exp', None, None, ), # 2
    (3, TType.STRING, 'modulo', None, None, ), # 3
    (4, TType.STRING, 'public_exp', None, None, ), # 4
    (5, TType.STRUCT, 'validity_start', (Generic_types.ttypes.Date_time, Generic_types.ttypes.Date_time.thrift_spec), None, ), # 5
    (6, TType.I32, 'validity_duration', None, None, ), # 6
    (7, TType.I32, 'version', None, None, ), # 7
  )

  def __init__(self, index=None, private_exp=None, modulo=None, public_exp=None, validity_start=None, validity_duration=None, version=None,):
    self.index = index
    self.private_exp = private_exp
    self.modulo = modulo
    self.public_exp = public_exp
    self.validity_start = validity_start
    self.validity_duration = validity_duration
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.index = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.private_exp = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.modulo = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.public_exp = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.validity_start = Generic_types.ttypes.Date_time()
          self.validity_start.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.validity_duration = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_key_rsa')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.BYTE, 1)
      oprot.writeByte(self.index)
      oprot.writeFieldEnd()
    if self.private_exp is not None:
      oprot.writeFieldBegin('private_exp', TType.STRING, 2)
      oprot.writeString(self.private_exp)
      oprot.writeFieldEnd()
    if self.modulo is not None:
      oprot.writeFieldBegin('modulo', TType.STRING, 3)
      oprot.writeString(self.modulo)
      oprot.writeFieldEnd()
    if self.public_exp is not None:
      oprot.writeFieldBegin('public_exp', TType.STRING, 4)
      oprot.writeString(self.public_exp)
      oprot.writeFieldEnd()
    if self.validity_start is not None:
      oprot.writeFieldBegin('validity_start', TType.STRUCT, 5)
      self.validity_start.write(oprot)
      oprot.writeFieldEnd()
    if self.validity_duration is not None:
      oprot.writeFieldBegin('validity_duration', TType.I32, 6)
      oprot.writeI32(self.validity_duration)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 7)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.index is None:
      raise TProtocol.TProtocolException(message='Required field index is unset!')
    if self.validity_start is None:
      raise TProtocol.TProtocolException(message='Required field validity_start is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_desfire_file_access_rights:
  """
  DESFire file access rights

  Attributes:
   - read_access: Defines the needed authentication to perform a reading
   - write_access: Defines the needed authentication to perform a writing
   - read_write_access: Defines the needed authentication to perform both reading and writing
   - chmod_access: Defines the needed authentication to modify access rights
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'read_access', None, None, ), # 1
    (2, TType.I32, 'write_access', None, None, ), # 2
    (3, TType.I32, 'read_write_access', None, None, ), # 3
    (4, TType.I32, 'chmod_access', None, None, ), # 4
  )

  def __init__(self, read_access=None, write_access=None, read_write_access=None, chmod_access=None,):
    self.read_access = read_access
    self.write_access = write_access
    self.read_write_access = read_write_access
    self.chmod_access = chmod_access

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.read_access = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.write_access = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.read_write_access = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.chmod_access = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_desfire_file_access_rights')
    if self.read_access is not None:
      oprot.writeFieldBegin('read_access', TType.I32, 1)
      oprot.writeI32(self.read_access)
      oprot.writeFieldEnd()
    if self.write_access is not None:
      oprot.writeFieldBegin('write_access', TType.I32, 2)
      oprot.writeI32(self.write_access)
      oprot.writeFieldEnd()
    if self.read_write_access is not None:
      oprot.writeFieldBegin('read_write_access', TType.I32, 3)
      oprot.writeI32(self.read_write_access)
      oprot.writeFieldEnd()
    if self.chmod_access is not None:
      oprot.writeFieldBegin('chmod_access', TType.I32, 4)
      oprot.writeI32(self.chmod_access)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.read_access is None:
      raise TProtocol.TProtocolException(message='Required field read_access is unset!')
    if self.write_access is None:
      raise TProtocol.TProtocolException(message='Required field write_access is unset!')
    if self.read_write_access is None:
      raise TProtocol.TProtocolException(message='Required field read_write_access is unset!')
    if self.chmod_access is None:
      raise TProtocol.TProtocolException(message='Required field chmod_access is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_desfire_file:
  """
  DESFire file

  Attributes:
   - id: File ID, from 0x00 to 0x1F
   - security: File security
   - access_rights: File access rights
   - file: For writing operation only, the file to encode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'id', None, None, ), # 1
    (2, TType.I32, 'security', None, None, ), # 2
    (3, TType.STRUCT, 'access_rights', (Cls_desfire_file_access_rights, Cls_desfire_file_access_rights.thrift_spec), None, ), # 3
    (4, TType.STRING, 'file', None, None, ), # 4
  )

  def __init__(self, id=None, security=None, access_rights=None, file=None,):
    self.id = id
    self.security = security
    self.access_rights = access_rights
    self.file = file

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.security = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.access_rights = Cls_desfire_file_access_rights()
          self.access_rights.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.file = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_desfire_file')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.BYTE, 1)
      oprot.writeByte(self.id)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.I32, 2)
      oprot.writeI32(self.security)
      oprot.writeFieldEnd()
    if self.access_rights is not None:
      oprot.writeFieldBegin('access_rights', TType.STRUCT, 3)
      self.access_rights.write(oprot)
      oprot.writeFieldEnd()
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.STRING, 4)
      oprot.writeString(self.file)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.security is None:
      raise TProtocol.TProtocolException(message='Required field security is unset!')
    if self.access_rights is None:
      raise TProtocol.TProtocolException(message='Required field access_rights is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_desfire_application:
  """
  DESFire application

  Attributes:
   - app_id: DESFire application AID number (according to DESFire MF3ICD84 functional specification).<br>
  @warning AID number 0x000000 is reserved as a reference to the card level (PICC) itself and cannot be used.
   - algo: Key algorithm.
   - diversify: Diversification algorithm.<br>
  If not present, no diversification will be performed on the application keys.
   - app_key_settings: Application key settings<br>
  See ChangeKeySettings function in DESFire MF3ICD81 functional specification.
   - keys: Application keys
   - file: List of files to read, write or erase from the application
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'app_id', None, None, ), # 1
    (2, TType.I32, 'algo', None, None, ), # 2
    (3, TType.I32, 'diversify', None, None, ), # 3
    (4, TType.BYTE, 'app_key_settings', None, None, ), # 4
    (5, TType.MAP, 'keys', (TType.I32,None,TType.I32,None), None, ), # 5
    (6, TType.LIST, 'file', (TType.STRUCT,(Cls_desfire_file, Cls_desfire_file.thrift_spec)), None, ), # 6
  )

  def __init__(self, app_id=None, algo=None, diversify=None, app_key_settings=None, keys=None, file=None,):
    self.app_id = app_id
    self.algo = algo
    self.diversify = diversify
    self.app_key_settings = app_key_settings
    self.keys = keys
    self.file = file

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.app_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.algo = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.diversify = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.app_key_settings = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.keys = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readI32();
            _val6 = iprot.readI32();
            self.keys[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.file = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = Cls_desfire_file()
            _elem12.read(iprot)
            self.file.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_desfire_application')
    if self.app_id is not None:
      oprot.writeFieldBegin('app_id', TType.I32, 1)
      oprot.writeI32(self.app_id)
      oprot.writeFieldEnd()
    if self.algo is not None:
      oprot.writeFieldBegin('algo', TType.I32, 2)
      oprot.writeI32(self.algo)
      oprot.writeFieldEnd()
    if self.diversify is not None:
      oprot.writeFieldBegin('diversify', TType.I32, 3)
      oprot.writeI32(self.diversify)
      oprot.writeFieldEnd()
    if self.app_key_settings is not None:
      oprot.writeFieldBegin('app_key_settings', TType.BYTE, 4)
      oprot.writeByte(self.app_key_settings)
      oprot.writeFieldEnd()
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.MAP, 5)
      oprot.writeMapBegin(TType.I32, TType.I32, len(self.keys))
      for kiter13,viter14 in self.keys.items():
        oprot.writeI32(kiter13)
        oprot.writeI32(viter14)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.file))
      for iter15 in self.file:
        iter15.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.app_id is None:
      raise TProtocol.TProtocolException(message='Required field app_id is unset!')
    if self.algo is None:
      raise TProtocol.TProtocolException(message='Required field algo is unset!')
    if self.app_key_settings is None:
      raise TProtocol.TProtocolException(message='Required field app_key_settings is unset!')
    if self.keys is None:
      raise TProtocol.TProtocolException(message='Required field keys is unset!')
    if self.file is None:
      raise TProtocol.TProtocolException(message='Required field file is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_desfire_card:
  """
  DESFire card structure definition

  Attributes:
   - master_picc_key: Master PICC key<br>
  The master PICC key is not needed for reading, but may be needed for writing or formatting
   - algo: Key algorithm (required if Master PICC key is provided).
   - diversify: Diversification algorithm.<br>
  If not present, no diversification will be performed on the PICC key.
   - picc_key_settings: PICC key settings<br>
  See ChangeKeySettings function in DESFire MF3ICD81 functional specification.
   - applications: List of DESFire applications to read, write or erase
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'master_picc_key', None, None, ), # 1
    (2, TType.I32, 'algo', None, None, ), # 2
    (3, TType.I32, 'diversify', None, None, ), # 3
    (4, TType.BYTE, 'picc_key_settings', None, None, ), # 4
    (5, TType.LIST, 'applications', (TType.STRUCT,(Cls_desfire_application, Cls_desfire_application.thrift_spec)), None, ), # 5
  )

  def __init__(self, master_picc_key=None, algo=None, diversify=None, picc_key_settings=None, applications=None,):
    self.master_picc_key = master_picc_key
    self.algo = algo
    self.diversify = diversify
    self.picc_key_settings = picc_key_settings
    self.applications = applications

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.master_picc_key = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.algo = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.diversify = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.picc_key_settings = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.applications = []
          (_etype19, _size16) = iprot.readListBegin()
          for _i20 in xrange(_size16):
            _elem21 = Cls_desfire_application()
            _elem21.read(iprot)
            self.applications.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_desfire_card')
    if self.master_picc_key is not None:
      oprot.writeFieldBegin('master_picc_key', TType.I32, 1)
      oprot.writeI32(self.master_picc_key)
      oprot.writeFieldEnd()
    if self.algo is not None:
      oprot.writeFieldBegin('algo', TType.I32, 2)
      oprot.writeI32(self.algo)
      oprot.writeFieldEnd()
    if self.diversify is not None:
      oprot.writeFieldBegin('diversify', TType.I32, 3)
      oprot.writeI32(self.diversify)
      oprot.writeFieldEnd()
    if self.picc_key_settings is not None:
      oprot.writeFieldBegin('picc_key_settings', TType.BYTE, 4)
      oprot.writeByte(self.picc_key_settings)
      oprot.writeFieldEnd()
    if self.applications is not None:
      oprot.writeFieldBegin('applications', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.applications))
      for iter22 in self.applications:
        iter22.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.applications is None:
      raise TProtocol.TProtocolException(message='Required field applications is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_mifare_blocks_list:
  """
  A list of MIFARE blocks with corresponding policy

  Attributes:
   - index: Index of start block
   - security_policy: Security policy for read and write operations
   - nb_blocks: For reading operation only, the number of blocks to read
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'index', None, None, ), # 1
    (2, TType.I32, 'security_policy', None, None, ), # 2
    (3, TType.BYTE, 'nb_blocks', None, None, ), # 3
  )

  def __init__(self, index=None, security_policy=None, nb_blocks=None,):
    self.index = index
    self.security_policy = security_policy
    self.nb_blocks = nb_blocks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.index = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.security_policy = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.nb_blocks = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_mifare_blocks_list')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.BYTE, 1)
      oprot.writeByte(self.index)
      oprot.writeFieldEnd()
    if self.security_policy is not None:
      oprot.writeFieldBegin('security_policy', TType.I32, 2)
      oprot.writeI32(self.security_policy)
      oprot.writeFieldEnd()
    if self.nb_blocks is not None:
      oprot.writeFieldBegin('nb_blocks', TType.BYTE, 3)
      oprot.writeByte(self.nb_blocks)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.index is None:
      raise TProtocol.TProtocolException(message='Required field index is unset!')
    if self.security_policy is None:
      raise TProtocol.TProtocolException(message='Required field security_policy is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_mifare_card:
  """
  MIFARE Classic or Plus card structure definition


  A MIFARE Classic or Plus card is just a list of sectors.

  Attributes:
   - blocks: The list of blocks to read or write
   - algo: Algorithm.
   - diversify: Diversification algorithm.<br>
  If not present, no diversification will be performed on the keys.
   - file: For writing operation only, the file to encode
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'blocks', (Cls_mifare_blocks_list, Cls_mifare_blocks_list.thrift_spec), None, ), # 1
    (2, TType.I32, 'algo', None, None, ), # 2
    (3, TType.I32, 'diversify', None, None, ), # 3
    (4, TType.STRING, 'file', None, None, ), # 4
  )

  def __init__(self, blocks=None, algo=None, diversify=None, file=None,):
    self.blocks = blocks
    self.algo = algo
    self.diversify = diversify
    self.file = file

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.blocks = Cls_mifare_blocks_list()
          self.blocks.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.algo = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.diversify = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.file = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_mifare_card')
    if self.blocks is not None:
      oprot.writeFieldBegin('blocks', TType.STRUCT, 1)
      self.blocks.write(oprot)
      oprot.writeFieldEnd()
    if self.algo is not None:
      oprot.writeFieldBegin('algo', TType.I32, 2)
      oprot.writeI32(self.algo)
      oprot.writeFieldEnd()
    if self.diversify is not None:
      oprot.writeFieldBegin('diversify', TType.I32, 3)
      oprot.writeI32(self.diversify)
      oprot.writeFieldEnd()
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.STRING, 4)
      oprot.writeString(self.file)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.blocks is None:
      raise TProtocol.TProtocolException(message='Required field blocks is unset!')
    if self.algo is None:
      raise TProtocol.TProtocolException(message='Required field algo is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_iclass_card:
  """
  iClass card structure definition

  Attributes:
   - page_offset: Page offset.</br>
  When using a 2K2 card (card containing only 2 applications in 1 page),
  this parameter specifies the starting block address to read/write data.<br/>
  Minimum value is 0x13 (default value if parameter is not present).
  Maximum value is 0xFF.
   - book_number: Book number.<br/>
  When using a card containing more than one book (32K cards),
  this parameter specifies the book to use.<br/>
  Value is 0 (default value if parameter is not present) or 1.
   - book_layout: Book layout.<br/>
  The book layout parameter specifies which pages and application areas the terminal
  is going to use when a 16 application areas card is presented.<br/>
  Even bits (0 based) are flags that mark the application area 1 of the page for use by the terminal.<br/>
  Odd bits (0 based) are flags that mark application area 2 of the page for use by the terminal.<br/>
  <table><tr><th>Bit</th><th>Description</th></tr>
  <tr><td>0</td><td>Page 0, application area 1</td></tr>
  <tr><td>1</td><td>Page 0, application area 2</td></tr>
  <tr><td>2</td><td>Page 1, application area 1</td></tr>
  <tr><td>...</td><td>...</td></tr>
  <tr><td>14</td><td>Page 7, application area 1</td></tr>
  <tr><td>15</td><td>Page 7, application area 2</td></tr>
  </table><br/>
  If the parameter is not present, the terminal will use all application areas,
  starting at page 1, application area 1.
   - diversify: If not present or set to false, no diversification will be performed on the key.
   - file: For writing operation only, the file to encode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'page_offset', None, None, ), # 1
    (2, TType.BYTE, 'book_number', None, None, ), # 2
    (3, TType.I16, 'book_layout', None, None, ), # 3
    (4, TType.BOOL, 'diversify', None, None, ), # 4
    (5, TType.STRING, 'file', None, None, ), # 5
  )

  def __init__(self, page_offset=None, book_number=None, book_layout=None, diversify=None, file=None,):
    self.page_offset = page_offset
    self.book_number = book_number
    self.book_layout = book_layout
    self.diversify = diversify
    self.file = file

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.page_offset = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.book_number = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.book_layout = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.diversify = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.file = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_iclass_card')
    if self.page_offset is not None:
      oprot.writeFieldBegin('page_offset', TType.BYTE, 1)
      oprot.writeByte(self.page_offset)
      oprot.writeFieldEnd()
    if self.book_number is not None:
      oprot.writeFieldBegin('book_number', TType.BYTE, 2)
      oprot.writeByte(self.book_number)
      oprot.writeFieldEnd()
    if self.book_layout is not None:
      oprot.writeFieldBegin('book_layout', TType.I16, 3)
      oprot.writeI16(self.book_layout)
      oprot.writeFieldEnd()
    if self.diversify is not None:
      oprot.writeFieldBegin('diversify', TType.BOOL, 4)
      oprot.writeBool(self.diversify)
      oprot.writeFieldEnd()
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.STRING, 5)
      oprot.writeString(self.file)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_cards_definition:
  """
  Contactless card definition

  Attributes:
   - desfire_cards: Optional list of zero or more DESFire cards definition to operate on
   - mifare_cards: Optional list of zero or more MIFARE Classic or Plus cards definition to operate on
   - iclass_cards: Optional list of zero or more iClass cards definition to operate on
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'desfire_cards', (TType.STRUCT,(Cls_desfire_card, Cls_desfire_card.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'mifare_cards', (TType.STRUCT,(Cls_mifare_card, Cls_mifare_card.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'iclass_cards', (TType.STRUCT,(Cls_iclass_card, Cls_iclass_card.thrift_spec)), None, ), # 3
  )

  def __init__(self, desfire_cards=None, mifare_cards=None, iclass_cards=None,):
    self.desfire_cards = desfire_cards
    self.mifare_cards = mifare_cards
    self.iclass_cards = iclass_cards

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.desfire_cards = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = Cls_desfire_card()
            _elem28.read(iprot)
            self.desfire_cards.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.mifare_cards = []
          (_etype32, _size29) = iprot.readListBegin()
          for _i33 in xrange(_size29):
            _elem34 = Cls_mifare_card()
            _elem34.read(iprot)
            self.mifare_cards.append(_elem34)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.iclass_cards = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = Cls_iclass_card()
            _elem40.read(iprot)
            self.iclass_cards.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_cards_definition')
    if self.desfire_cards is not None:
      oprot.writeFieldBegin('desfire_cards', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.desfire_cards))
      for iter41 in self.desfire_cards:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.mifare_cards is not None:
      oprot.writeFieldBegin('mifare_cards', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.mifare_cards))
      for iter42 in self.mifare_cards:
        iter42.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iclass_cards is not None:
      oprot.writeFieldBegin('iclass_cards', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.iclass_cards))
      for iter43 in self.iclass_cards:
        iter43.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_user_card:
  """
  User contactless card

  Attributes:
   - user_ID_UTF8
   - card_mode
   - template_1
   - template_2
   - pin_code
   - biopin_code
   - user_name_UTF8
   - expiry_date
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user_ID_UTF8', None, None, ), # 1
    (2, TType.I32, 'card_mode', None, None, ), # 2
    (3, TType.STRING, 'template_1', None, None, ), # 3
    (4, TType.STRING, 'template_2', None, None, ), # 4
    (5, TType.STRING, 'pin_code', None, None, ), # 5
    (6, TType.STRING, 'biopin_code', None, None, ), # 6
    (7, TType.STRING, 'user_name_UTF8', None, None, ), # 7
    (8, TType.STRUCT, 'expiry_date', (Generic_types.ttypes.Date_time, Generic_types.ttypes.Date_time.thrift_spec), None, ), # 8
  )

  def __init__(self, user_ID_UTF8=None, card_mode=None, template_1=None, template_2=None, pin_code=None, biopin_code=None, user_name_UTF8=None, expiry_date=None,):
    self.user_ID_UTF8 = user_ID_UTF8
    self.card_mode = card_mode
    self.template_1 = template_1
    self.template_2 = template_2
    self.pin_code = pin_code
    self.biopin_code = biopin_code
    self.user_name_UTF8 = user_name_UTF8
    self.expiry_date = expiry_date

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user_ID_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.card_mode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.template_1 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.template_2 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.pin_code = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.biopin_code = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.user_name_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.expiry_date = Generic_types.ttypes.Date_time()
          self.expiry_date.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_user_card')
    if self.user_ID_UTF8 is not None:
      oprot.writeFieldBegin('user_ID_UTF8', TType.STRING, 1)
      oprot.writeString(self.user_ID_UTF8)
      oprot.writeFieldEnd()
    if self.card_mode is not None:
      oprot.writeFieldBegin('card_mode', TType.I32, 2)
      oprot.writeI32(self.card_mode)
      oprot.writeFieldEnd()
    if self.template_1 is not None:
      oprot.writeFieldBegin('template_1', TType.STRING, 3)
      oprot.writeString(self.template_1)
      oprot.writeFieldEnd()
    if self.template_2 is not None:
      oprot.writeFieldBegin('template_2', TType.STRING, 4)
      oprot.writeString(self.template_2)
      oprot.writeFieldEnd()
    if self.pin_code is not None:
      oprot.writeFieldBegin('pin_code', TType.STRING, 5)
      oprot.writeString(self.pin_code)
      oprot.writeFieldEnd()
    if self.biopin_code is not None:
      oprot.writeFieldBegin('biopin_code', TType.STRING, 6)
      oprot.writeString(self.biopin_code)
      oprot.writeFieldEnd()
    if self.user_name_UTF8 is not None:
      oprot.writeFieldBegin('user_name_UTF8', TType.STRING, 7)
      oprot.writeString(self.user_name_UTF8)
      oprot.writeFieldEnd()
    if self.expiry_date is not None:
      oprot.writeFieldBegin('expiry_date', TType.STRUCT, 8)
      self.expiry_date.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user_ID_UTF8 is None:
      raise TProtocol.TProtocolException(message='Required field user_ID_UTF8 is unset!')
    if self.card_mode is None:
      raise TProtocol.TProtocolException(message='Required field card_mode is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_authent_user_params:
  """
  Structure representing parameters for authenticating an user
  using data contained in a contactless card.

  @warning If @a enable_intermediate_replies is true, you will need a modified version of the Thrift client that supports
           the reception of several T_REPLY messages for one command.

  Attributes:
   - use_card_mode: Use card mode information from card.<br/>
  If set to true, all verifications (biometric, PIN, BIOPIN)
  will be done depending policy stored in the card.
   - check_list: List of the verifications to perform.<br/>
  This parameter is ignored if card mode is set to true.
   - threshold: This parameter specifies the value of the False Acceptance Ratio (FAR) of the MorphoSmart\99 device.<br>
  The value of this parameter can be set from 0 to 10, by 1 value steps.<br/>
  This parameter is used and required only if a biometric verification is performed
  (depending on card mode and biometric check parameters ). Otherwise, it is ignored.
   - enable_intermediate_replies: If set to false, you will receive only one reply containing the final result of the
  authentication, otherwise you may also receive asynchronous replies containing the
  progress status of the authentication.<br/>
  This parameter is used and required only if a biometric verification is performed
  (depending on card mode and biometric check parameters ). Otherwise, it is ignored.
   - bio_optional_param: Biometric check optional parameters
  This parameter is used and required only if a biometric verification is performed
  (depending on card mode and biometric check parameters ). Otherwise, it is ignored.
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'use_card_mode', None, None, ), # 1
    (2, TType.LIST, 'check_list', (TType.I32,None), None, ), # 2
    (3, TType.BYTE, 'threshold', None, None, ), # 3
    (4, TType.BOOL, 'enable_intermediate_replies', None, None, ), # 4
    (5, TType.STRUCT, 'bio_optional_param', (Biofinger_types.ttypes.Biofinger_control_optional_param, Biofinger_types.ttypes.Biofinger_control_optional_param.thrift_spec), None, ), # 5
  )

  def __init__(self, use_card_mode=None, check_list=None, threshold=None, enable_intermediate_replies=None, bio_optional_param=None,):
    self.use_card_mode = use_card_mode
    self.check_list = check_list
    self.threshold = threshold
    self.enable_intermediate_replies = enable_intermediate_replies
    self.bio_optional_param = bio_optional_param

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.use_card_mode = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.check_list = []
          (_etype47, _size44) = iprot.readListBegin()
          for _i48 in xrange(_size44):
            _elem49 = iprot.readI32();
            self.check_list.append(_elem49)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.threshold = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.enable_intermediate_replies = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.bio_optional_param = Biofinger_types.ttypes.Biofinger_control_optional_param()
          self.bio_optional_param.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_authent_user_params')
    if self.use_card_mode is not None:
      oprot.writeFieldBegin('use_card_mode', TType.BOOL, 1)
      oprot.writeBool(self.use_card_mode)
      oprot.writeFieldEnd()
    if self.check_list is not None:
      oprot.writeFieldBegin('check_list', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.check_list))
      for iter50 in self.check_list:
        oprot.writeI32(iter50)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.threshold is not None:
      oprot.writeFieldBegin('threshold', TType.BYTE, 3)
      oprot.writeByte(self.threshold)
      oprot.writeFieldEnd()
    if self.enable_intermediate_replies is not None:
      oprot.writeFieldBegin('enable_intermediate_replies', TType.BOOL, 4)
      oprot.writeBool(self.enable_intermediate_replies)
      oprot.writeFieldEnd()
    if self.bio_optional_param is not None:
      oprot.writeFieldBegin('bio_optional_param', TType.STRUCT, 5)
      self.bio_optional_param.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_authent_user_reply:
  """
  Attributes:
   - final_result: Final reply of "authenticate user with data in contactless card" command.<br/>
  If final_result is present, it is the final reply.
   - bio_result: This result is present in these contexts:
  <ul>
  <li>Final reply containing the biometric result details.</li>
  <li>Intermediate reply containing information on the biometric check in progress.</li>
  </ul>
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'final_result', None, None, ), # 1
    (2, TType.STRUCT, 'bio_result', (Biofinger_types.ttypes.Biofinger_control_operation_reply, Biofinger_types.ttypes.Biofinger_control_operation_reply.thrift_spec), None, ), # 2
  )

  def __init__(self, final_result=None, bio_result=None,):
    self.final_result = final_result
    self.bio_result = bio_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.final_result = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bio_result = Biofinger_types.ttypes.Biofinger_control_operation_reply()
          self.bio_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_authent_user_reply')
    if self.final_result is not None:
      oprot.writeFieldBegin('final_result', TType.I32, 1)
      oprot.writeI32(self.final_result)
      oprot.writeFieldEnd()
    if self.bio_result is not None:
      oprot.writeFieldBegin('bio_result', TType.STRUCT, 2)
      self.bio_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Crypto_keys:
  """
  Structure to manage keys.<br/>
  At least one key list must be provided

  Attributes:
   - mifare_keys: Optional list of MIFARE keys
   - desfire_keys: Optional list of DESFire keys
   - iclass_keys: Optional list of iClass keys
   - l1_keys: Optional list of L1 site keys
   - rsa_keys: Optional list of RSA keys
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'mifare_keys', (TType.STRUCT,(Cls_key_mifare, Cls_key_mifare.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'desfire_keys', (TType.STRUCT,(Cls_key_desfire, Cls_key_desfire.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'iclass_keys', (TType.STRUCT,(Cls_key_iclass, Cls_key_iclass.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'l1_keys', (TType.STRUCT,(Cls_key_l1, Cls_key_l1.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'rsa_keys', (TType.STRUCT,(Cls_key_rsa, Cls_key_rsa.thrift_spec)), None, ), # 5
  )

  def __init__(self, mifare_keys=None, desfire_keys=None, iclass_keys=None, l1_keys=None, rsa_keys=None,):
    self.mifare_keys = mifare_keys
    self.desfire_keys = desfire_keys
    self.iclass_keys = iclass_keys
    self.l1_keys = l1_keys
    self.rsa_keys = rsa_keys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.mifare_keys = []
          (_etype54, _size51) = iprot.readListBegin()
          for _i55 in xrange(_size51):
            _elem56 = Cls_key_mifare()
            _elem56.read(iprot)
            self.mifare_keys.append(_elem56)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.desfire_keys = []
          (_etype60, _size57) = iprot.readListBegin()
          for _i61 in xrange(_size57):
            _elem62 = Cls_key_desfire()
            _elem62.read(iprot)
            self.desfire_keys.append(_elem62)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.iclass_keys = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = Cls_key_iclass()
            _elem68.read(iprot)
            self.iclass_keys.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.l1_keys = []
          (_etype72, _size69) = iprot.readListBegin()
          for _i73 in xrange(_size69):
            _elem74 = Cls_key_l1()
            _elem74.read(iprot)
            self.l1_keys.append(_elem74)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.rsa_keys = []
          (_etype78, _size75) = iprot.readListBegin()
          for _i79 in xrange(_size75):
            _elem80 = Cls_key_rsa()
            _elem80.read(iprot)
            self.rsa_keys.append(_elem80)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Crypto_keys')
    if self.mifare_keys is not None:
      oprot.writeFieldBegin('mifare_keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.mifare_keys))
      for iter81 in self.mifare_keys:
        iter81.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.desfire_keys is not None:
      oprot.writeFieldBegin('desfire_keys', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.desfire_keys))
      for iter82 in self.desfire_keys:
        iter82.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iclass_keys is not None:
      oprot.writeFieldBegin('iclass_keys', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.iclass_keys))
      for iter83 in self.iclass_keys:
        iter83.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.l1_keys is not None:
      oprot.writeFieldBegin('l1_keys', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.l1_keys))
      for iter84 in self.l1_keys:
        iter84.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.rsa_keys is not None:
      oprot.writeFieldBegin('rsa_keys', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.rsa_keys))
      for iter85 in self.rsa_keys:
        iter85.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_invalid_key_error(TException):
  """
  Invalid contactless key specified

  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_invalid_key_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cls_invalid_card_type_error(TException):
  """
  Invalid contactless card type

  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cls_invalid_card_type_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
