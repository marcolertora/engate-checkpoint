#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:twisted
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Capability:
  """
  Enumeration for capabilities
  """
  max_file_size_video = 0
  max_file_size_audio = 1
  max_file_size_picture = 2
  max_file_size_stolen_card_list = 3
  max_file_size_language = 4
  max_file_size_SSL_component = 5
  file_ext_video = 6
  file_ext_audio = 7
  file_ext_picture = 8
  file_ext_language = 9
  file_ext_SSL_component = 10
  max_file_upload_chunk_size = 11
  max_user_DB_records = 12

  _VALUES_TO_NAMES = {
    0: "max_file_size_video",
    1: "max_file_size_audio",
    2: "max_file_size_picture",
    3: "max_file_size_stolen_card_list",
    4: "max_file_size_language",
    5: "max_file_size_SSL_component",
    6: "file_ext_video",
    7: "file_ext_audio",
    8: "file_ext_picture",
    9: "file_ext_language",
    10: "file_ext_SSL_component",
    11: "max_file_upload_chunk_size",
    12: "max_user_DB_records",
  }

  _NAMES_TO_VALUES = {
    "max_file_size_video": 0,
    "max_file_size_audio": 1,
    "max_file_size_picture": 2,
    "max_file_size_stolen_card_list": 3,
    "max_file_size_language": 4,
    "max_file_size_SSL_component": 5,
    "file_ext_video": 6,
    "file_ext_audio": 7,
    "file_ext_picture": 8,
    "file_ext_language": 9,
    "file_ext_SSL_component": 10,
    "max_file_upload_chunk_size": 11,
    "max_user_DB_records": 12,
  }

class Verify_result_code:
  """
  \brief Enum representing verify result codes
  """
  verify_result_ok = 0
  verify_result_ok_multi_user_intermediate_id = 1
  verify_result_ok_multi_user_duplicate_id = 2
  verify_result_ko_user_trigger_mismatch = 3
  verify_result_ko_user_reference_mismatch = 4
  verify_result_ko_user_pin_timed_out = 5
  verify_result_ko_user_pin_not_exists = 6
  verify_result_ko_user_pin_mismath = 7
  verify_result_ko_holiday_scheduled = 8
  verify_result_ko_holiday_schedule_data_not_found = 9
  verify_result_ko_user_not_scheduled = 10
  verify_result_ko_access_schedule_data_not_found = 11
  verify_result_ko_user_bio_expired = 12
  verify_result_ko_user_expiry_data_not_found = 13
  verify_result_ko_user_bio_not_detected = 14
  verify_result_ko_user_bio_canceled = 15
  verify_result_ko_user_bio_mismatch = 16
  verify_result_ko_user_bio_not_found = 17
  verify_result_ko_user_bio_fake_finger_detected = 18
  verify_result_ko_user_bio_moist_finger = 19
  verify_result_ko_user_bio_misplaced_finger = 20
  verify_result_ko_user_bio_unsupported_format = 21
  verify_result_ko_user_bio_incompatible_ref_error = 22
  verify_result_ko_user_not_in_white_list = 23
  verify_result_ko_face_not_detected = 24
  verify_result_ko_job_code_list_not_exists = 25
  verify_result_ko_job_code_check_failure = 26
  verify_result_ko_job_code_timed_out = 27
  verify_result_ko_bio_pin_timed_out = 28
  verify_result_ko_bio_pin_not_exists = 29
  verify_result_ko_bio_pin_mismatch = 30
  verify_result_ko_F_key_timeout = 31
  verify_result_ko_F_key_canceled = 32

  _VALUES_TO_NAMES = {
    0: "verify_result_ok",
    1: "verify_result_ok_multi_user_intermediate_id",
    2: "verify_result_ok_multi_user_duplicate_id",
    3: "verify_result_ko_user_trigger_mismatch",
    4: "verify_result_ko_user_reference_mismatch",
    5: "verify_result_ko_user_pin_timed_out",
    6: "verify_result_ko_user_pin_not_exists",
    7: "verify_result_ko_user_pin_mismath",
    8: "verify_result_ko_holiday_scheduled",
    9: "verify_result_ko_holiday_schedule_data_not_found",
    10: "verify_result_ko_user_not_scheduled",
    11: "verify_result_ko_access_schedule_data_not_found",
    12: "verify_result_ko_user_bio_expired",
    13: "verify_result_ko_user_expiry_data_not_found",
    14: "verify_result_ko_user_bio_not_detected",
    15: "verify_result_ko_user_bio_canceled",
    16: "verify_result_ko_user_bio_mismatch",
    17: "verify_result_ko_user_bio_not_found",
    18: "verify_result_ko_user_bio_fake_finger_detected",
    19: "verify_result_ko_user_bio_moist_finger",
    20: "verify_result_ko_user_bio_misplaced_finger",
    21: "verify_result_ko_user_bio_unsupported_format",
    22: "verify_result_ko_user_bio_incompatible_ref_error",
    23: "verify_result_ko_user_not_in_white_list",
    24: "verify_result_ko_face_not_detected",
    25: "verify_result_ko_job_code_list_not_exists",
    26: "verify_result_ko_job_code_check_failure",
    27: "verify_result_ko_job_code_timed_out",
    28: "verify_result_ko_bio_pin_timed_out",
    29: "verify_result_ko_bio_pin_not_exists",
    30: "verify_result_ko_bio_pin_mismatch",
    31: "verify_result_ko_F_key_timeout",
    32: "verify_result_ko_F_key_canceled",
  }

  _NAMES_TO_VALUES = {
    "verify_result_ok": 0,
    "verify_result_ok_multi_user_intermediate_id": 1,
    "verify_result_ok_multi_user_duplicate_id": 2,
    "verify_result_ko_user_trigger_mismatch": 3,
    "verify_result_ko_user_reference_mismatch": 4,
    "verify_result_ko_user_pin_timed_out": 5,
    "verify_result_ko_user_pin_not_exists": 6,
    "verify_result_ko_user_pin_mismath": 7,
    "verify_result_ko_holiday_scheduled": 8,
    "verify_result_ko_holiday_schedule_data_not_found": 9,
    "verify_result_ko_user_not_scheduled": 10,
    "verify_result_ko_access_schedule_data_not_found": 11,
    "verify_result_ko_user_bio_expired": 12,
    "verify_result_ko_user_expiry_data_not_found": 13,
    "verify_result_ko_user_bio_not_detected": 14,
    "verify_result_ko_user_bio_canceled": 15,
    "verify_result_ko_user_bio_mismatch": 16,
    "verify_result_ko_user_bio_not_found": 17,
    "verify_result_ko_user_bio_fake_finger_detected": 18,
    "verify_result_ko_user_bio_moist_finger": 19,
    "verify_result_ko_user_bio_misplaced_finger": 20,
    "verify_result_ko_user_bio_unsupported_format": 21,
    "verify_result_ko_user_bio_incompatible_ref_error": 22,
    "verify_result_ko_user_not_in_white_list": 23,
    "verify_result_ko_face_not_detected": 24,
    "verify_result_ko_job_code_list_not_exists": 25,
    "verify_result_ko_job_code_check_failure": 26,
    "verify_result_ko_job_code_timed_out": 27,
    "verify_result_ko_bio_pin_timed_out": 28,
    "verify_result_ko_bio_pin_not_exists": 29,
    "verify_result_ko_bio_pin_mismatch": 30,
    "verify_result_ko_F_key_timeout": 31,
    "verify_result_ko_F_key_canceled": 32,
  }

class Param_data_types:
  """
  \brief Enum representing data-types of parameters
  """
  db_integer = 0
  db_unsigned_int = 1
  db_binary = 5
  db_string = 6

  _VALUES_TO_NAMES = {
    0: "db_integer",
    1: "db_unsigned_int",
    5: "db_binary",
    6: "db_string",
  }

  _NAMES_TO_VALUES = {
    "db_integer": 0,
    "db_unsigned_int": 1,
    "db_binary": 5,
    "db_string": 6,
  }

class Generic_error_code:
  """
  Generic error codes
  """
  err_unknown = 0
  err_size_invalid = 1
  err_size_negative = 2
  err_size_zero = 3
  err_buffer_overflow = 4
  err_buffer_underflow = 5
  err_config_inexistent_parameter = 6
  err_config_invalid_value = 7
  err_core_inexistent_user_id = 8
  err_core_timeout = 9
  err_core_out_of_memory = 10
  err_security_default_password = 11
  err_WIFI_module_not_connected = 12
  err_no_space_left_on_device = 13
  err_not_compatible_with_current_license = 14
  err_ethernet_config_not_found = 15
  err_ethernet_configuration_failed = 16
  err_job_code_validation_failed = 17
  err_job_code_list_data_invalid = 18
  err_invalid_job_code_array_length = 19
  err_job_code_list_array_full = 20
  err_wiegand_invalid_wiegand_string = 21
  err_wiegand_output_disabled = 22
  err_host_not_found = 23
  err_license_not_found = 24
  err_sd_card_not_found = 25

  _VALUES_TO_NAMES = {
    0: "err_unknown",
    1: "err_size_invalid",
    2: "err_size_negative",
    3: "err_size_zero",
    4: "err_buffer_overflow",
    5: "err_buffer_underflow",
    6: "err_config_inexistent_parameter",
    7: "err_config_invalid_value",
    8: "err_core_inexistent_user_id",
    9: "err_core_timeout",
    10: "err_core_out_of_memory",
    11: "err_security_default_password",
    12: "err_WIFI_module_not_connected",
    13: "err_no_space_left_on_device",
    14: "err_not_compatible_with_current_license",
    15: "err_ethernet_config_not_found",
    16: "err_ethernet_configuration_failed",
    17: "err_job_code_validation_failed",
    18: "err_job_code_list_data_invalid",
    19: "err_invalid_job_code_array_length",
    20: "err_job_code_list_array_full",
    21: "err_wiegand_invalid_wiegand_string",
    22: "err_wiegand_output_disabled",
    23: "err_host_not_found",
    24: "err_license_not_found",
    25: "err_sd_card_not_found",
  }

  _NAMES_TO_VALUES = {
    "err_unknown": 0,
    "err_size_invalid": 1,
    "err_size_negative": 2,
    "err_size_zero": 3,
    "err_buffer_overflow": 4,
    "err_buffer_underflow": 5,
    "err_config_inexistent_parameter": 6,
    "err_config_invalid_value": 7,
    "err_core_inexistent_user_id": 8,
    "err_core_timeout": 9,
    "err_core_out_of_memory": 10,
    "err_security_default_password": 11,
    "err_WIFI_module_not_connected": 12,
    "err_no_space_left_on_device": 13,
    "err_not_compatible_with_current_license": 14,
    "err_ethernet_config_not_found": 15,
    "err_ethernet_configuration_failed": 16,
    "err_job_code_validation_failed": 17,
    "err_job_code_list_data_invalid": 18,
    "err_invalid_job_code_array_length": 19,
    "err_job_code_list_array_full": 20,
    "err_wiegand_invalid_wiegand_string": 21,
    "err_wiegand_output_disabled": 22,
    "err_host_not_found": 23,
    "err_license_not_found": 24,
    "err_sd_card_not_found": 25,
  }

class Month_in_year:
  """
  Enumeration representing the month in a year
  """
  january = 1
  february = 2
  march = 3
  april = 4
  may = 5
  june = 6
  july = 7
  august = 8
  september = 9
  october = 10
  november = 11
  december = 12

  _VALUES_TO_NAMES = {
    1: "january",
    2: "february",
    3: "march",
    4: "april",
    5: "may",
    6: "june",
    7: "july",
    8: "august",
    9: "september",
    10: "october",
    11: "november",
    12: "december",
  }

  _NAMES_TO_VALUES = {
    "january": 1,
    "february": 2,
    "march": 3,
    "april": 4,
    "may": 5,
    "june": 6,
    "july": 7,
    "august": 8,
    "september": 9,
    "october": 10,
    "november": 11,
    "december": 12,
  }

class Day_in_week:
  """
  Enumeration representing the day in week
  """
  monday = 1
  tuesday = 2
  wednesday = 3
  thursday = 4
  friday = 5
  saturday = 6
  sunday = 7

  _VALUES_TO_NAMES = {
    1: "monday",
    2: "tuesday",
    3: "wednesday",
    4: "thursday",
    5: "friday",
    6: "saturday",
    7: "sunday",
  }

  _NAMES_TO_VALUES = {
    "monday": 1,
    "tuesday": 2,
    "wednesday": 3,
    "thursday": 4,
    "friday": 5,
    "saturday": 6,
    "sunday": 7,
  }

class Date_display_format_type:
  """
  Enumeration representing the date display type
  """
  mm_slash_dd_slash_yyyy = 0
  dd_slash_mm_slash_yyyy = 1
  mmm_dash_dd_dash_yy = 2
  dd_dash_mmm_dash_yy = 3
  yyyy_slash_mm_slash_dd = 4

  _VALUES_TO_NAMES = {
    0: "mm_slash_dd_slash_yyyy",
    1: "dd_slash_mm_slash_yyyy",
    2: "mmm_dash_dd_dash_yy",
    3: "dd_dash_mmm_dash_yy",
    4: "yyyy_slash_mm_slash_dd",
  }

  _NAMES_TO_VALUES = {
    "mm_slash_dd_slash_yyyy": 0,
    "dd_slash_mm_slash_yyyy": 1,
    "mmm_dash_dd_dash_yy": 2,
    "dd_dash_mmm_dash_yy": 3,
    "yyyy_slash_mm_slash_dd": 4,
  }

class Time_display_format_type:
  """
  Enumeration representing the time display type
  """
  hh_colon_mm_colon_ss = 0
  hh_colon_mm_dot_ss = 1

  _VALUES_TO_NAMES = {
    0: "hh_colon_mm_colon_ss",
    1: "hh_colon_mm_dot_ss",
  }

  _NAMES_TO_VALUES = {
    "hh_colon_mm_colon_ss": 0,
    "hh_colon_mm_dot_ss": 1,
  }

class Time_hour_display_type:
  """
  Enumeration representing the time meridian type
  """
  time_12_hour = 0
  time_24_hour = 1

  _VALUES_TO_NAMES = {
    0: "time_12_hour",
    1: "time_24_hour",
  }

  _NAMES_TO_VALUES = {
    "time_12_hour": 0,
    "time_24_hour": 1,
  }

class Communication_system_type:
  """
  The types of the communication system
  """
  half_duplex = 0
  full_duplex = 1

  _VALUES_TO_NAMES = {
    0: "half_duplex",
    1: "full_duplex",
  }

  _NAMES_TO_VALUES = {
    "half_duplex": 0,
    "full_duplex": 1,
  }

class Baud_rate:
  """
  The baud rates supported
  """
  baud_9600 = 9600
  baud_19200 = 19200
  baud_38400 = 38400
  baud_57600 = 57600
  baud_115200 = 115200

  _VALUES_TO_NAMES = {
    9600: "baud_9600",
    19200: "baud_19200",
    38400: "baud_38400",
    57600: "baud_57600",
    115200: "baud_115200",
  }

  _NAMES_TO_VALUES = {
    "baud_9600": 9600,
    "baud_19200": 19200,
    "baud_38400": 38400,
    "baud_57600": 57600,
    "baud_115200": 115200,
  }

class Data_bits:
  """
  The data bits supported
  """
  data_bits_7 = 7
  data_bits_8 = 8

  _VALUES_TO_NAMES = {
    7: "data_bits_7",
    8: "data_bits_8",
  }

  _NAMES_TO_VALUES = {
    "data_bits_7": 7,
    "data_bits_8": 8,
  }

class Parity_bits:
  """
  Parity supported
  """
  no_parity = 0
  odd_parity = 1
  even_parity = 2

  _VALUES_TO_NAMES = {
    0: "no_parity",
    1: "odd_parity",
    2: "even_parity",
  }

  _NAMES_TO_VALUES = {
    "no_parity": 0,
    "odd_parity": 1,
    "even_parity": 2,
  }

class Stop_bits:
  """
  Stop bits supported
  """
  stop_bits_1 = 1
  stop_bits_2 = 2

  _VALUES_TO_NAMES = {
    1: "stop_bits_1",
    2: "stop_bits_2",
  }

  _NAMES_TO_VALUES = {
    "stop_bits_1": 1,
    "stop_bits_2": 2,
  }

class IP_channel:
  ethernet = 0
  wifi = 1
  gprs = 2

  _VALUES_TO_NAMES = {
    0: "ethernet",
    1: "wifi",
    2: "gprs",
  }

  _NAMES_TO_VALUES = {
    "ethernet": 0,
    "wifi": 1,
    "gprs": 2,
  }

class Ip_version_type:
  ip_v4 = 0
  ip_v6 = 1

  _VALUES_TO_NAMES = {
    0: "ip_v4",
    1: "ip_v6",
  }

  _NAMES_TO_VALUES = {
    "ip_v4": 0,
    "ip_v6": 1,
  }

class Terminal_settings_type:
  date_time = 0
  ip = 1
  wifi_cfg = 2
  gprs_cfg = 3
  serial_params_cfg = 4

  _VALUES_TO_NAMES = {
    0: "date_time",
    1: "ip",
    2: "wifi_cfg",
    3: "gprs_cfg",
    4: "serial_params_cfg",
  }

  _NAMES_TO_VALUES = {
    "date_time": 0,
    "ip": 1,
    "wifi_cfg": 2,
    "gprs_cfg": 3,
    "serial_params_cfg": 4,
  }

class WIFI_encryption_type:
  """
  enum for WIFI encryption type
  """
  enc_none = 0
  enc_wep = 1
  enc_wpa_psk = 2
  enc_wpa2_psk = 3

  _VALUES_TO_NAMES = {
    0: "enc_none",
    1: "enc_wep",
    2: "enc_wpa_psk",
    3: "enc_wpa2_psk",
  }

  _NAMES_TO_VALUES = {
    "enc_none": 0,
    "enc_wep": 1,
    "enc_wpa_psk": 2,
    "enc_wpa2_psk": 3,
  }

class IP_protocol_type:
  """
  Enumeration of available distant session state
  """
  ipv4 = 0
  ipv6 = 1
  all = 2

  _VALUES_TO_NAMES = {
    0: "ipv4",
    1: "ipv6",
    2: "all",
  }

  _NAMES_TO_VALUES = {
    "ipv4": 0,
    "ipv6": 1,
    "all": 2,
  }

class Terminal_reset_settings_type:
  """
  List of the settings that can be reset.
  """
  configuration_parameters = 0
  date_time = 1
  ethernet = 2
  serial = 3
  wifi = 4
  video_phone = 5
  crypto_keys = 6
  passwords = 7
  ssl_components = 8
  stolen_card_list = 9
  job_code_lists = 10
  access_schedules = 11
  holiday_schedules = 12
  door_schedule = 13
  authorized_IP_list = 14
  logs = 15
  passphrases = 16
  languages = 17
  multimedia_files = 18
  user_db = 19
  white_list = 20
  dynamic_msg = 21
  vip_list = 22
  events = 23

  _VALUES_TO_NAMES = {
    0: "configuration_parameters",
    1: "date_time",
    2: "ethernet",
    3: "serial",
    4: "wifi",
    5: "video_phone",
    6: "crypto_keys",
    7: "passwords",
    8: "ssl_components",
    9: "stolen_card_list",
    10: "job_code_lists",
    11: "access_schedules",
    12: "holiday_schedules",
    13: "door_schedule",
    14: "authorized_IP_list",
    15: "logs",
    16: "passphrases",
    17: "languages",
    18: "multimedia_files",
    19: "user_db",
    20: "white_list",
    21: "dynamic_msg",
    22: "vip_list",
    23: "events",
  }

  _NAMES_TO_VALUES = {
    "configuration_parameters": 0,
    "date_time": 1,
    "ethernet": 2,
    "serial": 3,
    "wifi": 4,
    "video_phone": 5,
    "crypto_keys": 6,
    "passwords": 7,
    "ssl_components": 8,
    "stolen_card_list": 9,
    "job_code_lists": 10,
    "access_schedules": 11,
    "holiday_schedules": 12,
    "door_schedule": 13,
    "authorized_IP_list": 14,
    "logs": 15,
    "passphrases": 16,
    "languages": 17,
    "multimedia_files": 18,
    "user_db": 19,
    "white_list": 20,
    "dynamic_msg": 21,
    "vip_list": 22,
    "events": 23,
  }

class Terminal_peripherals:
  """
  List of the terminal peripherals.
  """
  screen = 0
  keyboard = 1
  camera = 2
  microphone = 3
  speaker = 4
  contactless_reader_mifare_desfire = 5
  contactless_reader_iclass = 6
  contactless_reader_prox = 7
  sensor_cbi = 8
  wifi = 9
  sd_card = 10
  gprs = 11

  _VALUES_TO_NAMES = {
    0: "screen",
    1: "keyboard",
    2: "camera",
    3: "microphone",
    4: "speaker",
    5: "contactless_reader_mifare_desfire",
    6: "contactless_reader_iclass",
    7: "contactless_reader_prox",
    8: "sensor_cbi",
    9: "wifi",
    10: "sd_card",
    11: "gprs",
  }

  _NAMES_TO_VALUES = {
    "screen": 0,
    "keyboard": 1,
    "camera": 2,
    "microphone": 3,
    "speaker": 4,
    "contactless_reader_mifare_desfire": 5,
    "contactless_reader_iclass": 6,
    "contactless_reader_prox": 7,
    "sensor_cbi": 8,
    "wifi": 9,
    "sd_card": 10,
    "gprs": 11,
  }

class Picture_interface:
  """
  Enumeration of available picture interface for capture feature.
  """
  front_camera = 0
  screen = 1

  _VALUES_TO_NAMES = {
    0: "front_camera",
    1: "screen",
  }

  _NAMES_TO_VALUES = {
    "front_camera": 0,
    "screen": 1,
  }

class Picture_format:
  """
  Enumeration of available picture format for capture and display features.
  """
  JPEG = 0
  BMP = 1
  PNG = 2

  _VALUES_TO_NAMES = {
    0: "JPEG",
    1: "BMP",
    2: "PNG",
  }

  _NAMES_TO_VALUES = {
    "JPEG": 0,
    "BMP": 1,
    "PNG": 2,
  }

class Wiegand_protocol_type:
  """
  enum for protocol type
  """
  wiegand = 0
  clock_and_data = 1

  _VALUES_TO_NAMES = {
    0: "wiegand",
    1: "clock_and_data",
  }

  _NAMES_TO_VALUES = {
    "wiegand": 0,
    "clock_and_data": 1,
  }

class Distant_session_state:
  """
  Enumeration of available distant session state
  """
  opened = 0
  closed = 1

  _VALUES_TO_NAMES = {
    0: "opened",
    1: "closed",
  }

  _NAMES_TO_VALUES = {
    "opened": 0,
    "closed": 1,
  }

class Generic_firmware_type:
  """
  Enumaration of board type
  """
  terminal_firmware = 0
  sensor_firmware = 1

  _VALUES_TO_NAMES = {
    0: "terminal_firmware",
    1: "sensor_firmware",
  }

  _NAMES_TO_VALUES = {
    "terminal_firmware": 0,
    "sensor_firmware": 1,
  }

class Product_info_type:
  """
  Enumeration of info type
  """
  terminal_packaged_part_number = 0
  terminal_packaged_serial_number = 1
  terminal_packaged_comm_name = 2
  sensor_packaged_part_number = 3
  sensor_packaged_serial_number = 4
  specific_part_number = 5
  license_identifier = 6
  license_name = 7
  mac_address_ethernet = 8
  mac_address_wifi = 9
  mac_address_3g_modem = 10

  _VALUES_TO_NAMES = {
    0: "terminal_packaged_part_number",
    1: "terminal_packaged_serial_number",
    2: "terminal_packaged_comm_name",
    3: "sensor_packaged_part_number",
    4: "sensor_packaged_serial_number",
    5: "specific_part_number",
    6: "license_identifier",
    7: "license_name",
    8: "mac_address_ethernet",
    9: "mac_address_wifi",
    10: "mac_address_3g_modem",
  }

  _NAMES_TO_VALUES = {
    "terminal_packaged_part_number": 0,
    "terminal_packaged_serial_number": 1,
    "terminal_packaged_comm_name": 2,
    "sensor_packaged_part_number": 3,
    "sensor_packaged_serial_number": 4,
    "specific_part_number": 5,
    "license_identifier": 6,
    "license_name": 7,
    "mac_address_ethernet": 8,
    "mac_address_wifi": 9,
    "mac_address_3g_modem": 10,
  }

class Protocol_host:
  """
  Enum host protocol
  """
  prot_TCP = 0
  prot_UDP = 1
  prot_SSL = 2

  _VALUES_TO_NAMES = {
    0: "prot_TCP",
    1: "prot_UDP",
    2: "prot_SSL",
  }

  _NAMES_TO_VALUES = {
    "prot_TCP": 0,
    "prot_UDP": 1,
    "prot_SSL": 2,
  }


class Video_phone_params:
  """
  Structure for holding video phone related parameters

  Attributes:
   - name: Name of the profile
   - address_IP: The IP address to call to
   - port: The port to connect to at the given IP address
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'address_IP', None, None, ), # 2
    (3, TType.I16, 'port', None, None, ), # 3
  )

  def __init__(self, name=None, address_IP=None, port=None,):
    self.name = name
    self.address_IP = address_IP
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.address_IP = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Video_phone_params')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.address_IP is not None:
      oprot.writeFieldBegin('address_IP', TType.STRING, 2)
      oprot.writeString(self.address_IP)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I16, 3)
      oprot.writeI16(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.address_IP is None:
      raise TProtocol.TProtocolException(message='Required field address_IP is unset!')
    if self.port is None:
      raise TProtocol.TProtocolException(message='Required field port is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Integer_range:
  """
  Structure containing minimum and maximum values for integer
  and unsigned integer parameters.

  Attributes:
   - min_value: Minimum value in case if range is continuous for eg: "0:10" (min_value = 0)
   - max_value: Maximum value in case if range is continuous for eg: "0:10" (max_value = 10)
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'min_value', None, None, ), # 1
    (2, TType.I32, 'max_value', None, None, ), # 2
  )

  def __init__(self, min_value=None, max_value=None,):
    self.min_value = min_value
    self.max_value = max_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.min_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.max_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Integer_range')
    if self.min_value is not None:
      oprot.writeFieldBegin('min_value', TType.I32, 1)
      oprot.writeI32(self.min_value)
      oprot.writeFieldEnd()
    if self.max_value is not None:
      oprot.writeFieldBegin('max_value', TType.I32, 2)
      oprot.writeI32(self.max_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Parameter_range:
  """
  Range shall be defined by the data type of the parameter.

  Attributes:
   - data_type: Data type of the parameter
   - continuous_range: Available only if value of Param_data_types is "db_integer" and "db_unsigned_int"
   - max_length: Length of the buffer
  Available only if value of Param_data_types is "db_binary" and "db_string"
   - discontinuous_range: List of discontinuous values. For eg: If range is "1,3,5,7,9"
  Available only if value of Param_data_types is "db_integer" and "db_unsigned_int"
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'data_type', None, None, ), # 1
    (2, TType.STRUCT, 'continuous_range', (Integer_range, Integer_range.thrift_spec), None, ), # 2
    (3, TType.I32, 'max_length', None, None, ), # 3
    (4, TType.LIST, 'discontinuous_range', (TType.I32,None), None, ), # 4
  )

  def __init__(self, data_type=None, continuous_range=None, max_length=None, discontinuous_range=None,):
    self.data_type = data_type
    self.continuous_range = continuous_range
    self.max_length = max_length
    self.discontinuous_range = discontinuous_range

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.data_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.continuous_range = Integer_range()
          self.continuous_range.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.max_length = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.discontinuous_range = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI32();
            self.discontinuous_range.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Parameter_range')
    if self.data_type is not None:
      oprot.writeFieldBegin('data_type', TType.I32, 1)
      oprot.writeI32(self.data_type)
      oprot.writeFieldEnd()
    if self.continuous_range is not None:
      oprot.writeFieldBegin('continuous_range', TType.STRUCT, 2)
      self.continuous_range.write(oprot)
      oprot.writeFieldEnd()
    if self.max_length is not None:
      oprot.writeFieldBegin('max_length', TType.I32, 3)
      oprot.writeI32(self.max_length)
      oprot.writeFieldEnd()
    if self.discontinuous_range is not None:
      oprot.writeFieldBegin('discontinuous_range', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.discontinuous_range))
      for iter6 in self.discontinuous_range:
        oprot.writeI32(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.data_type is None:
      raise TProtocol.TProtocolException(message='Required field data_type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Variant:
  """
  A generic datatype


  It is the generic datatype that might be used, for instance, as MA5G configuration parameter.<br>
  Note that only one of the values of interest shall be filled in.

  Attributes:
   - byte_value
   - int16_value
   - int32_value
   - int64_value
   - double_value
   - bool_value
   - UTF8string_value
   - binary_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'byte_value', None, None, ), # 1
    (2, TType.I16, 'int16_value', None, None, ), # 2
    (3, TType.I32, 'int32_value', None, None, ), # 3
    (4, TType.I64, 'int64_value', None, None, ), # 4
    (5, TType.DOUBLE, 'double_value', None, None, ), # 5
    (6, TType.BOOL, 'bool_value', None, None, ), # 6
    (7, TType.STRING, 'UTF8string_value', None, None, ), # 7
    (8, TType.STRING, 'binary_value', None, None, ), # 8
  )

  def __init__(self, byte_value=None, int16_value=None, int32_value=None, int64_value=None, double_value=None, bool_value=None, UTF8string_value=None, binary_value=None,):
    self.byte_value = byte_value
    self.int16_value = int16_value
    self.int32_value = int32_value
    self.int64_value = int64_value
    self.double_value = double_value
    self.bool_value = bool_value
    self.UTF8string_value = UTF8string_value
    self.binary_value = binary_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.byte_value = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.int16_value = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.int32_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.int64_value = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.double_value = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.bool_value = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.UTF8string_value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.binary_value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Variant')
    if self.byte_value is not None:
      oprot.writeFieldBegin('byte_value', TType.BYTE, 1)
      oprot.writeByte(self.byte_value)
      oprot.writeFieldEnd()
    if self.int16_value is not None:
      oprot.writeFieldBegin('int16_value', TType.I16, 2)
      oprot.writeI16(self.int16_value)
      oprot.writeFieldEnd()
    if self.int32_value is not None:
      oprot.writeFieldBegin('int32_value', TType.I32, 3)
      oprot.writeI32(self.int32_value)
      oprot.writeFieldEnd()
    if self.int64_value is not None:
      oprot.writeFieldBegin('int64_value', TType.I64, 4)
      oprot.writeI64(self.int64_value)
      oprot.writeFieldEnd()
    if self.double_value is not None:
      oprot.writeFieldBegin('double_value', TType.DOUBLE, 5)
      oprot.writeDouble(self.double_value)
      oprot.writeFieldEnd()
    if self.bool_value is not None:
      oprot.writeFieldBegin('bool_value', TType.BOOL, 6)
      oprot.writeBool(self.bool_value)
      oprot.writeFieldEnd()
    if self.UTF8string_value is not None:
      oprot.writeFieldBegin('UTF8string_value', TType.STRING, 7)
      oprot.writeString(self.UTF8string_value)
      oprot.writeFieldEnd()
    if self.binary_value is not None:
      oprot.writeFieldBegin('binary_value', TType.STRING, 8)
      oprot.writeString(self.binary_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Date_time:
  """
  A structure to deal with date and time

  Attributes:
   - year: Year
   - month: Month
   - day: Day
   - hour: Hour
   - minute: Minute
   - second: Second
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'year', None, None, ), # 1
    (2, TType.I16, 'month', None, None, ), # 2
    (3, TType.I16, 'day', None, None, ), # 3
    (4, TType.I16, 'hour', None, None, ), # 4
    (5, TType.I16, 'minute', None, None, ), # 5
    (6, TType.I16, 'second', None, None, ), # 6
  )

  def __init__(self, year=None, month=None, day=None, hour=None, minute=None, second=None,):
    self.year = year
    self.month = month
    self.day = day
    self.hour = hour
    self.minute = minute
    self.second = second

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.year = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.month = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.day = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.hour = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.minute = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I16:
          self.second = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Date_time')
    if self.year is not None:
      oprot.writeFieldBegin('year', TType.I16, 1)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.month is not None:
      oprot.writeFieldBegin('month', TType.I16, 2)
      oprot.writeI16(self.month)
      oprot.writeFieldEnd()
    if self.day is not None:
      oprot.writeFieldBegin('day', TType.I16, 3)
      oprot.writeI16(self.day)
      oprot.writeFieldEnd()
    if self.hour is not None:
      oprot.writeFieldBegin('hour', TType.I16, 4)
      oprot.writeI16(self.hour)
      oprot.writeFieldEnd()
    if self.minute is not None:
      oprot.writeFieldBegin('minute', TType.I16, 5)
      oprot.writeI16(self.minute)
      oprot.writeFieldEnd()
    if self.second is not None:
      oprot.writeFieldBegin('second', TType.I16, 6)
      oprot.writeI16(self.second)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Time_customed_time_zone:
  """
  Attributes:
   - UTC_offset_in_quarter: Offset from UTC in quarter of hour
   - daylight_start_month: Number representing the month that starts the daylight saving time.<br>
  Not set if terminal uses predefined timezone.
   - daylight_start_day_in_week: Number representing the weekday that starts the daylight saving time.<br>
  Not set if terminal uses predefined timezone.
   - daylight_start_week_in_month: Number representing the week number in month (1 to 4) where daylight saving time starts.<br>
  Not set if terminal uses predefined timezone.
   - daylight_start_hour_of_day: Number representing the hour of day (0 to 23) where daylight saving time starts.<br>
  Not set if terminal uses predefined timezone.
   - daylight_end_month: Number representing the month that ends the daylight saving time.<br>
  Not set if terminal uses predefined timezone.
   - daylight_end_day_in_week: Number representing the weekday that ends the daylight saving time.<br>
  Not set if terminal uses predefined timezone.
   - daylight_end_week_in_month: Number representing the week number in month (1 to 4) where daylight saving time ends.<br>
  Not set if terminal uses predefined timezone.
   - daylight_end_hour_of_day: Number representing the hour of day (0 to 23) where daylight saving time ends.<br>
  Not set if terminal uses predefined timezone.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'UTC_offset_in_quarter', None, None, ), # 1
    (2, TType.I32, 'daylight_start_month', None, None, ), # 2
    (3, TType.I32, 'daylight_start_day_in_week', None, None, ), # 3
    (4, TType.BYTE, 'daylight_start_week_in_month', None, None, ), # 4
    (5, TType.I16, 'daylight_start_hour_of_day', None, None, ), # 5
    (6, TType.I32, 'daylight_end_month', None, None, ), # 6
    (7, TType.I32, 'daylight_end_day_in_week', None, None, ), # 7
    (8, TType.BYTE, 'daylight_end_week_in_month', None, None, ), # 8
    (9, TType.I16, 'daylight_end_hour_of_day', None, None, ), # 9
  )

  def __init__(self, UTC_offset_in_quarter=None, daylight_start_month=None, daylight_start_day_in_week=None, daylight_start_week_in_month=None, daylight_start_hour_of_day=None, daylight_end_month=None, daylight_end_day_in_week=None, daylight_end_week_in_month=None, daylight_end_hour_of_day=None,):
    self.UTC_offset_in_quarter = UTC_offset_in_quarter
    self.daylight_start_month = daylight_start_month
    self.daylight_start_day_in_week = daylight_start_day_in_week
    self.daylight_start_week_in_month = daylight_start_week_in_month
    self.daylight_start_hour_of_day = daylight_start_hour_of_day
    self.daylight_end_month = daylight_end_month
    self.daylight_end_day_in_week = daylight_end_day_in_week
    self.daylight_end_week_in_month = daylight_end_week_in_month
    self.daylight_end_hour_of_day = daylight_end_hour_of_day

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.UTC_offset_in_quarter = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.daylight_start_month = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.daylight_start_day_in_week = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.daylight_start_week_in_month = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.daylight_start_hour_of_day = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.daylight_end_month = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.daylight_end_day_in_week = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.daylight_end_week_in_month = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I16:
          self.daylight_end_hour_of_day = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Time_customed_time_zone')
    if self.UTC_offset_in_quarter is not None:
      oprot.writeFieldBegin('UTC_offset_in_quarter', TType.I32, 1)
      oprot.writeI32(self.UTC_offset_in_quarter)
      oprot.writeFieldEnd()
    if self.daylight_start_month is not None:
      oprot.writeFieldBegin('daylight_start_month', TType.I32, 2)
      oprot.writeI32(self.daylight_start_month)
      oprot.writeFieldEnd()
    if self.daylight_start_day_in_week is not None:
      oprot.writeFieldBegin('daylight_start_day_in_week', TType.I32, 3)
      oprot.writeI32(self.daylight_start_day_in_week)
      oprot.writeFieldEnd()
    if self.daylight_start_week_in_month is not None:
      oprot.writeFieldBegin('daylight_start_week_in_month', TType.BYTE, 4)
      oprot.writeByte(self.daylight_start_week_in_month)
      oprot.writeFieldEnd()
    if self.daylight_start_hour_of_day is not None:
      oprot.writeFieldBegin('daylight_start_hour_of_day', TType.I16, 5)
      oprot.writeI16(self.daylight_start_hour_of_day)
      oprot.writeFieldEnd()
    if self.daylight_end_month is not None:
      oprot.writeFieldBegin('daylight_end_month', TType.I32, 6)
      oprot.writeI32(self.daylight_end_month)
      oprot.writeFieldEnd()
    if self.daylight_end_day_in_week is not None:
      oprot.writeFieldBegin('daylight_end_day_in_week', TType.I32, 7)
      oprot.writeI32(self.daylight_end_day_in_week)
      oprot.writeFieldEnd()
    if self.daylight_end_week_in_month is not None:
      oprot.writeFieldBegin('daylight_end_week_in_month', TType.BYTE, 8)
      oprot.writeByte(self.daylight_end_week_in_month)
      oprot.writeFieldEnd()
    if self.daylight_end_hour_of_day is not None:
      oprot.writeFieldBegin('daylight_end_hour_of_day', TType.I16, 9)
      oprot.writeI16(self.daylight_end_hour_of_day)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.UTC_offset_in_quarter is None:
      raise TProtocol.TProtocolException(message='Required field UTC_offset_in_quarter is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Time_time_zone:
  """
  Attributes:
   - observe_daylight_saving_time: Set to true if daylight saving time shall be handled
   - predefined_time_zone_UTF8: Name of a predefined timezone (Europe/Paris for example).<br>
  Not set if terminal uses customized time zone.
   - customed_time_zone: Customized time zone.<br>
  Not set if terminals uses predefined time zone.
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'observe_daylight_saving_time', None, None, ), # 1
    (2, TType.STRING, 'predefined_time_zone_UTF8', None, None, ), # 2
    (3, TType.STRUCT, 'customed_time_zone', (Time_customed_time_zone, Time_customed_time_zone.thrift_spec), None, ), # 3
  )

  def __init__(self, observe_daylight_saving_time=None, predefined_time_zone_UTF8=None, customed_time_zone=None,):
    self.observe_daylight_saving_time = observe_daylight_saving_time
    self.predefined_time_zone_UTF8 = predefined_time_zone_UTF8
    self.customed_time_zone = customed_time_zone

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.observe_daylight_saving_time = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.predefined_time_zone_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.customed_time_zone = Time_customed_time_zone()
          self.customed_time_zone.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Time_time_zone')
    if self.observe_daylight_saving_time is not None:
      oprot.writeFieldBegin('observe_daylight_saving_time', TType.BOOL, 1)
      oprot.writeBool(self.observe_daylight_saving_time)
      oprot.writeFieldEnd()
    if self.predefined_time_zone_UTF8 is not None:
      oprot.writeFieldBegin('predefined_time_zone_UTF8', TType.STRING, 2)
      oprot.writeString(self.predefined_time_zone_UTF8)
      oprot.writeFieldEnd()
    if self.customed_time_zone is not None:
      oprot.writeFieldBegin('customed_time_zone', TType.STRUCT, 3)
      self.customed_time_zone.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.observe_daylight_saving_time is None:
      raise TProtocol.TProtocolException(message='Required field observe_daylight_saving_time is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Time_local_date_time_settings:
  """
  Attributes:
   - date_time: Date and time in DDMMYY format
   - time_zone: Structure defining the terminal time zone<br>
  Can use predefined or customized time zone
   - date_display_type: Number representing date display format type
   - time_display_type: Number representing time display format type
   - hour_display_type: Number representing time meridian type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'date_time', (Date_time, Date_time.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'time_zone', (Time_time_zone, Time_time_zone.thrift_spec), None, ), # 2
    (3, TType.I32, 'date_display_type', None, None, ), # 3
    (4, TType.I32, 'time_display_type', None, None, ), # 4
    (5, TType.I32, 'hour_display_type', None, None, ), # 5
  )

  def __init__(self, date_time=None, time_zone=None, date_display_type=None, time_display_type=None, hour_display_type=None,):
    self.date_time = date_time
    self.time_zone = time_zone
    self.date_display_type = date_display_type
    self.time_display_type = time_display_type
    self.hour_display_type = hour_display_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.date_time = Date_time()
          self.date_time.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.time_zone = Time_time_zone()
          self.time_zone.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.date_display_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.time_display_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.hour_display_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Time_local_date_time_settings')
    if self.date_time is not None:
      oprot.writeFieldBegin('date_time', TType.STRUCT, 1)
      self.date_time.write(oprot)
      oprot.writeFieldEnd()
    if self.time_zone is not None:
      oprot.writeFieldBegin('time_zone', TType.STRUCT, 2)
      self.time_zone.write(oprot)
      oprot.writeFieldEnd()
    if self.date_display_type is not None:
      oprot.writeFieldBegin('date_display_type', TType.I32, 3)
      oprot.writeI32(self.date_display_type)
      oprot.writeFieldEnd()
    if self.time_display_type is not None:
      oprot.writeFieldBegin('time_display_type', TType.I32, 4)
      oprot.writeI32(self.time_display_type)
      oprot.writeFieldEnd()
    if self.hour_display_type is not None:
      oprot.writeFieldBegin('hour_display_type', TType.I32, 5)
      oprot.writeI32(self.hour_display_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Serial_params_settings:
  """
  Settings for serial channel

  Attributes:
   - baud: The baud rate for the serial protocol
   - char_size: Data bits or character size
   - parity: Parity supported
   - stop_bit: Stop bits supported
   - communication_system: The kind of communication system used by the serial channel this instance represents
   - net_id: The net ID for the terminal
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'baud', None, None, ), # 1
    (2, TType.I32, 'char_size', None, None, ), # 2
    (3, TType.I32, 'parity', None, None, ), # 3
    (4, TType.I32, 'stop_bit', None, None, ), # 4
    (5, TType.I32, 'communication_system', None, None, ), # 5
    (6, TType.I16, 'net_id', None, None, ), # 6
  )

  def __init__(self, baud=None, char_size=None, parity=None, stop_bit=None, communication_system=None, net_id=None,):
    self.baud = baud
    self.char_size = char_size
    self.parity = parity
    self.stop_bit = stop_bit
    self.communication_system = communication_system
    self.net_id = net_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.baud = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.char_size = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.parity = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.stop_bit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.communication_system = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I16:
          self.net_id = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Serial_params_settings')
    if self.baud is not None:
      oprot.writeFieldBegin('baud', TType.I32, 1)
      oprot.writeI32(self.baud)
      oprot.writeFieldEnd()
    if self.char_size is not None:
      oprot.writeFieldBegin('char_size', TType.I32, 2)
      oprot.writeI32(self.char_size)
      oprot.writeFieldEnd()
    if self.parity is not None:
      oprot.writeFieldBegin('parity', TType.I32, 3)
      oprot.writeI32(self.parity)
      oprot.writeFieldEnd()
    if self.stop_bit is not None:
      oprot.writeFieldBegin('stop_bit', TType.I32, 4)
      oprot.writeI32(self.stop_bit)
      oprot.writeFieldEnd()
    if self.communication_system is not None:
      oprot.writeFieldBegin('communication_system', TType.I32, 5)
      oprot.writeI32(self.communication_system)
      oprot.writeFieldEnd()
    if self.net_id is not None:
      oprot.writeFieldBegin('net_id', TType.I16, 6)
      oprot.writeI16(self.net_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IP_settings:
  """
  Attributes:
   - channel: Specify for which IP channel the configuration apply for
   - ip_version: IPV4 address or IPV6 address configuration
   - is_dhcp_mode: Set to true if dynamic IP configuration else set to false for static IP configuration
   - ip_address: If static IP configuration then value of IP address to be set
   - net_mask_or_prefix_len: If static IP configuration then value of netmask(IPV4)/prefix_length(IPV6) to be set
   - gateway_address: If static IP configuration then value of default gateway to be set
   - host_name: Device host name
   - preferred_DNS_address: preferred DNS server address
   - alternate_DNS_address: alternate DNS server address
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'channel', None, None, ), # 1
    (2, TType.I32, 'ip_version', None, None, ), # 2
    (3, TType.BOOL, 'is_dhcp_mode', None, None, ), # 3
    (4, TType.STRING, 'ip_address', None, None, ), # 4
    (5, TType.STRING, 'net_mask_or_prefix_len', None, None, ), # 5
    (6, TType.STRING, 'gateway_address', None, None, ), # 6
    (7, TType.STRING, 'host_name', None, None, ), # 7
    (8, TType.STRING, 'preferred_DNS_address', None, None, ), # 8
    (9, TType.STRING, 'alternate_DNS_address', None, None, ), # 9
  )

  def __init__(self, channel=None, ip_version=None, is_dhcp_mode=None, ip_address=None, net_mask_or_prefix_len=None, gateway_address=None, host_name=None, preferred_DNS_address=None, alternate_DNS_address=None,):
    self.channel = channel
    self.ip_version = ip_version
    self.is_dhcp_mode = is_dhcp_mode
    self.ip_address = ip_address
    self.net_mask_or_prefix_len = net_mask_or_prefix_len
    self.gateway_address = gateway_address
    self.host_name = host_name
    self.preferred_DNS_address = preferred_DNS_address
    self.alternate_DNS_address = alternate_DNS_address

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ip_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_dhcp_mode = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.ip_address = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.net_mask_or_prefix_len = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.gateway_address = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.host_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.preferred_DNS_address = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.alternate_DNS_address = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IP_settings')
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.I32, 1)
      oprot.writeI32(self.channel)
      oprot.writeFieldEnd()
    if self.ip_version is not None:
      oprot.writeFieldBegin('ip_version', TType.I32, 2)
      oprot.writeI32(self.ip_version)
      oprot.writeFieldEnd()
    if self.is_dhcp_mode is not None:
      oprot.writeFieldBegin('is_dhcp_mode', TType.BOOL, 3)
      oprot.writeBool(self.is_dhcp_mode)
      oprot.writeFieldEnd()
    if self.ip_address is not None:
      oprot.writeFieldBegin('ip_address', TType.STRING, 4)
      oprot.writeString(self.ip_address)
      oprot.writeFieldEnd()
    if self.net_mask_or_prefix_len is not None:
      oprot.writeFieldBegin('net_mask_or_prefix_len', TType.STRING, 5)
      oprot.writeString(self.net_mask_or_prefix_len)
      oprot.writeFieldEnd()
    if self.gateway_address is not None:
      oprot.writeFieldBegin('gateway_address', TType.STRING, 6)
      oprot.writeString(self.gateway_address)
      oprot.writeFieldEnd()
    if self.host_name is not None:
      oprot.writeFieldBegin('host_name', TType.STRING, 7)
      oprot.writeString(self.host_name)
      oprot.writeFieldEnd()
    if self.preferred_DNS_address is not None:
      oprot.writeFieldBegin('preferred_DNS_address', TType.STRING, 8)
      oprot.writeString(self.preferred_DNS_address)
      oprot.writeFieldEnd()
    if self.alternate_DNS_address is not None:
      oprot.writeFieldBegin('alternate_DNS_address', TType.STRING, 9)
      oprot.writeString(self.alternate_DNS_address)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.channel is None:
      raise TProtocol.TProtocolException(message='Required field channel is unset!')
    if self.ip_version is None:
      raise TProtocol.TProtocolException(message='Required field ip_version is unset!')
    if self.is_dhcp_mode is None:
      raise TProtocol.TProtocolException(message='Required field is_dhcp_mode is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Sdac_status:
  """
  Attributes:
   - mode: SDAC mode : 0=Off, 1=On
   - relay_state: Relay state : 0=Door unlocked, 1=Door locked
   - door_status: Door status : 0=Open, 1=Closed, -1=Error
   - req_to_exit_state: Request to exit state : 0=Off, 1=On, -1=Error
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'mode', None, None, ), # 1
    (2, TType.I32, 'relay_state', None, None, ), # 2
    (3, TType.I32, 'door_status', None, None, ), # 3
    (4, TType.I32, 'req_to_exit_state', None, None, ), # 4
  )

  def __init__(self, mode=None, relay_state=None, door_status=None, req_to_exit_state=None,):
    self.mode = mode
    self.relay_state = relay_state
    self.door_status = door_status
    self.req_to_exit_state = req_to_exit_state

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.mode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.relay_state = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.door_status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.req_to_exit_state = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Sdac_status')
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.I32, 1)
      oprot.writeI32(self.mode)
      oprot.writeFieldEnd()
    if self.relay_state is not None:
      oprot.writeFieldBegin('relay_state', TType.I32, 2)
      oprot.writeI32(self.relay_state)
      oprot.writeFieldEnd()
    if self.door_status is not None:
      oprot.writeFieldBegin('door_status', TType.I32, 3)
      oprot.writeI32(self.door_status)
      oprot.writeFieldEnd()
    if self.req_to_exit_state is not None:
      oprot.writeFieldBegin('req_to_exit_state', TType.I32, 4)
      oprot.writeI32(self.req_to_exit_state)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.mode is None:
      raise TProtocol.TProtocolException(message='Required field mode is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WIFI_network_info:
  """
  Attributes:
   - SSID: SSID address
   - BSSID: BSSID address
   - frequency: Frequency of ssid
   - signal_level: Signal level of ssid
   - enc_type: Encryption type enum
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'SSID', None, None, ), # 1
    (2, TType.STRING, 'BSSID', None, None, ), # 2
    (3, TType.I16, 'frequency', None, None, ), # 3
    (4, TType.I16, 'signal_level', None, None, ), # 4
    (5, TType.I32, 'enc_type', None, None, ), # 5
  )

  def __init__(self, SSID=None, BSSID=None, frequency=None, signal_level=None, enc_type=None,):
    self.SSID = SSID
    self.BSSID = BSSID
    self.frequency = frequency
    self.signal_level = signal_level
    self.enc_type = enc_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.SSID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.BSSID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.frequency = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.signal_level = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.enc_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WIFI_network_info')
    if self.SSID is not None:
      oprot.writeFieldBegin('SSID', TType.STRING, 1)
      oprot.writeString(self.SSID)
      oprot.writeFieldEnd()
    if self.BSSID is not None:
      oprot.writeFieldBegin('BSSID', TType.STRING, 2)
      oprot.writeString(self.BSSID)
      oprot.writeFieldEnd()
    if self.frequency is not None:
      oprot.writeFieldBegin('frequency', TType.I16, 3)
      oprot.writeI16(self.frequency)
      oprot.writeFieldEnd()
    if self.signal_level is not None:
      oprot.writeFieldBegin('signal_level', TType.I16, 4)
      oprot.writeI16(self.signal_level)
      oprot.writeFieldEnd()
    if self.enc_type is not None:
      oprot.writeFieldBegin('enc_type', TType.I32, 5)
      oprot.writeI32(self.enc_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WIFI_settings:
  """
  Attributes:
   - wifi_info
   - password: Security key (password) of WIFI SSID.
  Write Only value (i.e. can not be read)
   - wep_key_index: WEP key index of SSID.
  Write Only value (i.e. can not be read)
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'wifi_info', (WIFI_network_info, WIFI_network_info.thrift_spec), None, ), # 1
    (2, TType.STRING, 'password', None, None, ), # 2
    (3, TType.BYTE, 'wep_key_index', None, None, ), # 3
  )

  def __init__(self, wifi_info=None, password=None, wep_key_index=None,):
    self.wifi_info = wifi_info
    self.password = password
    self.wep_key_index = wep_key_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.wifi_info = WIFI_network_info()
          self.wifi_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.wep_key_index = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WIFI_settings')
    if self.wifi_info is not None:
      oprot.writeFieldBegin('wifi_info', TType.STRUCT, 1)
      self.wifi_info.write(oprot)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 2)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.wep_key_index is not None:
      oprot.writeFieldBegin('wep_key_index', TType.BYTE, 3)
      oprot.writeByte(self.wep_key_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Terminal_configuration_type:
  """
  Attributes:
   - settings_type
   - ip_version
   - ip_channel
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'settings_type', None, None, ), # 1
    (2, TType.I32, 'ip_version', None, None, ), # 2
    (3, TType.I32, 'ip_channel', None, None, ), # 3
  )

  def __init__(self, settings_type=None, ip_version=None, ip_channel=None,):
    self.settings_type = settings_type
    self.ip_version = ip_version
    self.ip_channel = ip_channel

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.settings_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ip_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.ip_channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Terminal_configuration_type')
    if self.settings_type is not None:
      oprot.writeFieldBegin('settings_type', TType.I32, 1)
      oprot.writeI32(self.settings_type)
      oprot.writeFieldEnd()
    if self.ip_version is not None:
      oprot.writeFieldBegin('ip_version', TType.I32, 2)
      oprot.writeI32(self.ip_version)
      oprot.writeFieldEnd()
    if self.ip_channel is not None:
      oprot.writeFieldBegin('ip_channel', TType.I32, 3)
      oprot.writeI32(self.ip_channel)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.settings_type is None:
      raise TProtocol.TProtocolException(message='Required field settings_type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Terminal_configuration:
  """
  Attributes:
   - date_time_settings
   - ip_settings
   - wifi_settings
   - serial_params
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'date_time_settings', (Time_local_date_time_settings, Time_local_date_time_settings.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ip_settings', (IP_settings, IP_settings.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'wifi_settings', (WIFI_settings, WIFI_settings.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'serial_params', (Serial_params_settings, Serial_params_settings.thrift_spec), None, ), # 4
  )

  def __init__(self, date_time_settings=None, ip_settings=None, wifi_settings=None, serial_params=None,):
    self.date_time_settings = date_time_settings
    self.ip_settings = ip_settings
    self.wifi_settings = wifi_settings
    self.serial_params = serial_params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.date_time_settings = Time_local_date_time_settings()
          self.date_time_settings.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ip_settings = IP_settings()
          self.ip_settings.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.wifi_settings = WIFI_settings()
          self.wifi_settings.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.serial_params = Serial_params_settings()
          self.serial_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Terminal_configuration')
    if self.date_time_settings is not None:
      oprot.writeFieldBegin('date_time_settings', TType.STRUCT, 1)
      self.date_time_settings.write(oprot)
      oprot.writeFieldEnd()
    if self.ip_settings is not None:
      oprot.writeFieldBegin('ip_settings', TType.STRUCT, 2)
      self.ip_settings.write(oprot)
      oprot.writeFieldEnd()
    if self.wifi_settings is not None:
      oprot.writeFieldBegin('wifi_settings', TType.STRUCT, 3)
      self.wifi_settings.write(oprot)
      oprot.writeFieldEnd()
    if self.serial_params is not None:
      oprot.writeFieldBegin('serial_params', TType.STRUCT, 4)
      self.serial_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class XY_coordinates:
  """
  Attributes:
   - x: Horizontal coordinate of a point
   - y: Vertical coordinate of a point
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'x', None, None, ), # 1
    (2, TType.I16, 'y', None, None, ), # 2
  )

  def __init__(self, x=None, y=None,):
    self.x = x
    self.y = y

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.x = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.y = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('XY_coordinates')
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.I16, 1)
      oprot.writeI16(self.x)
      oprot.writeFieldEnd()
    if self.y is not None:
      oprot.writeFieldBegin('y', TType.I16, 2)
      oprot.writeI16(self.y)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.x is None:
      raise TProtocol.TProtocolException(message='Required field x is unset!')
    if self.y is None:
      raise TProtocol.TProtocolException(message='Required field y is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Product_info:
  """
  struct of Product info

  Attributes:
   - terminal_packaged_part_number_UTF8: UTF8 string that represents 10 digit terminal part number of packaged product
   - terminal_packaged_serial_number_UTF8: UTF8 string that represents 14 digit terminal serial number of packaged product
   - terminal_packaged_comm_name_UTF8: UTF8 string that represents terminal commercial name
   - sensor_packaged_part_number_UTF8: UTF8 string that represents 10 digit sensor part number of packaged product
   - sensor_packaged_serial_number_UTF8: UTF8 string that represents 14 digit sensor serial number of packaged product
   - specific_part_number_UTF8: UTF8 string that represents 10 digit product specific part number
   - license_identifier_UTF8: UTF8 string that represents license identifier
   - license_name_UTF8: UTF8 string that represents license name
   - mac_address_ethernet_UTF8: UTF8 string that represents MAC address of Ethernet
   - mac_address_wifi_UTF8: UTF8 string that represents MAC address of WiFi
   - mac_address_3g_modem_UTF8: UTF8 string that represents MAC address of 3G modem
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'terminal_packaged_part_number_UTF8', None, None, ), # 1
    (2, TType.STRING, 'terminal_packaged_serial_number_UTF8', None, None, ), # 2
    (3, TType.STRING, 'terminal_packaged_comm_name_UTF8', None, None, ), # 3
    (4, TType.STRING, 'sensor_packaged_part_number_UTF8', None, None, ), # 4
    (5, TType.STRING, 'sensor_packaged_serial_number_UTF8', None, None, ), # 5
    (6, TType.STRING, 'specific_part_number_UTF8', None, None, ), # 6
    (7, TType.STRING, 'license_identifier_UTF8', None, None, ), # 7
    (8, TType.STRING, 'license_name_UTF8', None, None, ), # 8
    (9, TType.STRING, 'mac_address_ethernet_UTF8', None, None, ), # 9
    (10, TType.STRING, 'mac_address_wifi_UTF8', None, None, ), # 10
    (11, TType.STRING, 'mac_address_3g_modem_UTF8', None, None, ), # 11
  )

  def __init__(self, terminal_packaged_part_number_UTF8=None, terminal_packaged_serial_number_UTF8=None, terminal_packaged_comm_name_UTF8=None, sensor_packaged_part_number_UTF8=None, sensor_packaged_serial_number_UTF8=None, specific_part_number_UTF8=None, license_identifier_UTF8=None, license_name_UTF8=None, mac_address_ethernet_UTF8=None, mac_address_wifi_UTF8=None, mac_address_3g_modem_UTF8=None,):
    self.terminal_packaged_part_number_UTF8 = terminal_packaged_part_number_UTF8
    self.terminal_packaged_serial_number_UTF8 = terminal_packaged_serial_number_UTF8
    self.terminal_packaged_comm_name_UTF8 = terminal_packaged_comm_name_UTF8
    self.sensor_packaged_part_number_UTF8 = sensor_packaged_part_number_UTF8
    self.sensor_packaged_serial_number_UTF8 = sensor_packaged_serial_number_UTF8
    self.specific_part_number_UTF8 = specific_part_number_UTF8
    self.license_identifier_UTF8 = license_identifier_UTF8
    self.license_name_UTF8 = license_name_UTF8
    self.mac_address_ethernet_UTF8 = mac_address_ethernet_UTF8
    self.mac_address_wifi_UTF8 = mac_address_wifi_UTF8
    self.mac_address_3g_modem_UTF8 = mac_address_3g_modem_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.terminal_packaged_part_number_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.terminal_packaged_serial_number_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.terminal_packaged_comm_name_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.sensor_packaged_part_number_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.sensor_packaged_serial_number_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.specific_part_number_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.license_identifier_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.license_name_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.mac_address_ethernet_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.mac_address_wifi_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.mac_address_3g_modem_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Product_info')
    if self.terminal_packaged_part_number_UTF8 is not None:
      oprot.writeFieldBegin('terminal_packaged_part_number_UTF8', TType.STRING, 1)
      oprot.writeString(self.terminal_packaged_part_number_UTF8)
      oprot.writeFieldEnd()
    if self.terminal_packaged_serial_number_UTF8 is not None:
      oprot.writeFieldBegin('terminal_packaged_serial_number_UTF8', TType.STRING, 2)
      oprot.writeString(self.terminal_packaged_serial_number_UTF8)
      oprot.writeFieldEnd()
    if self.terminal_packaged_comm_name_UTF8 is not None:
      oprot.writeFieldBegin('terminal_packaged_comm_name_UTF8', TType.STRING, 3)
      oprot.writeString(self.terminal_packaged_comm_name_UTF8)
      oprot.writeFieldEnd()
    if self.sensor_packaged_part_number_UTF8 is not None:
      oprot.writeFieldBegin('sensor_packaged_part_number_UTF8', TType.STRING, 4)
      oprot.writeString(self.sensor_packaged_part_number_UTF8)
      oprot.writeFieldEnd()
    if self.sensor_packaged_serial_number_UTF8 is not None:
      oprot.writeFieldBegin('sensor_packaged_serial_number_UTF8', TType.STRING, 5)
      oprot.writeString(self.sensor_packaged_serial_number_UTF8)
      oprot.writeFieldEnd()
    if self.specific_part_number_UTF8 is not None:
      oprot.writeFieldBegin('specific_part_number_UTF8', TType.STRING, 6)
      oprot.writeString(self.specific_part_number_UTF8)
      oprot.writeFieldEnd()
    if self.license_identifier_UTF8 is not None:
      oprot.writeFieldBegin('license_identifier_UTF8', TType.STRING, 7)
      oprot.writeString(self.license_identifier_UTF8)
      oprot.writeFieldEnd()
    if self.license_name_UTF8 is not None:
      oprot.writeFieldBegin('license_name_UTF8', TType.STRING, 8)
      oprot.writeString(self.license_name_UTF8)
      oprot.writeFieldEnd()
    if self.mac_address_ethernet_UTF8 is not None:
      oprot.writeFieldBegin('mac_address_ethernet_UTF8', TType.STRING, 9)
      oprot.writeString(self.mac_address_ethernet_UTF8)
      oprot.writeFieldEnd()
    if self.mac_address_wifi_UTF8 is not None:
      oprot.writeFieldBegin('mac_address_wifi_UTF8', TType.STRING, 10)
      oprot.writeString(self.mac_address_wifi_UTF8)
      oprot.writeFieldEnd()
    if self.mac_address_3g_modem_UTF8 is not None:
      oprot.writeFieldBegin('mac_address_3g_modem_UTF8', TType.STRING, 11)
      oprot.writeString(self.mac_address_3g_modem_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Event_config:
  """
  \brief Structure representing per event configuration

  Attributes:
   - enable: Event enable/disable flag
   - send_to_controller: Event sending to controller flag
   - clock_n_data_id: Event ID for clock n data
   - trigger_TTL0: Event sending over TTL0 enable/disable flag
   - trigger_TTL1: Event sending over TTL1 enable/disable flag
   - trigger_TTL2: Event sending over TTL2 enable/disable flag
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'enable', None, None, ), # 1
    (2, TType.BOOL, 'send_to_controller', None, None, ), # 2
    (3, TType.STRING, 'clock_n_data_id', None, None, ), # 3
    (4, TType.BOOL, 'trigger_TTL0', None, None, ), # 4
    (5, TType.BOOL, 'trigger_TTL1', None, None, ), # 5
    (6, TType.BOOL, 'trigger_TTL2', None, None, ), # 6
  )

  def __init__(self, enable=None, send_to_controller=None, clock_n_data_id=None, trigger_TTL0=None, trigger_TTL1=None, trigger_TTL2=None,):
    self.enable = enable
    self.send_to_controller = send_to_controller
    self.clock_n_data_id = clock_n_data_id
    self.trigger_TTL0 = trigger_TTL0
    self.trigger_TTL1 = trigger_TTL1
    self.trigger_TTL2 = trigger_TTL2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.enable = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.send_to_controller = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.clock_n_data_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.trigger_TTL0 = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.trigger_TTL1 = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.trigger_TTL2 = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Event_config')
    if self.enable is not None:
      oprot.writeFieldBegin('enable', TType.BOOL, 1)
      oprot.writeBool(self.enable)
      oprot.writeFieldEnd()
    if self.send_to_controller is not None:
      oprot.writeFieldBegin('send_to_controller', TType.BOOL, 2)
      oprot.writeBool(self.send_to_controller)
      oprot.writeFieldEnd()
    if self.clock_n_data_id is not None:
      oprot.writeFieldBegin('clock_n_data_id', TType.STRING, 3)
      oprot.writeString(self.clock_n_data_id)
      oprot.writeFieldEnd()
    if self.trigger_TTL0 is not None:
      oprot.writeFieldBegin('trigger_TTL0', TType.BOOL, 4)
      oprot.writeBool(self.trigger_TTL0)
      oprot.writeFieldEnd()
    if self.trigger_TTL1 is not None:
      oprot.writeFieldBegin('trigger_TTL1', TType.BOOL, 5)
      oprot.writeBool(self.trigger_TTL1)
      oprot.writeFieldEnd()
    if self.trigger_TTL2 is not None:
      oprot.writeFieldBegin('trigger_TTL2', TType.BOOL, 6)
      oprot.writeBool(self.trigger_TTL2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.enable is None:
      raise TProtocol.TProtocolException(message='Required field enable is unset!')
    if self.send_to_controller is None:
      raise TProtocol.TProtocolException(message='Required field send_to_controller is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IP_host_config:
  """
  \brief Structure contains IP host configuration data

  Attributes:
   - ip_address: controller IP address
   - port: controller port number, range (1:65000)
   - timeout: timeout for connection, read and write
   - protocol: protocol to use for IP channel, range (1:65000)
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ip_address', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'timeout', None, None, ), # 3
    (4, TType.I32, 'protocol', None, None, ), # 4
  )

  def __init__(self, ip_address=None, port=None, timeout=None, protocol=None,):
    self.ip_address = ip_address
    self.port = port
    self.timeout = timeout
    self.protocol = protocol

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ip_address = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.timeout = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.protocol = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IP_host_config')
    if self.ip_address is not None:
      oprot.writeFieldBegin('ip_address', TType.STRING, 1)
      oprot.writeString(self.ip_address)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.timeout is not None:
      oprot.writeFieldBegin('timeout', TType.I32, 3)
      oprot.writeI32(self.timeout)
      oprot.writeFieldEnd()
    if self.protocol is not None:
      oprot.writeFieldBegin('protocol', TType.I32, 4)
      oprot.writeI32(self.protocol)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ip_address is None:
      raise TProtocol.TProtocolException(message='Required field ip_address is unset!')
    if self.port is None:
      raise TProtocol.TProtocolException(message='Required field port is unset!')
    if self.timeout is None:
      raise TProtocol.TProtocolException(message='Required field timeout is unset!')
    if self.protocol is None:
      raise TProtocol.TProtocolException(message='Required field protocol is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Serial_host_config:
  """
  \brief Structure contains serial host configuration data

  Attributes:
   - baud: The baud rate for the serial protocol
   - communication_system: The kind of communication system used by the serial channel
   - char_size: Databits to use
   - parity: Parity bits to use
   - stopbits: Stop bits to use
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'baud', None, None, ), # 1
    (2, TType.I32, 'communication_system', None, None, ), # 2
    (3, TType.I32, 'char_size', None, None, ), # 3
    (4, TType.I32, 'parity', None, None, ), # 4
    (5, TType.I32, 'stopbits', None, None, ), # 5
  )

  def __init__(self, baud=None, communication_system=None, char_size=None, parity=None, stopbits=None,):
    self.baud = baud
    self.communication_system = communication_system
    self.char_size = char_size
    self.parity = parity
    self.stopbits = stopbits

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.baud = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.communication_system = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.char_size = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.parity = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.stopbits = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Serial_host_config')
    if self.baud is not None:
      oprot.writeFieldBegin('baud', TType.I32, 1)
      oprot.writeI32(self.baud)
      oprot.writeFieldEnd()
    if self.communication_system is not None:
      oprot.writeFieldBegin('communication_system', TType.I32, 2)
      oprot.writeI32(self.communication_system)
      oprot.writeFieldEnd()
    if self.char_size is not None:
      oprot.writeFieldBegin('char_size', TType.I32, 3)
      oprot.writeI32(self.char_size)
      oprot.writeFieldEnd()
    if self.parity is not None:
      oprot.writeFieldBegin('parity', TType.I32, 4)
      oprot.writeI32(self.parity)
      oprot.writeFieldEnd()
    if self.stopbits is not None:
      oprot.writeFieldBegin('stopbits', TType.I32, 5)
      oprot.writeI32(self.stopbits)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.baud is None:
      raise TProtocol.TProtocolException(message='Required field baud is unset!')
    if self.communication_system is None:
      raise TProtocol.TProtocolException(message='Required field communication_system is unset!')
    if self.char_size is None:
      raise TProtocol.TProtocolException(message='Required field char_size is unset!')
    if self.parity is None:
      raise TProtocol.TProtocolException(message='Required field parity is unset!')
    if self.stopbits is None:
      raise TProtocol.TProtocolException(message='Required field stopbits is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Host_configuration:
  """
  Configurations of the host on which the data needs to be send

  Attributes:
   - ip_host_conf: IP host configuration if data needs to be sent on IP channel
   - serial_host_conf: serial host configuration if data needs to be sent on serial channel
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ip_host_conf', (IP_host_config, IP_host_config.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'serial_host_conf', (Serial_host_config, Serial_host_config.thrift_spec), None, ), # 2
  )

  def __init__(self, ip_host_conf=None, serial_host_conf=None,):
    self.ip_host_conf = ip_host_conf
    self.serial_host_conf = serial_host_conf

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ip_host_conf = IP_host_config()
          self.ip_host_conf.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.serial_host_conf = Serial_host_config()
          self.serial_host_conf.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Host_configuration')
    if self.ip_host_conf is not None:
      oprot.writeFieldBegin('ip_host_conf', TType.STRUCT, 1)
      self.ip_host_conf.write(oprot)
      oprot.writeFieldEnd()
    if self.serial_host_conf is not None:
      oprot.writeFieldBegin('serial_host_conf', TType.STRUCT, 2)
      self.serial_host_conf.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Inexistent_user_id_error(TException):
  """
  The specified user ID does not exist.

  Attributes:
   - err_code
   - user_id_UTF8
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
    (2, TType.STRING, 'user_id_UTF8', None, None, ), # 2
  )

  def __init__(self, err_code=None, user_id_UTF8=None,):
    self.err_code = err_code
    self.user_id_UTF8 = user_id_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user_id_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Inexistent_user_id_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    if self.user_id_UTF8 is not None:
      oprot.writeFieldBegin('user_id_UTF8', TType.STRING, 2)
      oprot.writeString(self.user_id_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    if self.user_id_UTF8 is None:
      raise TProtocol.TProtocolException(message='Required field user_id_UTF8 is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Out_of_memory_error(TException):
  """
  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Out_of_memory_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Timeout_error(TException):
  """
  Command reaches the timeout.

  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Timeout_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Invalid_argument_error(TException):
  """
  One command argument can not be interpreted.

  Attributes:
   - err_code
   - what_UTF8
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
    (2, TType.STRING, 'what_UTF8', None, None, ), # 2
  )

  def __init__(self, err_code=None, what_UTF8=None,):
    self.err_code = err_code
    self.what_UTF8 = what_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.what_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Invalid_argument_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    if self.what_UTF8 is not None:
      oprot.writeFieldBegin('what_UTF8', TType.STRING, 2)
      oprot.writeString(self.what_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Cancelled_error(TException):
  """
  The command was cancelled by distant command.

  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Cancelled_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Security_default_password(TException):
  """
  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Security_default_password')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class File_inexistent_error(TException):
  """
  Attributes:
   - err_code
   - what_UTF8
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
    (2, TType.STRING, 'what_UTF8', None, None, ), # 2
  )

  def __init__(self, err_code=None, what_UTF8=None,):
    self.err_code = err_code
    self.what_UTF8 = what_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.what_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('File_inexistent_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    if self.what_UTF8 is not None:
      oprot.writeFieldBegin('what_UTF8', TType.STRING, 2)
      oprot.writeString(self.what_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class File_name_missing_error(TException):
  """
  Attributes:
   - err_code
   - what_UTF8
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
    (2, TType.STRING, 'what_UTF8', None, None, ), # 2
  )

  def __init__(self, err_code=None, what_UTF8=None,):
    self.err_code = err_code
    self.what_UTF8 = what_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.what_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('File_name_missing_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    if self.what_UTF8 is not None:
      oprot.writeFieldBegin('what_UTF8', TType.STRING, 2)
      oprot.writeString(self.what_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Invalid_file_extension_error(TException):
  """
  Attributes:
   - err_code
   - what_UTF8
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
    (2, TType.STRING, 'what_UTF8', None, None, ), # 2
  )

  def __init__(self, err_code=None, what_UTF8=None,):
    self.err_code = err_code
    self.what_UTF8 = what_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.what_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Invalid_file_extension_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    if self.what_UTF8 is not None:
      oprot.writeFieldBegin('what_UTF8', TType.STRING, 2)
      oprot.writeString(self.what_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class File_too_large_error(TException):
  """
  Attributes:
   - err_code
   - what_UTF8
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
    (2, TType.STRING, 'what_UTF8', None, None, ), # 2
  )

  def __init__(self, err_code=None, what_UTF8=None,):
    self.err_code = err_code
    self.what_UTF8 = what_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.what_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('File_too_large_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    if self.what_UTF8 is not None:
      oprot.writeFieldBegin('what_UTF8', TType.STRING, 2)
      oprot.writeString(self.what_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WIFI_module_not_connected(TException):
  """
  Attributes:
   - err_code
   - what_UTF8
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
    (2, TType.STRING, 'what_UTF8', None, None, ), # 2
  )

  def __init__(self, err_code=None, what_UTF8=None,):
    self.err_code = err_code
    self.what_UTF8 = what_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.what_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WIFI_module_not_connected')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    if self.what_UTF8 is not None:
      oprot.writeFieldBegin('what_UTF8', TType.STRING, 2)
      oprot.writeString(self.what_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Ethernet_config_not_found(TException):
  """
  Attributes:
   - err_code
   - what_UTF8
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
    (2, TType.STRING, 'what_UTF8', None, None, ), # 2
  )

  def __init__(self, err_code=None, what_UTF8=None,):
    self.err_code = err_code
    self.what_UTF8 = what_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.what_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Ethernet_config_not_found')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    if self.what_UTF8 is not None:
      oprot.writeFieldBegin('what_UTF8', TType.STRING, 2)
      oprot.writeString(self.what_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Ethernet_configuration_failed(TException):
  """
  Attributes:
   - err_code
   - what_UTF8
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
    (2, TType.STRING, 'what_UTF8', None, None, ), # 2
  )

  def __init__(self, err_code=None, what_UTF8=None,):
    self.err_code = err_code
    self.what_UTF8 = what_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.what_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Ethernet_configuration_failed')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    if self.what_UTF8 is not None:
      oprot.writeFieldBegin('what_UTF8', TType.STRING, 2)
      oprot.writeString(self.what_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Invalid_IP_error(TException):
  """
  Attributes:
   - what_UTF8
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'what_UTF8', None, None, ), # 1
  )

  def __init__(self, what_UTF8=None,):
    self.what_UTF8 = what_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.what_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Invalid_IP_error')
    if self.what_UTF8 is not None:
      oprot.writeFieldBegin('what_UTF8', TType.STRING, 1)
      oprot.writeString(self.what_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.what_UTF8 is None:
      raise TProtocol.TProtocolException(message='Required field what_UTF8 is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Invalid_size_error(TException):
  """
  Attributes:
   - what_UTF8
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'what_UTF8', None, None, ), # 1
  )

  def __init__(self, what_UTF8=None,):
    self.what_UTF8 = what_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.what_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Invalid_size_error')
    if self.what_UTF8 is not None:
      oprot.writeFieldBegin('what_UTF8', TType.STRING, 1)
      oprot.writeString(self.what_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.what_UTF8 is None:
      raise TProtocol.TProtocolException(message='Required field what_UTF8 is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Invalid_wiegand_string(TException):
  """
  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Invalid_wiegand_string')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Wiegand_output_disabled(TException):
  """
  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Wiegand_output_disabled')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Host_not_found(TException):
  """
  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Host_not_found')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class License_not_found(TException):
  """
  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('License_not_found')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SD_card_not_found(TException):
  """
  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SD_card_not_found')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Generic_error(TException):
  """
  The exception encompassing other general exceptions

  Attributes:
   - err_code
   - what_UTF8
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
    (2, TType.STRING, 'what_UTF8', None, None, ), # 2
  )

  def __init__(self, err_code=None, what_UTF8=None,):
    self.err_code = err_code
    self.what_UTF8 = what_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.what_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Generic_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    if self.what_UTF8 is not None:
      oprot.writeFieldBegin('what_UTF8', TType.STRING, 2)
      oprot.writeString(self.what_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
