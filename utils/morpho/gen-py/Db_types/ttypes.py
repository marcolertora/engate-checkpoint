#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import Biofinger_types.ttypes
import Generic_types.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Transaction_log_action_code:
  """
  Enumeration for transaction log action code
  """
  tlac_duress_finger_detected = 0
  tlac_fake_finger_detected = 1
  tlac_user_control_successful = 2
  tlac_biometric_mismatch = 3
  tlac_pin_mismatch = 4
  tlac_user_id_not_in_db = 5
  tlac_control_timed_out = 6
  tlac_rejected_by_schedule = 7
  tlac_temp_validity_expired = 8
  tlac_user_not_in_white_list = 9
  tlac_black_listed_card = 10
  tlac_face_not_detected = 11
  tlac_transaction_log_full = 12
  tlac_controller_feedback_action = 13
  tlac_job_code_check_failure = 14
  tlac_user_rule_check_failure = 15
  tlac_door_opened_for_too_long = 16
  tlac_door_forced_open = 17
  tlac_door_closed_after_alarm = 18
  tlac_door_unlocked = 19
  tlac_door_locked_back = 20
  tlac_management_menu_login = 21
  tlac_management_menu_logout = 22
  tlac_database_deleted = 23
  tlac_enrollment_completed = 24
  tlac_user_deleted = 25
  tlac_user_modification_completed = 26
  tlac_cls_card_encoded = 27
  tlac_cls_card_reset = 28
  tlac_settings_changed = 29
  tlac_cls_card_security_key_reset = 30
  tlac_security_policy_changed = 31
  tlac_tamper_detected = 32
  tlac_tamper_cleared = 33
  tlac_terminal_boot_completed = 34
  tlac_firmware_upgrade = 35
  tlac_add_user = 36
  tlac_reboot_initiated = 37
  tlac_multi_user_intermediate_id = 38
  tlac_max_code = 39

  _VALUES_TO_NAMES = {
    0: "tlac_duress_finger_detected",
    1: "tlac_fake_finger_detected",
    2: "tlac_user_control_successful",
    3: "tlac_biometric_mismatch",
    4: "tlac_pin_mismatch",
    5: "tlac_user_id_not_in_db",
    6: "tlac_control_timed_out",
    7: "tlac_rejected_by_schedule",
    8: "tlac_temp_validity_expired",
    9: "tlac_user_not_in_white_list",
    10: "tlac_black_listed_card",
    11: "tlac_face_not_detected",
    12: "tlac_transaction_log_full",
    13: "tlac_controller_feedback_action",
    14: "tlac_job_code_check_failure",
    15: "tlac_user_rule_check_failure",
    16: "tlac_door_opened_for_too_long",
    17: "tlac_door_forced_open",
    18: "tlac_door_closed_after_alarm",
    19: "tlac_door_unlocked",
    20: "tlac_door_locked_back",
    21: "tlac_management_menu_login",
    22: "tlac_management_menu_logout",
    23: "tlac_database_deleted",
    24: "tlac_enrollment_completed",
    25: "tlac_user_deleted",
    26: "tlac_user_modification_completed",
    27: "tlac_cls_card_encoded",
    28: "tlac_cls_card_reset",
    29: "tlac_settings_changed",
    30: "tlac_cls_card_security_key_reset",
    31: "tlac_security_policy_changed",
    32: "tlac_tamper_detected",
    33: "tlac_tamper_cleared",
    34: "tlac_terminal_boot_completed",
    35: "tlac_firmware_upgrade",
    36: "tlac_add_user",
    37: "tlac_reboot_initiated",
    38: "tlac_multi_user_intermediate_id",
    39: "tlac_max_code",
  }

  _NAMES_TO_VALUES = {
    "tlac_duress_finger_detected": 0,
    "tlac_fake_finger_detected": 1,
    "tlac_user_control_successful": 2,
    "tlac_biometric_mismatch": 3,
    "tlac_pin_mismatch": 4,
    "tlac_user_id_not_in_db": 5,
    "tlac_control_timed_out": 6,
    "tlac_rejected_by_schedule": 7,
    "tlac_temp_validity_expired": 8,
    "tlac_user_not_in_white_list": 9,
    "tlac_black_listed_card": 10,
    "tlac_face_not_detected": 11,
    "tlac_transaction_log_full": 12,
    "tlac_controller_feedback_action": 13,
    "tlac_job_code_check_failure": 14,
    "tlac_user_rule_check_failure": 15,
    "tlac_door_opened_for_too_long": 16,
    "tlac_door_forced_open": 17,
    "tlac_door_closed_after_alarm": 18,
    "tlac_door_unlocked": 19,
    "tlac_door_locked_back": 20,
    "tlac_management_menu_login": 21,
    "tlac_management_menu_logout": 22,
    "tlac_database_deleted": 23,
    "tlac_enrollment_completed": 24,
    "tlac_user_deleted": 25,
    "tlac_user_modification_completed": 26,
    "tlac_cls_card_encoded": 27,
    "tlac_cls_card_reset": 28,
    "tlac_settings_changed": 29,
    "tlac_cls_card_security_key_reset": 30,
    "tlac_security_policy_changed": 31,
    "tlac_tamper_detected": 32,
    "tlac_tamper_cleared": 33,
    "tlac_terminal_boot_completed": 34,
    "tlac_firmware_upgrade": 35,
    "tlac_add_user": 36,
    "tlac_reboot_initiated": 37,
    "tlac_multi_user_intermediate_id": 38,
    "tlac_max_code": 39,
  }

class Transaction_log_action_status:
  """
  Enumeration representing all the action status
  """
  action_fail = 0
  action_pass = 1

  _VALUES_TO_NAMES = {
    0: "action_fail",
    1: "action_pass",
  }

  _NAMES_TO_VALUES = {
    "action_fail": 0,
    "action_pass": 1,
  }

class Transaction_log_DB_fields:
  """
  Enumeration representing all the fields contained in a transaction log record.
  """
  action_status = 0
  date_time = 1
  name = 2
  first_name = 3
  channel = 4
  action_data = 5
  action = 6
  userid_csn = 7
  jobcode = 8
  duration = 9
  matched_finger = 10
  tna_key = 11
  photo = 12
  error_code = 13
  matching_score = 14
  user_role = 15
  usr_ctrl_ref = 16
  usr_ctrl_checks_to_do = 17
  usr_ctrl_checks_done = 18

  _VALUES_TO_NAMES = {
    0: "action_status",
    1: "date_time",
    2: "name",
    3: "first_name",
    4: "channel",
    5: "action_data",
    6: "action",
    7: "userid_csn",
    8: "jobcode",
    9: "duration",
    10: "matched_finger",
    11: "tna_key",
    12: "photo",
    13: "error_code",
    14: "matching_score",
    15: "user_role",
    16: "usr_ctrl_ref",
    17: "usr_ctrl_checks_to_do",
    18: "usr_ctrl_checks_done",
  }

  _NAMES_TO_VALUES = {
    "action_status": 0,
    "date_time": 1,
    "name": 2,
    "first_name": 3,
    "channel": 4,
    "action_data": 5,
    "action": 6,
    "userid_csn": 7,
    "jobcode": 8,
    "duration": 9,
    "matched_finger": 10,
    "tna_key": 11,
    "photo": 12,
    "error_code": 13,
    "matching_score": 14,
    "user_role": 15,
    "usr_ctrl_ref": 16,
    "usr_ctrl_checks_to_do": 17,
    "usr_ctrl_checks_done": 18,
  }

class Transaction_log_filter_type:
  """
  Enumeration representing all the filters available for retrieving transaction logs.
  """
  all = 0
  action_status = 1
  date_time = 2
  user_id = 3
  log_action = 4
  photo_status = 5

  _VALUES_TO_NAMES = {
    0: "all",
    1: "action_status",
    2: "date_time",
    3: "user_id",
    4: "log_action",
    5: "photo_status",
  }

  _NAMES_TO_VALUES = {
    "all": 0,
    "action_status": 1,
    "date_time": 2,
    "user_id": 3,
    "log_action": 4,
    "photo_status": 5,
  }

class User_type:
  """
  Enumeration representing the type of users in database.

  See user_DB_get_user_IDs command.
  """
  enrolled = 0
  white_list = 1
  VIP_list = 2
  all = 3

  _VALUES_TO_NAMES = {
    0: "enrolled",
    1: "white_list",
    2: "VIP_list",
    3: "all",
  }

  _NAMES_TO_VALUES = {
    "enrolled": 0,
    "white_list": 1,
    "VIP_list": 2,
    "all": 3,
  }

class User_DB_fields:
  """
  Enumeration representing all the fields contained in a user record.
  """
  name = 0
  first_name = 1
  templates = 2
  first_finger_qual = 3
  second_finger_qual = 4
  third_finger_qual = 5
  first_finger_nb = 6
  second_finger_nb = 7
  third_finger_nb = 8
  duress_finger_index = 9
  schedule_nb = 10
  PIN_code = 11
  user_card_sn = 12
  job_code_list = 13
  apply_holiday_schedule = 14
  specific_relay_duration_in_sec = 15
  expiry_date = 16
  user_rule = 17
  white_list_flag = 18
  legacy_timemask = 19
  legacy_extended_id = 20
  user_role = 21
  VIP_list_flag = 22
  additional_data = 23

  _VALUES_TO_NAMES = {
    0: "name",
    1: "first_name",
    2: "templates",
    3: "first_finger_qual",
    4: "second_finger_qual",
    5: "third_finger_qual",
    6: "first_finger_nb",
    7: "second_finger_nb",
    8: "third_finger_nb",
    9: "duress_finger_index",
    10: "schedule_nb",
    11: "PIN_code",
    12: "user_card_sn",
    13: "job_code_list",
    14: "apply_holiday_schedule",
    15: "specific_relay_duration_in_sec",
    16: "expiry_date",
    17: "user_rule",
    18: "white_list_flag",
    19: "legacy_timemask",
    20: "legacy_extended_id",
    21: "user_role",
    22: "VIP_list_flag",
    23: "additional_data",
  }

  _NAMES_TO_VALUES = {
    "name": 0,
    "first_name": 1,
    "templates": 2,
    "first_finger_qual": 3,
    "second_finger_qual": 4,
    "third_finger_qual": 5,
    "first_finger_nb": 6,
    "second_finger_nb": 7,
    "third_finger_nb": 8,
    "duress_finger_index": 9,
    "schedule_nb": 10,
    "PIN_code": 11,
    "user_card_sn": 12,
    "job_code_list": 13,
    "apply_holiday_schedule": 14,
    "specific_relay_duration_in_sec": 15,
    "expiry_date": 16,
    "user_rule": 17,
    "white_list_flag": 18,
    "legacy_timemask": 19,
    "legacy_extended_id": 20,
    "user_role": 21,
    "VIP_list_flag": 22,
    "additional_data": 23,
  }

class Dynamic_msg_type:
  dynamic_msg_none = 0
  dynamic_msg_text = 1
  dynamic_msg_image = 2

  _VALUES_TO_NAMES = {
    0: "dynamic_msg_none",
    1: "dynamic_msg_text",
    2: "dynamic_msg_image",
  }

  _NAMES_TO_VALUES = {
    "dynamic_msg_none": 0,
    "dynamic_msg_text": 1,
    "dynamic_msg_image": 2,
  }


class Jobcode_list:
  """
  Jobcode list datatype

  This will be used for the job code list load/retrieve operation

  Attributes:
   - list_number: List number (1 to 128)
   - list_name: List name, max name length is 128
   - jobcode_values: Array of Job code values (0 to (2^32-1)), value is unsigned but it is declared as singed in command due to thrift data type limitation
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'list_number', None, None, ), # 1
    (2, TType.STRING, 'list_name', None, None, ), # 2
    (3, TType.LIST, 'jobcode_values', (TType.I32,None), None, ), # 3
  )

  def __init__(self, list_number=None, list_name=None, jobcode_values=None,):
    self.list_number = list_number
    self.list_name = list_name
    self.jobcode_values = jobcode_values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.list_number = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.list_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.jobcode_values = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI32();
            self.jobcode_values.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Jobcode_list')
    if self.list_number is not None:
      oprot.writeFieldBegin('list_number', TType.I16, 1)
      oprot.writeI16(self.list_number)
      oprot.writeFieldEnd()
    if self.list_name is not None:
      oprot.writeFieldBegin('list_name', TType.STRING, 2)
      oprot.writeString(self.list_name)
      oprot.writeFieldEnd()
    if self.jobcode_values is not None:
      oprot.writeFieldBegin('jobcode_values', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.jobcode_values))
      for iter6 in self.jobcode_values:
        oprot.writeI32(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DB_status:
  """
  Attributes:
   - capacity: Maximum number of records.
   - size: Current number of records.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'capacity', None, None, ), # 1
    (2, TType.I32, 'size', None, None, ), # 2
  )

  def __init__(self, capacity=None, size=None,):
    self.capacity = capacity
    self.size = size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.capacity = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.size = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DB_status')
    if self.capacity is not None:
      oprot.writeFieldBegin('capacity', TType.I32, 1)
      oprot.writeI32(self.capacity)
      oprot.writeFieldEnd()
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I32, 2)
      oprot.writeI32(self.size)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Transaction_log_status:
  """
  Attributes:
   - log_status: Log status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'log_status', (DB_status, DB_status.thrift_spec), None, ), # 1
  )

  def __init__(self, log_status=None,):
    self.log_status = log_status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.log_status = DB_status()
          self.log_status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Transaction_log_status')
    if self.log_status is not None:
      oprot.writeFieldBegin('log_status', TType.STRUCT, 1)
      self.log_status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Usr_ctrl_ref:
  """
  Attributes:
   - ctrl_mode_ref_in_DB: Control mode reference
   - user_record_ref_in_DB: user record reference
   - id_check_ref_in_DB: Terminal ID check reference
   - id_check_ref_on_SC: Smartcard ID check reference
   - finger_ref_in_DB: Finger data reference
   - pin_ref_in_DB: PIN data reference
   - expiry_date_ref_in_DB: Expiry date reference
   - access_schedule_ref_in_DB: Access schedule data reference
   - holiday_schedule_ref_in_DB: Holiday schedule data reference
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'ctrl_mode_ref_in_DB', None, None, ), # 1
    (2, TType.BOOL, 'user_record_ref_in_DB', None, None, ), # 2
    (3, TType.BOOL, 'id_check_ref_in_DB', None, None, ), # 3
    (4, TType.BOOL, 'id_check_ref_on_SC', None, None, ), # 4
    (5, TType.BOOL, 'finger_ref_in_DB', None, None, ), # 5
    (6, TType.BOOL, 'pin_ref_in_DB', None, None, ), # 6
    (7, TType.BOOL, 'expiry_date_ref_in_DB', None, None, ), # 7
    (8, TType.BOOL, 'access_schedule_ref_in_DB', None, None, ), # 8
    (9, TType.BOOL, 'holiday_schedule_ref_in_DB', None, None, ), # 9
  )

  def __init__(self, ctrl_mode_ref_in_DB=None, user_record_ref_in_DB=None, id_check_ref_in_DB=None, id_check_ref_on_SC=None, finger_ref_in_DB=None, pin_ref_in_DB=None, expiry_date_ref_in_DB=None, access_schedule_ref_in_DB=None, holiday_schedule_ref_in_DB=None,):
    self.ctrl_mode_ref_in_DB = ctrl_mode_ref_in_DB
    self.user_record_ref_in_DB = user_record_ref_in_DB
    self.id_check_ref_in_DB = id_check_ref_in_DB
    self.id_check_ref_on_SC = id_check_ref_on_SC
    self.finger_ref_in_DB = finger_ref_in_DB
    self.pin_ref_in_DB = pin_ref_in_DB
    self.expiry_date_ref_in_DB = expiry_date_ref_in_DB
    self.access_schedule_ref_in_DB = access_schedule_ref_in_DB
    self.holiday_schedule_ref_in_DB = holiday_schedule_ref_in_DB

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.ctrl_mode_ref_in_DB = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.user_record_ref_in_DB = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.id_check_ref_in_DB = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.id_check_ref_on_SC = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.finger_ref_in_DB = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.pin_ref_in_DB = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.expiry_date_ref_in_DB = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.access_schedule_ref_in_DB = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.holiday_schedule_ref_in_DB = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Usr_ctrl_ref')
    if self.ctrl_mode_ref_in_DB is not None:
      oprot.writeFieldBegin('ctrl_mode_ref_in_DB', TType.BOOL, 1)
      oprot.writeBool(self.ctrl_mode_ref_in_DB)
      oprot.writeFieldEnd()
    if self.user_record_ref_in_DB is not None:
      oprot.writeFieldBegin('user_record_ref_in_DB', TType.BOOL, 2)
      oprot.writeBool(self.user_record_ref_in_DB)
      oprot.writeFieldEnd()
    if self.id_check_ref_in_DB is not None:
      oprot.writeFieldBegin('id_check_ref_in_DB', TType.BOOL, 3)
      oprot.writeBool(self.id_check_ref_in_DB)
      oprot.writeFieldEnd()
    if self.id_check_ref_on_SC is not None:
      oprot.writeFieldBegin('id_check_ref_on_SC', TType.BOOL, 4)
      oprot.writeBool(self.id_check_ref_on_SC)
      oprot.writeFieldEnd()
    if self.finger_ref_in_DB is not None:
      oprot.writeFieldBegin('finger_ref_in_DB', TType.BOOL, 5)
      oprot.writeBool(self.finger_ref_in_DB)
      oprot.writeFieldEnd()
    if self.pin_ref_in_DB is not None:
      oprot.writeFieldBegin('pin_ref_in_DB', TType.BOOL, 6)
      oprot.writeBool(self.pin_ref_in_DB)
      oprot.writeFieldEnd()
    if self.expiry_date_ref_in_DB is not None:
      oprot.writeFieldBegin('expiry_date_ref_in_DB', TType.BOOL, 7)
      oprot.writeBool(self.expiry_date_ref_in_DB)
      oprot.writeFieldEnd()
    if self.access_schedule_ref_in_DB is not None:
      oprot.writeFieldBegin('access_schedule_ref_in_DB', TType.BOOL, 8)
      oprot.writeBool(self.access_schedule_ref_in_DB)
      oprot.writeFieldEnd()
    if self.holiday_schedule_ref_in_DB is not None:
      oprot.writeFieldBegin('holiday_schedule_ref_in_DB', TType.BOOL, 9)
      oprot.writeBool(self.holiday_schedule_ref_in_DB)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ctrl_mode_ref_in_DB is None:
      raise TProtocol.TProtocolException(message='Required field ctrl_mode_ref_in_DB is unset!')
    if self.user_record_ref_in_DB is None:
      raise TProtocol.TProtocolException(message='Required field user_record_ref_in_DB is unset!')
    if self.id_check_ref_in_DB is None:
      raise TProtocol.TProtocolException(message='Required field id_check_ref_in_DB is unset!')
    if self.id_check_ref_on_SC is None:
      raise TProtocol.TProtocolException(message='Required field id_check_ref_on_SC is unset!')
    if self.finger_ref_in_DB is None:
      raise TProtocol.TProtocolException(message='Required field finger_ref_in_DB is unset!')
    if self.pin_ref_in_DB is None:
      raise TProtocol.TProtocolException(message='Required field pin_ref_in_DB is unset!')
    if self.expiry_date_ref_in_DB is None:
      raise TProtocol.TProtocolException(message='Required field expiry_date_ref_in_DB is unset!')
    if self.access_schedule_ref_in_DB is None:
      raise TProtocol.TProtocolException(message='Required field access_schedule_ref_in_DB is unset!')
    if self.holiday_schedule_ref_in_DB is None:
      raise TProtocol.TProtocolException(message='Required field holiday_schedule_ref_in_DB is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Usr_ctrl_check:
  """
  Attributes:
   - id_check_DB
   - id_check_SC
   - bio_check
   - pin_check
   - usr_rule_check
   - biopin_check
   - face_detection_check
   - face_detection_mandatory
   - face_detection_photo_check
   - white_list_check
   - VIP_list_check
   - stolen_SC_list_check
   - multi_usr_check
   - duress_check
   - access_schedule_check
   - holiday_schedule_check
   - expiry_date_check
   - tna_ext_mode_check
   - job_code_list_check
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'id_check_DB', None, None, ), # 1
    (2, TType.BOOL, 'id_check_SC', None, None, ), # 2
    (3, TType.BOOL, 'bio_check', None, None, ), # 3
    (4, TType.BOOL, 'pin_check', None, None, ), # 4
    (5, TType.BOOL, 'usr_rule_check', None, None, ), # 5
    (6, TType.BOOL, 'biopin_check', None, None, ), # 6
    (7, TType.BOOL, 'face_detection_check', None, None, ), # 7
    (8, TType.BOOL, 'face_detection_mandatory', None, None, ), # 8
    (9, TType.BOOL, 'face_detection_photo_check', None, None, ), # 9
    (10, TType.BOOL, 'white_list_check', None, None, ), # 10
    (11, TType.BOOL, 'VIP_list_check', None, None, ), # 11
    (12, TType.BOOL, 'stolen_SC_list_check', None, None, ), # 12
    (13, TType.BOOL, 'multi_usr_check', None, None, ), # 13
    (14, TType.BOOL, 'duress_check', None, None, ), # 14
    (15, TType.BOOL, 'access_schedule_check', None, None, ), # 15
    (16, TType.BOOL, 'holiday_schedule_check', None, None, ), # 16
    (17, TType.BOOL, 'expiry_date_check', None, None, ), # 17
    (18, TType.BOOL, 'tna_ext_mode_check', None, None, ), # 18
    (19, TType.BOOL, 'job_code_list_check', None, None, ), # 19
  )

  def __init__(self, id_check_DB=None, id_check_SC=None, bio_check=None, pin_check=None, usr_rule_check=None, biopin_check=None, face_detection_check=None, face_detection_mandatory=None, face_detection_photo_check=None, white_list_check=None, VIP_list_check=None, stolen_SC_list_check=None, multi_usr_check=None, duress_check=None, access_schedule_check=None, holiday_schedule_check=None, expiry_date_check=None, tna_ext_mode_check=None, job_code_list_check=None,):
    self.id_check_DB = id_check_DB
    self.id_check_SC = id_check_SC
    self.bio_check = bio_check
    self.pin_check = pin_check
    self.usr_rule_check = usr_rule_check
    self.biopin_check = biopin_check
    self.face_detection_check = face_detection_check
    self.face_detection_mandatory = face_detection_mandatory
    self.face_detection_photo_check = face_detection_photo_check
    self.white_list_check = white_list_check
    self.VIP_list_check = VIP_list_check
    self.stolen_SC_list_check = stolen_SC_list_check
    self.multi_usr_check = multi_usr_check
    self.duress_check = duress_check
    self.access_schedule_check = access_schedule_check
    self.holiday_schedule_check = holiday_schedule_check
    self.expiry_date_check = expiry_date_check
    self.tna_ext_mode_check = tna_ext_mode_check
    self.job_code_list_check = job_code_list_check

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.id_check_DB = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.id_check_SC = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.bio_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.pin_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.usr_rule_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.biopin_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.face_detection_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.face_detection_mandatory = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.face_detection_photo_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.white_list_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.VIP_list_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.stolen_SC_list_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.multi_usr_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.duress_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BOOL:
          self.access_schedule_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.BOOL:
          self.holiday_schedule_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.BOOL:
          self.expiry_date_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.BOOL:
          self.tna_ext_mode_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.BOOL:
          self.job_code_list_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Usr_ctrl_check')
    if self.id_check_DB is not None:
      oprot.writeFieldBegin('id_check_DB', TType.BOOL, 1)
      oprot.writeBool(self.id_check_DB)
      oprot.writeFieldEnd()
    if self.id_check_SC is not None:
      oprot.writeFieldBegin('id_check_SC', TType.BOOL, 2)
      oprot.writeBool(self.id_check_SC)
      oprot.writeFieldEnd()
    if self.bio_check is not None:
      oprot.writeFieldBegin('bio_check', TType.BOOL, 3)
      oprot.writeBool(self.bio_check)
      oprot.writeFieldEnd()
    if self.pin_check is not None:
      oprot.writeFieldBegin('pin_check', TType.BOOL, 4)
      oprot.writeBool(self.pin_check)
      oprot.writeFieldEnd()
    if self.usr_rule_check is not None:
      oprot.writeFieldBegin('usr_rule_check', TType.BOOL, 5)
      oprot.writeBool(self.usr_rule_check)
      oprot.writeFieldEnd()
    if self.biopin_check is not None:
      oprot.writeFieldBegin('biopin_check', TType.BOOL, 6)
      oprot.writeBool(self.biopin_check)
      oprot.writeFieldEnd()
    if self.face_detection_check is not None:
      oprot.writeFieldBegin('face_detection_check', TType.BOOL, 7)
      oprot.writeBool(self.face_detection_check)
      oprot.writeFieldEnd()
    if self.face_detection_mandatory is not None:
      oprot.writeFieldBegin('face_detection_mandatory', TType.BOOL, 8)
      oprot.writeBool(self.face_detection_mandatory)
      oprot.writeFieldEnd()
    if self.face_detection_photo_check is not None:
      oprot.writeFieldBegin('face_detection_photo_check', TType.BOOL, 9)
      oprot.writeBool(self.face_detection_photo_check)
      oprot.writeFieldEnd()
    if self.white_list_check is not None:
      oprot.writeFieldBegin('white_list_check', TType.BOOL, 10)
      oprot.writeBool(self.white_list_check)
      oprot.writeFieldEnd()
    if self.VIP_list_check is not None:
      oprot.writeFieldBegin('VIP_list_check', TType.BOOL, 11)
      oprot.writeBool(self.VIP_list_check)
      oprot.writeFieldEnd()
    if self.stolen_SC_list_check is not None:
      oprot.writeFieldBegin('stolen_SC_list_check', TType.BOOL, 12)
      oprot.writeBool(self.stolen_SC_list_check)
      oprot.writeFieldEnd()
    if self.multi_usr_check is not None:
      oprot.writeFieldBegin('multi_usr_check', TType.BOOL, 13)
      oprot.writeBool(self.multi_usr_check)
      oprot.writeFieldEnd()
    if self.duress_check is not None:
      oprot.writeFieldBegin('duress_check', TType.BOOL, 14)
      oprot.writeBool(self.duress_check)
      oprot.writeFieldEnd()
    if self.access_schedule_check is not None:
      oprot.writeFieldBegin('access_schedule_check', TType.BOOL, 15)
      oprot.writeBool(self.access_schedule_check)
      oprot.writeFieldEnd()
    if self.holiday_schedule_check is not None:
      oprot.writeFieldBegin('holiday_schedule_check', TType.BOOL, 16)
      oprot.writeBool(self.holiday_schedule_check)
      oprot.writeFieldEnd()
    if self.expiry_date_check is not None:
      oprot.writeFieldBegin('expiry_date_check', TType.BOOL, 17)
      oprot.writeBool(self.expiry_date_check)
      oprot.writeFieldEnd()
    if self.tna_ext_mode_check is not None:
      oprot.writeFieldBegin('tna_ext_mode_check', TType.BOOL, 18)
      oprot.writeBool(self.tna_ext_mode_check)
      oprot.writeFieldEnd()
    if self.job_code_list_check is not None:
      oprot.writeFieldBegin('job_code_list_check', TType.BOOL, 19)
      oprot.writeBool(self.job_code_list_check)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id_check_DB is None:
      raise TProtocol.TProtocolException(message='Required field id_check_DB is unset!')
    if self.id_check_SC is None:
      raise TProtocol.TProtocolException(message='Required field id_check_SC is unset!')
    if self.bio_check is None:
      raise TProtocol.TProtocolException(message='Required field bio_check is unset!')
    if self.pin_check is None:
      raise TProtocol.TProtocolException(message='Required field pin_check is unset!')
    if self.usr_rule_check is None:
      raise TProtocol.TProtocolException(message='Required field usr_rule_check is unset!')
    if self.biopin_check is None:
      raise TProtocol.TProtocolException(message='Required field biopin_check is unset!')
    if self.face_detection_check is None:
      raise TProtocol.TProtocolException(message='Required field face_detection_check is unset!')
    if self.face_detection_mandatory is None:
      raise TProtocol.TProtocolException(message='Required field face_detection_mandatory is unset!')
    if self.face_detection_photo_check is None:
      raise TProtocol.TProtocolException(message='Required field face_detection_photo_check is unset!')
    if self.white_list_check is None:
      raise TProtocol.TProtocolException(message='Required field white_list_check is unset!')
    if self.VIP_list_check is None:
      raise TProtocol.TProtocolException(message='Required field VIP_list_check is unset!')
    if self.stolen_SC_list_check is None:
      raise TProtocol.TProtocolException(message='Required field stolen_SC_list_check is unset!')
    if self.multi_usr_check is None:
      raise TProtocol.TProtocolException(message='Required field multi_usr_check is unset!')
    if self.duress_check is None:
      raise TProtocol.TProtocolException(message='Required field duress_check is unset!')
    if self.access_schedule_check is None:
      raise TProtocol.TProtocolException(message='Required field access_schedule_check is unset!')
    if self.holiday_schedule_check is None:
      raise TProtocol.TProtocolException(message='Required field holiday_schedule_check is unset!')
    if self.expiry_date_check is None:
      raise TProtocol.TProtocolException(message='Required field expiry_date_check is unset!')
    if self.tna_ext_mode_check is None:
      raise TProtocol.TProtocolException(message='Required field tna_ext_mode_check is unset!')
    if self.job_code_list_check is None:
      raise TProtocol.TProtocolException(message='Required field job_code_list_check is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Transaction_log_DB_record:
  """
  Attributes:
   - action_status: User control status
   - date_time: Transaction time stamp
   - name: Name
   - first_name: First name
   - channel: Channel
   - action_data: Action data (Action specific data) values
   - action: Action
   - userid_csn: User ID or CSN
   - jobcode: Jobcode
   - duration: Duration
   - matched_finger: Matched finger index of user
   - tna_key: Time and Attendance key pressed by user (valid value 0(No Key) to 16(pressed key) )
   - photo: Photo data of user
   - error_code: Error code
   - matching_score: Matching score
   - user_role: User role
   - usr_ctrl_ref_used: Referenced used during user control
   - usr_ctrl_checks_to_do: Controls to do during user control
   - usr_ctrl_checks_done: Controls performed during user control
   - is_final_response: Flag indicating whether the response is final or intermediate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_status', None, None, ), # 1
    (2, TType.STRUCT, 'date_time', (Generic_types.ttypes.Date_time, Generic_types.ttypes.Date_time.thrift_spec), None, ), # 2
    (3, TType.STRING, 'name', None, None, ), # 3
    (4, TType.STRING, 'first_name', None, None, ), # 4
    (5, TType.BYTE, 'channel', None, None, ), # 5
    (6, TType.STRING, 'action_data', None, None, ), # 6
    (7, TType.I32, 'action', None, None, ), # 7
    (8, TType.STRING, 'userid_csn', None, None, ), # 8
    (9, TType.I32, 'jobcode', None, None, ), # 9
    (10, TType.I16, 'duration', None, None, ), # 10
    (11, TType.BYTE, 'matched_finger', None, None, ), # 11
    (12, TType.BYTE, 'tna_key', None, None, ), # 12
    (13, TType.STRING, 'photo', None, None, ), # 13
    (14, TType.I32, 'error_code', None, None, ), # 14
    (15, TType.I64, 'matching_score', None, None, ), # 15
    (16, TType.BYTE, 'user_role', None, None, ), # 16
    (17, TType.STRUCT, 'usr_ctrl_ref_used', (Usr_ctrl_ref, Usr_ctrl_ref.thrift_spec), None, ), # 17
    (18, TType.STRUCT, 'usr_ctrl_checks_to_do', (Usr_ctrl_check, Usr_ctrl_check.thrift_spec), None, ), # 18
    (19, TType.STRUCT, 'usr_ctrl_checks_done', (Usr_ctrl_check, Usr_ctrl_check.thrift_spec), None, ), # 19
    (20, TType.BOOL, 'is_final_response', None, False, ), # 20
  )

  def __init__(self, action_status=None, date_time=None, name=None, first_name=None, channel=None, action_data=None, action=None, userid_csn=None, jobcode=None, duration=None, matched_finger=None, tna_key=None, photo=None, error_code=None, matching_score=None, user_role=None, usr_ctrl_ref_used=None, usr_ctrl_checks_to_do=None, usr_ctrl_checks_done=None, is_final_response=thrift_spec[20][4],):
    self.action_status = action_status
    self.date_time = date_time
    self.name = name
    self.first_name = first_name
    self.channel = channel
    self.action_data = action_data
    self.action = action
    self.userid_csn = userid_csn
    self.jobcode = jobcode
    self.duration = duration
    self.matched_finger = matched_finger
    self.tna_key = tna_key
    self.photo = photo
    self.error_code = error_code
    self.matching_score = matching_score
    self.user_role = user_role
    self.usr_ctrl_ref_used = usr_ctrl_ref_used
    self.usr_ctrl_checks_to_do = usr_ctrl_checks_to_do
    self.usr_ctrl_checks_done = usr_ctrl_checks_done
    self.is_final_response = is_final_response

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.date_time = Generic_types.ttypes.Date_time()
          self.date_time.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.first_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.channel = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.action_data = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.userid_csn = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.jobcode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I16:
          self.duration = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BYTE:
          self.matched_finger = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BYTE:
          self.tna_key = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.photo = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I32:
          self.error_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.matching_score = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.BYTE:
          self.user_role = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRUCT:
          self.usr_ctrl_ref_used = Usr_ctrl_ref()
          self.usr_ctrl_ref_used.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRUCT:
          self.usr_ctrl_checks_to_do = Usr_ctrl_check()
          self.usr_ctrl_checks_to_do.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRUCT:
          self.usr_ctrl_checks_done = Usr_ctrl_check()
          self.usr_ctrl_checks_done.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.BOOL:
          self.is_final_response = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Transaction_log_DB_record')
    if self.action_status is not None:
      oprot.writeFieldBegin('action_status', TType.I32, 1)
      oprot.writeI32(self.action_status)
      oprot.writeFieldEnd()
    if self.date_time is not None:
      oprot.writeFieldBegin('date_time', TType.STRUCT, 2)
      self.date_time.write(oprot)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.first_name is not None:
      oprot.writeFieldBegin('first_name', TType.STRING, 4)
      oprot.writeString(self.first_name)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.BYTE, 5)
      oprot.writeByte(self.channel)
      oprot.writeFieldEnd()
    if self.action_data is not None:
      oprot.writeFieldBegin('action_data', TType.STRING, 6)
      oprot.writeString(self.action_data)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 7)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.userid_csn is not None:
      oprot.writeFieldBegin('userid_csn', TType.STRING, 8)
      oprot.writeString(self.userid_csn)
      oprot.writeFieldEnd()
    if self.jobcode is not None:
      oprot.writeFieldBegin('jobcode', TType.I32, 9)
      oprot.writeI32(self.jobcode)
      oprot.writeFieldEnd()
    if self.duration is not None:
      oprot.writeFieldBegin('duration', TType.I16, 10)
      oprot.writeI16(self.duration)
      oprot.writeFieldEnd()
    if self.matched_finger is not None:
      oprot.writeFieldBegin('matched_finger', TType.BYTE, 11)
      oprot.writeByte(self.matched_finger)
      oprot.writeFieldEnd()
    if self.tna_key is not None:
      oprot.writeFieldBegin('tna_key', TType.BYTE, 12)
      oprot.writeByte(self.tna_key)
      oprot.writeFieldEnd()
    if self.photo is not None:
      oprot.writeFieldBegin('photo', TType.STRING, 13)
      oprot.writeString(self.photo)
      oprot.writeFieldEnd()
    if self.error_code is not None:
      oprot.writeFieldBegin('error_code', TType.I32, 14)
      oprot.writeI32(self.error_code)
      oprot.writeFieldEnd()
    if self.matching_score is not None:
      oprot.writeFieldBegin('matching_score', TType.I64, 15)
      oprot.writeI64(self.matching_score)
      oprot.writeFieldEnd()
    if self.user_role is not None:
      oprot.writeFieldBegin('user_role', TType.BYTE, 16)
      oprot.writeByte(self.user_role)
      oprot.writeFieldEnd()
    if self.usr_ctrl_ref_used is not None:
      oprot.writeFieldBegin('usr_ctrl_ref_used', TType.STRUCT, 17)
      self.usr_ctrl_ref_used.write(oprot)
      oprot.writeFieldEnd()
    if self.usr_ctrl_checks_to_do is not None:
      oprot.writeFieldBegin('usr_ctrl_checks_to_do', TType.STRUCT, 18)
      self.usr_ctrl_checks_to_do.write(oprot)
      oprot.writeFieldEnd()
    if self.usr_ctrl_checks_done is not None:
      oprot.writeFieldBegin('usr_ctrl_checks_done', TType.STRUCT, 19)
      self.usr_ctrl_checks_done.write(oprot)
      oprot.writeFieldEnd()
    if self.is_final_response is not None:
      oprot.writeFieldBegin('is_final_response', TType.BOOL, 20)
      oprot.writeBool(self.is_final_response)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Transaction_log_filter:
  """
  Attributes:
   - filter_type: Filter type required
   - action_status: User control status
   - start_time_stamp: Start time stamp
   - end_time_stamp: End time stamp
   - user_id: User ID
   - log_action: Action
   - photo_status: Photo status
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'filter_type', None, None, ), # 1
    (2, TType.I32, 'action_status', None, None, ), # 2
    (3, TType.STRUCT, 'start_time_stamp', (Generic_types.ttypes.Date_time, Generic_types.ttypes.Date_time.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'end_time_stamp', (Generic_types.ttypes.Date_time, Generic_types.ttypes.Date_time.thrift_spec), None, ), # 4
    (5, TType.STRING, 'user_id', None, None, ), # 5
    (6, TType.I32, 'log_action', None, None, ), # 6
    (7, TType.BOOL, 'photo_status', None, None, ), # 7
  )

  def __init__(self, filter_type=None, action_status=None, start_time_stamp=None, end_time_stamp=None, user_id=None, log_action=None, photo_status=None,):
    self.filter_type = filter_type
    self.action_status = action_status
    self.start_time_stamp = start_time_stamp
    self.end_time_stamp = end_time_stamp
    self.user_id = user_id
    self.log_action = log_action
    self.photo_status = photo_status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.filter_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action_status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.start_time_stamp = Generic_types.ttypes.Date_time()
          self.start_time_stamp.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.end_time_stamp = Generic_types.ttypes.Date_time()
          self.end_time_stamp.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.user_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.log_action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.photo_status = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Transaction_log_filter')
    if self.filter_type is not None:
      oprot.writeFieldBegin('filter_type', TType.I32, 1)
      oprot.writeI32(self.filter_type)
      oprot.writeFieldEnd()
    if self.action_status is not None:
      oprot.writeFieldBegin('action_status', TType.I32, 2)
      oprot.writeI32(self.action_status)
      oprot.writeFieldEnd()
    if self.start_time_stamp is not None:
      oprot.writeFieldBegin('start_time_stamp', TType.STRUCT, 3)
      self.start_time_stamp.write(oprot)
      oprot.writeFieldEnd()
    if self.end_time_stamp is not None:
      oprot.writeFieldBegin('end_time_stamp', TType.STRUCT, 4)
      self.end_time_stamp.write(oprot)
      oprot.writeFieldEnd()
    if self.user_id is not None:
      oprot.writeFieldBegin('user_id', TType.STRING, 5)
      oprot.writeString(self.user_id)
      oprot.writeFieldEnd()
    if self.log_action is not None:
      oprot.writeFieldBegin('log_action', TType.I32, 6)
      oprot.writeI32(self.log_action)
      oprot.writeFieldEnd()
    if self.photo_status is not None:
      oprot.writeFieldBegin('photo_status', TType.BOOL, 7)
      oprot.writeBool(self.photo_status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.filter_type is None:
      raise TProtocol.TProtocolException(message='Required field filter_type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class User_DB_unavailable_field(TException):
  """
  The requested field does not exist in user database.

  Attributes:
   - err_code
   - missing_fields
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
    (2, TType.I32, 'missing_fields', None, None, ), # 2
  )

  def __init__(self, err_code=None, missing_fields=None,):
    self.err_code = err_code
    self.missing_fields = missing_fields

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.missing_fields = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('User_DB_unavailable_field')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    if self.missing_fields is not None:
      oprot.writeFieldBegin('missing_fields', TType.I32, 2)
      oprot.writeI32(self.missing_fields)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    if self.missing_fields is None:
      raise TProtocol.TProtocolException(message='Required field missing_fields is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Dynamic_msg_DB_record:
  """
  Attributes:
   - start_date
   - end_date
   - message_or_filename
   - type
   - attach_flag
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'start_date', (Generic_types.ttypes.Date_time, Generic_types.ttypes.Date_time.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'end_date', (Generic_types.ttypes.Date_time, Generic_types.ttypes.Date_time.thrift_spec), None, ), # 2
    (3, TType.STRING, 'message_or_filename', None, None, ), # 3
    (4, TType.I32, 'type', None, None, ), # 4
    (5, TType.BOOL, 'attach_flag', None, None, ), # 5
  )

  def __init__(self, start_date=None, end_date=None, message_or_filename=None, type=None, attach_flag=None,):
    self.start_date = start_date
    self.end_date = end_date
    self.message_or_filename = message_or_filename
    self.type = type
    self.attach_flag = attach_flag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.start_date = Generic_types.ttypes.Date_time()
          self.start_date.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.end_date = Generic_types.ttypes.Date_time()
          self.end_date.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.message_or_filename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.attach_flag = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Dynamic_msg_DB_record')
    if self.start_date is not None:
      oprot.writeFieldBegin('start_date', TType.STRUCT, 1)
      self.start_date.write(oprot)
      oprot.writeFieldEnd()
    if self.end_date is not None:
      oprot.writeFieldBegin('end_date', TType.STRUCT, 2)
      self.end_date.write(oprot)
      oprot.writeFieldEnd()
    if self.message_or_filename is not None:
      oprot.writeFieldBegin('message_or_filename', TType.STRING, 3)
      oprot.writeString(self.message_or_filename)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 4)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.attach_flag is not None:
      oprot.writeFieldBegin('attach_flag', TType.BOOL, 5)
      oprot.writeBool(self.attach_flag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class User_rule_control_check:
  """
  Attributes:
   - PIN_control: PIN control <br> if enabled PIN control is required for user
   - finger_bio_control: Finger bio reference check
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'PIN_control', None, None, ), # 1
    (2, TType.BOOL, 'finger_bio_control', None, None, ), # 2
  )

  def __init__(self, PIN_control=None, finger_bio_control=None,):
    self.PIN_control = PIN_control
    self.finger_bio_control = finger_bio_control

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.PIN_control = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.finger_bio_control = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('User_rule_control_check')
    if self.PIN_control is not None:
      oprot.writeFieldBegin('PIN_control', TType.BOOL, 1)
      oprot.writeBool(self.PIN_control)
      oprot.writeFieldEnd()
    if self.finger_bio_control is not None:
      oprot.writeFieldBegin('finger_bio_control', TType.BOOL, 2)
      oprot.writeBool(self.finger_bio_control)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.PIN_control is None:
      raise TProtocol.TProtocolException(message='Required field PIN_control is unset!')
    if self.finger_bio_control is None:
      raise TProtocol.TProtocolException(message='Required field finger_bio_control is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class User_rule_reference_check:
  """
  Attributes:
   - terminal: Terminal reference check <br> if enabled reference for user must be terminal
   - smart_card: Smartcard reference check
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'terminal', None, None, ), # 1
    (2, TType.BOOL, 'smart_card', None, None, ), # 2
  )

  def __init__(self, terminal=None, smart_card=None,):
    self.terminal = terminal
    self.smart_card = smart_card

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.terminal = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.smart_card = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('User_rule_reference_check')
    if self.terminal is not None:
      oprot.writeFieldBegin('terminal', TType.BOOL, 1)
      oprot.writeBool(self.terminal)
      oprot.writeFieldEnd()
    if self.smart_card is not None:
      oprot.writeFieldBegin('smart_card', TType.BOOL, 2)
      oprot.writeBool(self.smart_card)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.terminal is None:
      raise TProtocol.TProtocolException(message='Required field terminal is unset!')
    if self.smart_card is None:
      raise TProtocol.TProtocolException(message='Required field smart_card is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class User_rule_trigger_check:
  """
  Attributes:
   - finger_bio: Finger bio trigger check<br> if enabled Finger BIO trigger is valid source of trigger for user
   - contactless: contactless card trigger check
   - keyboard: keyboard trigger check
   - external_port: external_port trigger check
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'finger_bio', None, None, ), # 1
    (2, TType.BOOL, 'contactless', None, None, ), # 2
    (3, TType.BOOL, 'keyboard', None, None, ), # 3
    (4, TType.BOOL, 'external_port', None, None, ), # 4
  )

  def __init__(self, finger_bio=None, contactless=None, keyboard=None, external_port=None,):
    self.finger_bio = finger_bio
    self.contactless = contactless
    self.keyboard = keyboard
    self.external_port = external_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.finger_bio = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.contactless = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.keyboard = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.external_port = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('User_rule_trigger_check')
    if self.finger_bio is not None:
      oprot.writeFieldBegin('finger_bio', TType.BOOL, 1)
      oprot.writeBool(self.finger_bio)
      oprot.writeFieldEnd()
    if self.contactless is not None:
      oprot.writeFieldBegin('contactless', TType.BOOL, 2)
      oprot.writeBool(self.contactless)
      oprot.writeFieldEnd()
    if self.keyboard is not None:
      oprot.writeFieldBegin('keyboard', TType.BOOL, 3)
      oprot.writeBool(self.keyboard)
      oprot.writeFieldEnd()
    if self.external_port is not None:
      oprot.writeFieldBegin('external_port', TType.BOOL, 4)
      oprot.writeBool(self.external_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.finger_bio is None:
      raise TProtocol.TProtocolException(message='Required field finger_bio is unset!')
    if self.contactless is None:
      raise TProtocol.TProtocolException(message='Required field contactless is unset!')
    if self.keyboard is None:
      raise TProtocol.TProtocolException(message='Required field keyboard is unset!')
    if self.external_port is None:
      raise TProtocol.TProtocolException(message='Required field external_port is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class User_access_rule:
  """
  Attributes:
   - trigger_check: Trigger check parameter
   - reference_check: reference check parameter
   - control_check: Control check parameter
   - allow_bio_substitution: BIO substitution
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'trigger_check', (User_rule_trigger_check, User_rule_trigger_check.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'reference_check', (User_rule_reference_check, User_rule_reference_check.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'control_check', (User_rule_control_check, User_rule_control_check.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'allow_bio_substitution', None, None, ), # 4
  )

  def __init__(self, trigger_check=None, reference_check=None, control_check=None, allow_bio_substitution=None,):
    self.trigger_check = trigger_check
    self.reference_check = reference_check
    self.control_check = control_check
    self.allow_bio_substitution = allow_bio_substitution

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.trigger_check = User_rule_trigger_check()
          self.trigger_check.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.reference_check = User_rule_reference_check()
          self.reference_check.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.control_check = User_rule_control_check()
          self.control_check.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.allow_bio_substitution = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('User_access_rule')
    if self.trigger_check is not None:
      oprot.writeFieldBegin('trigger_check', TType.STRUCT, 1)
      self.trigger_check.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_check is not None:
      oprot.writeFieldBegin('reference_check', TType.STRUCT, 2)
      self.reference_check.write(oprot)
      oprot.writeFieldEnd()
    if self.control_check is not None:
      oprot.writeFieldBegin('control_check', TType.STRUCT, 3)
      self.control_check.write(oprot)
      oprot.writeFieldEnd()
    if self.allow_bio_substitution is not None:
      oprot.writeFieldBegin('allow_bio_substitution', TType.BOOL, 4)
      oprot.writeBool(self.allow_bio_substitution)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.trigger_check is None:
      raise TProtocol.TProtocolException(message='Required field trigger_check is unset!')
    if self.reference_check is None:
      raise TProtocol.TProtocolException(message='Required field reference_check is unset!')
    if self.control_check is None:
      raise TProtocol.TProtocolException(message='Required field control_check is unset!')
    if self.allow_bio_substitution is None:
      raise TProtocol.TProtocolException(message='Required field allow_bio_substitution is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class User_DB_record:
  """
  Attributes:
   - name_UTF8: User name
   - first_name_UTF8: First name
   - templates: Non compressed templates.<br>
  Max number of templates per user is 3.
   - first_finger_qual: Quality of the first enrolled finger.
   - second_finger_qual: Quality of the second enrolled finger.
   - third_finger_qual: Quality of the third enrolled finger.
   - first_finger_nb: Number that represents the first finger enrolled.</br>
  1 for left little finger, up to 10 for right little finger.
   - second_finger_nb: Number that represents the second finger enrolled.</br>
  1 for left little finger, up to 10 for right little finger.
   - third_finger_nb: Number that represents the third finger enrolled.</br>
  1 for left little finger, up to 10 for right little finger.
   - duress_finger_index: Index of the duress finger amoung the enrolled finger.</be>
  From 1 to 3.
   - schedule_nb: Schedule number that applies to the user.
   - PIN_code_UTF8: UTF8 string that represents user PIN code.
   - user_card_sn: Card Serial Number (CSN) of the user card.
   - job_code_list: Job code list associated to a user.
   - apply_holiday_schedule: Flag to indicate if holiday schedule apply to the user.
   - specific_relay_duration_in_sec: Specific duration for relay triggering.</br>
  0 for N/A (i.e. used duration from terminal configuration), else duration in seconds (from 1 to 3600 seconds).
   - expiry_date: User expiration data.</br>
  If according feature is enabled, after that date the user will be rejected if control is successful.
   - access_rule: User specific access rule.
   - white_list_flag: Flag to indicate if user is part of the white list.
   - legacy_timemask: MorphoAccess 2G legacy timemask.
   - legacy_extended_id: L1/Bioscrypt legacy extended ID.
   - user_role: Role of the user
   - VIP_list_flag: Flag to indicate if user is part of the VIP list.
   - additional_data: Customer additional data (Not used by terminal)
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name_UTF8', None, None, ), # 1
    (2, TType.STRING, 'first_name_UTF8', None, None, ), # 2
    (3, TType.LIST, 'templates', (TType.STRUCT,(Biofinger_types.ttypes.User_templates, Biofinger_types.ttypes.User_templates.thrift_spec)), None, ), # 3
    (4, TType.I16, 'first_finger_qual', None, None, ), # 4
    (5, TType.I16, 'second_finger_qual', None, None, ), # 5
    (6, TType.I16, 'third_finger_qual', None, None, ), # 6
    (7, TType.BYTE, 'first_finger_nb', None, None, ), # 7
    (8, TType.BYTE, 'second_finger_nb', None, None, ), # 8
    (9, TType.BYTE, 'third_finger_nb', None, None, ), # 9
    (10, TType.BYTE, 'duress_finger_index', None, None, ), # 10
    (11, TType.BYTE, 'schedule_nb', None, None, ), # 11
    (12, TType.STRING, 'PIN_code_UTF8', None, None, ), # 12
    (13, TType.STRING, 'user_card_sn', None, None, ), # 13
    (14, TType.I16, 'job_code_list', None, None, ), # 14
    (15, TType.BOOL, 'apply_holiday_schedule', None, None, ), # 15
    (16, TType.I16, 'specific_relay_duration_in_sec', None, None, ), # 16
    (17, TType.STRUCT, 'expiry_date', (Generic_types.ttypes.Date_time, Generic_types.ttypes.Date_time.thrift_spec), None, ), # 17
    (18, TType.STRUCT, 'access_rule', (User_access_rule, User_access_rule.thrift_spec), None, ), # 18
    (19, TType.BOOL, 'white_list_flag', None, None, ), # 19
    (20, TType.STRING, 'legacy_timemask', None, None, ), # 20
    (21, TType.STRING, 'legacy_extended_id', None, None, ), # 21
    (22, TType.BYTE, 'user_role', None, None, ), # 22
    (23, TType.BOOL, 'VIP_list_flag', None, None, ), # 23
    (24, TType.STRING, 'additional_data', None, None, ), # 24
  )

  def __init__(self, name_UTF8=None, first_name_UTF8=None, templates=None, first_finger_qual=None, second_finger_qual=None, third_finger_qual=None, first_finger_nb=None, second_finger_nb=None, third_finger_nb=None, duress_finger_index=None, schedule_nb=None, PIN_code_UTF8=None, user_card_sn=None, job_code_list=None, apply_holiday_schedule=None, specific_relay_duration_in_sec=None, expiry_date=None, access_rule=None, white_list_flag=None, legacy_timemask=None, legacy_extended_id=None, user_role=None, VIP_list_flag=None, additional_data=None,):
    self.name_UTF8 = name_UTF8
    self.first_name_UTF8 = first_name_UTF8
    self.templates = templates
    self.first_finger_qual = first_finger_qual
    self.second_finger_qual = second_finger_qual
    self.third_finger_qual = third_finger_qual
    self.first_finger_nb = first_finger_nb
    self.second_finger_nb = second_finger_nb
    self.third_finger_nb = third_finger_nb
    self.duress_finger_index = duress_finger_index
    self.schedule_nb = schedule_nb
    self.PIN_code_UTF8 = PIN_code_UTF8
    self.user_card_sn = user_card_sn
    self.job_code_list = job_code_list
    self.apply_holiday_schedule = apply_holiday_schedule
    self.specific_relay_duration_in_sec = specific_relay_duration_in_sec
    self.expiry_date = expiry_date
    self.access_rule = access_rule
    self.white_list_flag = white_list_flag
    self.legacy_timemask = legacy_timemask
    self.legacy_extended_id = legacy_extended_id
    self.user_role = user_role
    self.VIP_list_flag = VIP_list_flag
    self.additional_data = additional_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.first_name_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.templates = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = Biofinger_types.ttypes.User_templates()
            _elem12.read(iprot)
            self.templates.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.first_finger_qual = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.second_finger_qual = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I16:
          self.third_finger_qual = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BYTE:
          self.first_finger_nb = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.second_finger_nb = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BYTE:
          self.third_finger_nb = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BYTE:
          self.duress_finger_index = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BYTE:
          self.schedule_nb = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.PIN_code_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.user_card_sn = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I16:
          self.job_code_list = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BOOL:
          self.apply_holiday_schedule = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I16:
          self.specific_relay_duration_in_sec = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRUCT:
          self.expiry_date = Generic_types.ttypes.Date_time()
          self.expiry_date.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRUCT:
          self.access_rule = User_access_rule()
          self.access_rule.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.BOOL:
          self.white_list_flag = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRING:
          self.legacy_timemask = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRING:
          self.legacy_extended_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.BYTE:
          self.user_role = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.BOOL:
          self.VIP_list_flag = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.STRING:
          self.additional_data = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('User_DB_record')
    if self.name_UTF8 is not None:
      oprot.writeFieldBegin('name_UTF8', TType.STRING, 1)
      oprot.writeString(self.name_UTF8)
      oprot.writeFieldEnd()
    if self.first_name_UTF8 is not None:
      oprot.writeFieldBegin('first_name_UTF8', TType.STRING, 2)
      oprot.writeString(self.first_name_UTF8)
      oprot.writeFieldEnd()
    if self.templates is not None:
      oprot.writeFieldBegin('templates', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.templates))
      for iter13 in self.templates:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.first_finger_qual is not None:
      oprot.writeFieldBegin('first_finger_qual', TType.I16, 4)
      oprot.writeI16(self.first_finger_qual)
      oprot.writeFieldEnd()
    if self.second_finger_qual is not None:
      oprot.writeFieldBegin('second_finger_qual', TType.I16, 5)
      oprot.writeI16(self.second_finger_qual)
      oprot.writeFieldEnd()
    if self.third_finger_qual is not None:
      oprot.writeFieldBegin('third_finger_qual', TType.I16, 6)
      oprot.writeI16(self.third_finger_qual)
      oprot.writeFieldEnd()
    if self.first_finger_nb is not None:
      oprot.writeFieldBegin('first_finger_nb', TType.BYTE, 7)
      oprot.writeByte(self.first_finger_nb)
      oprot.writeFieldEnd()
    if self.second_finger_nb is not None:
      oprot.writeFieldBegin('second_finger_nb', TType.BYTE, 8)
      oprot.writeByte(self.second_finger_nb)
      oprot.writeFieldEnd()
    if self.third_finger_nb is not None:
      oprot.writeFieldBegin('third_finger_nb', TType.BYTE, 9)
      oprot.writeByte(self.third_finger_nb)
      oprot.writeFieldEnd()
    if self.duress_finger_index is not None:
      oprot.writeFieldBegin('duress_finger_index', TType.BYTE, 10)
      oprot.writeByte(self.duress_finger_index)
      oprot.writeFieldEnd()
    if self.schedule_nb is not None:
      oprot.writeFieldBegin('schedule_nb', TType.BYTE, 11)
      oprot.writeByte(self.schedule_nb)
      oprot.writeFieldEnd()
    if self.PIN_code_UTF8 is not None:
      oprot.writeFieldBegin('PIN_code_UTF8', TType.STRING, 12)
      oprot.writeString(self.PIN_code_UTF8)
      oprot.writeFieldEnd()
    if self.user_card_sn is not None:
      oprot.writeFieldBegin('user_card_sn', TType.STRING, 13)
      oprot.writeString(self.user_card_sn)
      oprot.writeFieldEnd()
    if self.job_code_list is not None:
      oprot.writeFieldBegin('job_code_list', TType.I16, 14)
      oprot.writeI16(self.job_code_list)
      oprot.writeFieldEnd()
    if self.apply_holiday_schedule is not None:
      oprot.writeFieldBegin('apply_holiday_schedule', TType.BOOL, 15)
      oprot.writeBool(self.apply_holiday_schedule)
      oprot.writeFieldEnd()
    if self.specific_relay_duration_in_sec is not None:
      oprot.writeFieldBegin('specific_relay_duration_in_sec', TType.I16, 16)
      oprot.writeI16(self.specific_relay_duration_in_sec)
      oprot.writeFieldEnd()
    if self.expiry_date is not None:
      oprot.writeFieldBegin('expiry_date', TType.STRUCT, 17)
      self.expiry_date.write(oprot)
      oprot.writeFieldEnd()
    if self.access_rule is not None:
      oprot.writeFieldBegin('access_rule', TType.STRUCT, 18)
      self.access_rule.write(oprot)
      oprot.writeFieldEnd()
    if self.white_list_flag is not None:
      oprot.writeFieldBegin('white_list_flag', TType.BOOL, 19)
      oprot.writeBool(self.white_list_flag)
      oprot.writeFieldEnd()
    if self.legacy_timemask is not None:
      oprot.writeFieldBegin('legacy_timemask', TType.STRING, 20)
      oprot.writeString(self.legacy_timemask)
      oprot.writeFieldEnd()
    if self.legacy_extended_id is not None:
      oprot.writeFieldBegin('legacy_extended_id', TType.STRING, 21)
      oprot.writeString(self.legacy_extended_id)
      oprot.writeFieldEnd()
    if self.user_role is not None:
      oprot.writeFieldBegin('user_role', TType.BYTE, 22)
      oprot.writeByte(self.user_role)
      oprot.writeFieldEnd()
    if self.VIP_list_flag is not None:
      oprot.writeFieldBegin('VIP_list_flag', TType.BOOL, 23)
      oprot.writeBool(self.VIP_list_flag)
      oprot.writeFieldEnd()
    if self.additional_data is not None:
      oprot.writeFieldBegin('additional_data', TType.STRING, 24)
      oprot.writeString(self.additional_data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DB_full_error(TException):
  """
  No more space to create a new record. Can be because of licence.

  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DB_full_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DB_empty_error(TException):
  """
  The database is empty.

  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DB_empty_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DB_duplicate_record_error(TException):
  """
  A similar record already exists in the database.

  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DB_duplicate_record_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Access_schedule_slots:
  """
  Attributes:
   - start_interval_1: Time slots of 15 mins of interval. value of slot should be between 0-96
   - stop_interval_1: Time slots of 15 mins of interval. value of slot should be between 0-96
   - start_interval_2: Time slots of 15 mins of interval. value of slot should be between 0-96
   - stop_interval_2: Time slots of 15 mins of interval. value of slot should be between 0-96
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'start_interval_1', None, None, ), # 1
    (2, TType.BYTE, 'stop_interval_1', None, None, ), # 2
    (3, TType.BYTE, 'start_interval_2', None, None, ), # 3
    (4, TType.BYTE, 'stop_interval_2', None, None, ), # 4
  )

  def __init__(self, start_interval_1=None, stop_interval_1=None, start_interval_2=None, stop_interval_2=None,):
    self.start_interval_1 = start_interval_1
    self.stop_interval_1 = stop_interval_1
    self.start_interval_2 = start_interval_2
    self.stop_interval_2 = stop_interval_2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.start_interval_1 = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.stop_interval_1 = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.start_interval_2 = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.stop_interval_2 = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Access_schedule_slots')
    if self.start_interval_1 is not None:
      oprot.writeFieldBegin('start_interval_1', TType.BYTE, 1)
      oprot.writeByte(self.start_interval_1)
      oprot.writeFieldEnd()
    if self.stop_interval_1 is not None:
      oprot.writeFieldBegin('stop_interval_1', TType.BYTE, 2)
      oprot.writeByte(self.stop_interval_1)
      oprot.writeFieldEnd()
    if self.start_interval_2 is not None:
      oprot.writeFieldBegin('start_interval_2', TType.BYTE, 3)
      oprot.writeByte(self.start_interval_2)
      oprot.writeFieldEnd()
    if self.stop_interval_2 is not None:
      oprot.writeFieldBegin('stop_interval_2', TType.BYTE, 4)
      oprot.writeByte(self.stop_interval_2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Access_schedule:
  """
  Attributes:
   - schedule_name: name of defined schedule
   - schedule_index: Schedule index value should be between 1 to 58.
  Schedule 0 is never allowed schedule.Value of this schedule can not be modified.
  Schedule 63 is always allowed schedule.Value of this schedule can not be modified.
  Schedule 59 to 62 are reserved schedule.Value of this schedule can not be modified.
   - schedule_slots: Schedule weekly slots
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'schedule_name', None, None, ), # 1
    (2, TType.BYTE, 'schedule_index', None, None, ), # 2
    (3, TType.LIST, 'schedule_slots', (TType.STRUCT,(Access_schedule_slots, Access_schedule_slots.thrift_spec)), None, ), # 3
  )

  def __init__(self, schedule_name=None, schedule_index=None, schedule_slots=None,):
    self.schedule_name = schedule_name
    self.schedule_index = schedule_index
    self.schedule_slots = schedule_slots

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.schedule_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.schedule_index = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.schedule_slots = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = Access_schedule_slots()
            _elem19.read(iprot)
            self.schedule_slots.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Access_schedule')
    if self.schedule_name is not None:
      oprot.writeFieldBegin('schedule_name', TType.STRING, 1)
      oprot.writeString(self.schedule_name)
      oprot.writeFieldEnd()
    if self.schedule_index is not None:
      oprot.writeFieldBegin('schedule_index', TType.BYTE, 2)
      oprot.writeByte(self.schedule_index)
      oprot.writeFieldEnd()
    if self.schedule_slots is not None:
      oprot.writeFieldBegin('schedule_slots', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.schedule_slots))
      for iter20 in self.schedule_slots:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Door_open_schedule_interval:
  """
  Attributes:
   - start_interval: Time slots of 15 mins of interval. value of slot should be between 0-96
   - stop_interval: Time slots of 15 mins of interval. value of slot should be between 0-96
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'start_interval', None, None, ), # 1
    (2, TType.BYTE, 'stop_interval', None, None, ), # 2
  )

  def __init__(self, start_interval=None, stop_interval=None,):
    self.start_interval = start_interval
    self.stop_interval = stop_interval

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.start_interval = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.stop_interval = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Door_open_schedule_interval')
    if self.start_interval is not None:
      oprot.writeFieldBegin('start_interval', TType.BYTE, 1)
      oprot.writeByte(self.start_interval)
      oprot.writeFieldEnd()
    if self.stop_interval is not None:
      oprot.writeFieldBegin('stop_interval', TType.BYTE, 2)
      oprot.writeByte(self.stop_interval)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Door_open_schedule:
  """
  Attributes:
   - schedule_interval: Door open schedule slots. Maximum 10 slots can be defined *
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'schedule_interval', (TType.STRUCT,(Door_open_schedule_interval, Door_open_schedule_interval.thrift_spec)), None, ), # 1
  )

  def __init__(self, schedule_interval=None,):
    self.schedule_interval = schedule_interval

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.schedule_interval = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = Door_open_schedule_interval()
            _elem26.read(iprot)
            self.schedule_interval.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Door_open_schedule')
    if self.schedule_interval is not None:
      oprot.writeFieldBegin('schedule_interval', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.schedule_interval))
      for iter27 in self.schedule_interval:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Holiday_schedule:
  """
  Attributes:
   - schedule_name: name of defined schedule
   - schedule_index: Schedule index value should be between 0 to 63
   - start_date: Start date for holiday schedule
   - end_date: End date for holiday schedule
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'schedule_name', None, None, ), # 1
    (2, TType.BYTE, 'schedule_index', None, None, ), # 2
    (3, TType.STRUCT, 'start_date', (Generic_types.ttypes.Date_time, Generic_types.ttypes.Date_time.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'end_date', (Generic_types.ttypes.Date_time, Generic_types.ttypes.Date_time.thrift_spec), None, ), # 4
  )

  def __init__(self, schedule_name=None, schedule_index=None, start_date=None, end_date=None,):
    self.schedule_name = schedule_name
    self.schedule_index = schedule_index
    self.start_date = start_date
    self.end_date = end_date

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.schedule_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.schedule_index = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.start_date = Generic_types.ttypes.Date_time()
          self.start_date.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.end_date = Generic_types.ttypes.Date_time()
          self.end_date.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Holiday_schedule')
    if self.schedule_name is not None:
      oprot.writeFieldBegin('schedule_name', TType.STRING, 1)
      oprot.writeString(self.schedule_name)
      oprot.writeFieldEnd()
    if self.schedule_index is not None:
      oprot.writeFieldBegin('schedule_index', TType.BYTE, 2)
      oprot.writeByte(self.schedule_index)
      oprot.writeFieldEnd()
    if self.start_date is not None:
      oprot.writeFieldBegin('start_date', TType.STRUCT, 3)
      self.start_date.write(oprot)
      oprot.writeFieldEnd()
    if self.end_date is not None:
      oprot.writeFieldBegin('end_date', TType.STRUCT, 4)
      self.end_date.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Invalid_schedule_index(TException):
  """
  Invalid schedule index exception

  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Invalid_schedule_index')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Invalid_schedule_data(TException):
  """
  Invalid schedule data exception

  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Invalid_schedule_data')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Schedule_store_error(TException):
  """
  Schedule store exception

  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Schedule_store_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Schedule_retrieve_error(TException):
  """
  Schedule retrieve exception

  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Schedule_retrieve_error')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Job_code_list_array_full(TException):
  """
  Job code list array full.

  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Job_code_list_array_full')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Invalid_job_code_array_length(TException):
  """
  Invalid job code array length.

  Attributes:
   - err_code
   - list_number
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
    (2, TType.I16, 'list_number', None, None, ), # 2
  )

  def __init__(self, err_code=None, list_number=None,):
    self.err_code = err_code
    self.list_number = list_number

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.list_number = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Invalid_job_code_array_length')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    if self.list_number is not None:
      oprot.writeFieldBegin('list_number', TType.I16, 2)
      oprot.writeI16(self.list_number)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    if self.list_number is None:
      raise TProtocol.TProtocolException(message='Required field list_number is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Job_code_list_data_invalid(TException):
  """
  Job code list data invalid.

  Attributes:
   - err_code
   - list_number
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
    (2, TType.I16, 'list_number', None, None, ), # 2
  )

  def __init__(self, err_code=None, list_number=None,):
    self.err_code = err_code
    self.list_number = list_number

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.list_number = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Job_code_list_data_invalid')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    if self.list_number is not None:
      oprot.writeFieldBegin('list_number', TType.I16, 2)
      oprot.writeI16(self.list_number)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    if self.list_number is None:
      raise TProtocol.TProtocolException(message='Required field list_number is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Job_code_validation_failed(TException):
  """
  Job_code_validation_failed.

  Attributes:
   - err_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_code', None, None, ), # 1
  )

  def __init__(self, err_code=None,):
    self.err_code = err_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Job_code_validation_failed')
    if self.err_code is not None:
      oprot.writeFieldBegin('err_code', TType.I32, 1)
      oprot.writeI32(self.err_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.err_code is None:
      raise TProtocol.TProtocolException(message='Required field err_code is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
