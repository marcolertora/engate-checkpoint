#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def job_code_load_lists(self, list_values):
    """
    To load one or more job code lists

    This command will add job code list and if list is already
    exist then it will update the list

    Parameters:
     - list_values: List number to be created
    """
    pass

  def job_code_retrieve_lists(self, list_numbers):
    """
    To retrieve one or more job code lists data

    @return The job code list array.

    Parameters:
     - list_numbers: List numbers to be retrieved
    """
    pass

  def job_code_retrieve_list_indices(self):
    """
    To retrieve all job code list number and name

    @return All job code list number and name.
    """
    pass

  def job_code_check_value_against_user(self, user_id, jobcode_value):
    """
    Job code value validate against user


    Parameters:
     - user_id: User ID for which job code is to be checked
     - jobcode_value: Job code value to be validated
    """
    pass

  def job_code_empty_lists(self, list_numbers):
    """
    To remove one or more job code lists
    @return Map of list number to the delete status, if successful then 'true'

    Parameters:
     - list_numbers: List array to be removed
    """
    pass

  def job_code_remove_all_lists(self):
    """
    To remove all job code lists

    """
    pass

  def transaction_log_get_status(self, filter):
    """
    Command to get the transaction log status.

    @return Transaction log status values.


    Parameters:
     - filter: Filter to be applied for getting transaction log count as per filter.
    """
    pass

  def transaction_log_retrieve(self, filter, required_fields):
    """
    Command to retrieve the transaction log entries.

    This command is multi response command. It will give data in multiresponse.
    @return List of the transaction log entries as per the filter applied.<br></br>
    <b>Functionality change required in Thrift generated client code (C++ sample)</b><br>
    <pre>
    void Generic_commandsClient::transaction_log_retrieve(std::vector< ::Distant_cmd::Transaction_log_DB_record> & _return, const  ::Distant_cmd::Transaction_log_filter& filter, const std::set< ::Distant_cmd::Transaction_log_DB_fields::type> & required_fields)
    {
        send_transaction_log_retrieve(filter, required_fields);
        <span style="color:green">// recv_transaction_log_retrieve(_return); // Original line in the generate code</span>
    &nbsp;
        <span style="color:green">// BEGIN: Custom section for receiving and processing intermediate data</span>
        uint32_t loop_id = 0;
        while (true)
        {
            recv_transaction_log_retrieve (_return);
    &nbsp;
            <span style="color:green">// Check if the perticular data chunk is final or not.
            //If it is the final data chunk, the data will be returned in normal way not as callback.</span>
            if (_return.empty() || _return[_return.size() - 1].is_final_response)
            {
                break;
            }
            else
            {
                <span style="color:green">// If the data chunk is not final, the data chunk will be returned as callback function manner
                // Following is the client's callaback, if set, assumed to take necessary action on the received data,
                // e.g. Do process (store somewhere in file or memory) the retrieved transaction log chunk as other chunks are yet to be received.</span>
                if (Multiresponse_handler::client_tlog_command)
                {
                    Multiresponse_handler::client_tlog_command(_return);
                }
            }
        }
        <span style="color:green">// END: Custom section for receiving and processing intermediate data</span>
    }
    </pre>

    Parameters:
     - filter: Filter to be applied for retrieving transaction logs.
     - required_fields: List of the transaction log fields to be retrieved
    """
    pass

  def transaction_log_delete_all(self):
    """
    Command to delete all the transaction log entries.
    """
    pass

  def transaction_log_get_fields(self):
    """
    Gets the available fields in the transaction log records

    @return The list of available transaction log record fields.
    """
    pass

  def config_get_all_params_name(self):
    """
    Returns a list of name of all terminal parameters
    """
    pass

  def config_get_params(self, param_list_UTF8):
    """
    Returns a list of values corresponding to requested parameters

    Parameters:
     - param_list_UTF8: List of UTF8 string representing names of requested parameters
    """
    pass

  def config_set_params(self, param_map):
    """
    Set requested parameters with given values

    Parameters:
     - param_map: List of key-value pairs.<br>
    Parameters are represented by a UTF8 string
    """
    pass

  def config_get_range(self, param_keys):
    """
    Get the value range of the required or all configuration parameters.


    Parameters:
     - param_keys: List of key-value pairs.<br>
    Parameters are represented by a UTF8 string
    """
    pass

  def cls_authenticate_user(self, timeout_in_sec, authent_param):
    """
    Use data contained in a contactless card to authenticate an user (biometric and/or PIN and/or BIOPIN check)<br><br>
    <b>Functionality change required in Thrift generated client code (C++ sample)</b><br>
    Similar to the <a href=#SampleBiofingerIdentify>C++ sample code</a> provided for the method <code>biofinger_identify</code>

    Parameters:
     - timeout_in_sec: Max. duration of Smartcard detection process<br>
    0 implies an infinite process.
     - authent_param: Contactless authentication parameters
    """
    pass

  def biofinger_identify(self, database_id, timeout_in_sec, threshold, enable_intermediate_replies, optional_param):
    """
    Identify an user using its finger against the terminal database

    The reference templates are stored in one (and only one) specified record.<br>
    The search template is compared to all the templates found in the database

    <b>Warning:</b> If @a enable_intermediate_replies is true, you will need a modified version of the Thrift client that supports
             the reception of several T_REPLY messages for one command.<br><br>
    <b id="SampleBiofingerIdentify">Functionality change required in Thrift generated client code (C++ sample)</b><br>
    <pre>
    void Generic_commandsClient::biofinger_identify(::Distant_cmd::Biofinger_control_operation_reply& _return,
            const int8_t database_id, const int32_t timeout_in_sec, const int8_t threshold,
            const bool enable_intermediate_replies, const ::Distant_cmd::Biofinger_control_optional_param& optional_param)
    {
        send_biofinger_identify(database_id, timeout_in_sec, threshold, enable_intermediate_replies, optional_param);
        <span style="color:green">// recv_biofinger_identify(_return); // Original line in the generated code</span>
    &nbsp;
        <span style="color:green">// BEGIN: Custom section for receiving and processing intermediate data</span>
        uint32_t loop_id = 0;
        while (true)
        {
            <span style="color:green">// receive intermediate response</span>
            recv_biofinger_identify(_return);
    &nbsp;
            <span style="color:green">// check for final_result status</span>
            if (_return.__isset.final_result)
            {
                break; <span style="color:green">// if final_result callback, break from loop</span>
            }
            else if (_return.__isset.cb_bio_command) <span style="color:green">// check for interested callback</span>
            {
                _return.__isset.cb_bio_command = false; <span style="color:green">// reset the callback flag</span>
                if (Multiresponse_handler::client_cb_bio_command)
                {
                    <span style="color:green">// process callback data</span>
                    Multiresponse_handler::client_cb_bio_command(_return.cb_bio_command);
                }
            }
            else if (_return.__isset.cb_low_resol_live_image)
            {
                <span style="color:green">// Process similar to "if (_return.__isset.cb_bio_command)" block</span>
            }
            else if (_return.__isset.cb_high_resol_capture_image)
            {
                <span style="color:green">// Process similar to "if (_return.__isset.cb_bio_command)" block</span>
            }
            else if (_return.__isset.cb_capture_quality)
            {
                <span style="color:green">// Process similar to "if (_return.__isset.cb_bio_command)" block</span>
            }
            else if (_return.__isset.cb_live_quality)
            {
                <span style="color:green">// Process similar to "if (_return.__isset.cb_bio_command)" block</span>
            }
        }
        <span style="color:green">// END: Custom section for receiving and processing intermediate data</span>
    }
    </pre>

    Parameters:
     - database_id: Database identifier
     - timeout_in_sec: Max. duration of identification process<br>
    0 implies an infinite process.
     - threshold: This parameter specifies the value of the False Acceptance Ratio (FAR) of the MorphoSmart\99 device.<br>
    The value of this parameter can be set from 0 to 10, by 1 value steps.
     - enable_intermediate_replies: If set to false, you will receive only one reply containing the final result of the
    identification, otherwise you may also receive asynchronous replies containing the
    progress status of the identification.
     - optional_param: Identification optional parameters
    """
    pass

  def biofinger_authenticate_db(self, database_id, timeout_in_sec, threshold, user_id_UTF8, enable_intermediate_replies, optional_param):
    """
    Authenticates an user using its finger against its database references


    The reference templates are stored in one (and only one) specified record.<br>
    The search template is compared to all the templates found in the specified record
    (the number of fingerprint templates depends on the database format).


    <b>Warning:</b> If @a enable_intermediate_replies is true, you will need a modified version of the Thrift client that supports
             the reception of several T_REPLY messages for one command.<br><br>
    <b>Functionality change required in Thrift generated client code (C++ sample)</b><br>
    Similar to the <a href=#SampleBiofingerIdentify>C++ sample code</a> provided for the method <code>biofinger_identify</code>

    Parameters:
     - database_id: Database identifier
     - timeout_in_sec: Max. duration of authentication process<br>
    0 implies an infinite process.
     - threshold: This parameter specifies the value of the False Acceptance Ratio (FAR) of the MorphoSmart\99 device.<br>
    The value of this parameter can be set from 0 to 10, by 1 value steps.
     - user_id_UTF8: User ID to authenticate (UTF8 string)
     - enable_intermediate_replies: If set to false, you will receive only one reply containing the final result of the
    authentication, otherwise you may also receive asynchronous replies containing the
    progress status of the authentication.
     - optional_param: Authentication optional parameters
    """
    pass

  def biofinger_authenticate_ref(self, timeout_in_sec, threshold, ref_template_list, enable_intermediate_replies, optional_param):
    """
    <b>Functionality change required in Thrift generated client code (C++ sample)</b><br>
    Similar to the <a href=#SampleBiofingerIdentify>C++ sample code</a> provided for the method <code>biofinger_identify</code>

    Parameters:
     - timeout_in_sec: Max. duration of authentication process<br>
    0 implies an infinite process.
     - threshold: This parameter specifies the value of the False Acceptance Ratio (FAR) of the MorphoSmart\99 device.<br>
    The value of this parameter can be set from 0 to 10, by 1 value steps.
     - ref_template_list:                                                                * List of reference templates<br>
                                                                   * The templates can be in any format handled by the terminal<br>
    * Max number of templates per list is 20
     - enable_intermediate_replies: If set to false, you will receive only one reply containing the final result of the
    authentication, otherwise you may also receive asynchronous replies containing the
    progress status of the authentication.
     - optional_param: Authentication optional parameters
    """
    pass

  def biofinger_enroll(self, database_id, timeout_in_sec, enrollment_type, nb_of_finger, user_id_UTF8, user_fields, enable_intermediate_replies, optional_param):
    """
    Captures user fingers, optionally stores them in terminal database,
    and/or returns finger templates, and/or returns fingerprint images.


    The template is calculated after three finger acquisitions (the user has to put each finger three times on the sensor).<br>
    To obtain the best accuracy, users are advised to use the fore, the thumb or the middle fingers.<br><br>
    <b>Functionality change required in Thrift generated client code (C++ sample)</b><br>
    Similar to the <a href=#SampleBiofingerIdentify>C++ sample code</a> provided for the method <code>biofinger_identify</code>

    Parameters:
     - database_id: Database identifier<br>
    That parameter is useless if the function does not store in terminal database
     - timeout_in_sec: Max. duration of authentication process<br>
    0 implies an infinite process. Allowed range is 0 - 65535 seconds
     - enrollment_type: This function can create a new record in terminal user database,
    or can return the captured templated, or can perform both.
     - nb_of_finger: Number of fingers to enroll.
    It can be 1, 2 or 3 fingers.
     - user_id_UTF8: User ID to enroll<br>
    That parameter is useless if the function does not store in terminal database
     - user_fields: The user's data to store along with templates<br>
    That parameter is useless if the function does not store in terminal database
     - enable_intermediate_replies: If set to false, you will receive only one reply containing the final result of the
    enrollment, otherwise you may also receive asynchronous replies containing the
    progress status of the enrollment.
     - optional_param: Enrollment optional parameter
    """
    pass

  def PIN_authenticate_db(self, timeout_in_sec, user_id_UTF8):
    """
    Authenticates an user using its PIN code stored in terminal database


    User has to enter a PIN code on the terminal keypad.


    @return True, if the code keyed by the user matches the database user's PIN code, otherwise false.

    Parameters:
     - timeout_in_sec: Max. duration of authentication process<br>
    Limited to 60s.
     - user_id_UTF8: User ID to authenticate (UTF8 string)
    """
    pass

  def reset_factory_settings(self, list_of_settings):
    """
    Reset selected parameters to factory settings.


    Parameters:
     - list_of_settings: List of the settings to reset.
    """
    pass

  def user_DB_get_status(self, type):
    """
    Gets the user's database status

    @return The database capacity and number of records.

    Parameters:
     - type: Type of user to retrieve status
    """
    pass

  def user_DB_get_fields(self):
    """
    Gets the available fields


    This command returns the list of available user fields in the terminal database.

    @return The list of available user fields.
    """
    pass

  def user_DB_set_users(self, users, enable_similar_finger_check):
    """
    Adds or modify one or more user records in the database


    Only the fields which are present in the DB_record structure will be modified.

    <b>Warning:</b> If the command is used to set non compressed templates, they all shall be of the same type.
     users list should be limited to 100 entries otherwise terminal may misbehave.

    Parameters:
     - users: Mapping of User IDs (UTF8 string) to their database fields
     - enable_similar_finger_check: If set to true,  checks  on  reference  templates  are performed:  same  finger  cannot  be  used  twice,<br>
    and  the  person  must  not  be  already  enrolled.<br>
    If set to false, these checks are not performed.<br>
    This  option  is  useful  to  reduce  the  time  taken  to  fill  large databases.<br>
    In this case, the database coherence must be previously checked.
    """
    pass

  def user_DB_delete_records(self, user_IDs_UTF8):
    """
    Deletes one or more user record from the terminal database


    <b>Warning:</b> If a user is not found, no error is reported.

    Parameters:
     - user_IDs_UTF8: User IDs (UTF8 string) of records to delete
    """
    pass

  def user_DB_delete_all_records(self):
    """
    Deletes all user records from the terminal database
    """
    pass

  def user_DB_get_users(self, user_IDs_UTF8, requested_fields):
    """
    Returns one or more user records.


    <b>Warning:</b> The list of user ID shall be limited to 100 items max.


    @return A map of UserIDs and their corresponding records.<br>
            If a user_IDs is not found, it will not be present in the map.

    Parameters:
     - user_IDs_UTF8: List of User IDs to return
     - requested_fields: Fields to return in the DB_record structure. It can be empty if you just
    want to check for a User ID presence.
    """
    pass

  def user_DB_get_user_IDs(self, type):
    """
    Returns the list of all user IDs (UTF8 string) present in terminal database based on user type

    @note For the moment, only the users ID of users in biometric database or in white list can be retrieved.

    Parameters:
     - type: Kind of user to retrieve
    """
    pass

  def dynamic_message_set(self, dm_list):
    """
    Set dynamic message of users.

    <b>Warning:</b> Dynamic messages list should be limited to 500 entries otherwise terminal may misbehave.

    Parameters:
     - dm_list: Mapping of User IDs (UTF8 string) to their dynamic message database fields
    """
    pass

  def dynamic_message_get(self, user_IDs_UTF8):
    """
    Get dynamic message of users.

    <b>Warning:</b> User IDs list should be limited to 500 entries otherwise terminal may misbehave.

    @return The list of read files/data

    Parameters:
     - user_IDs_UTF8: Set of User IDs to return
    """
    pass

  def dynamic_message_reset(self, user_IDs_UTF8):
    """
    Reset dynamic message data of users.


    Parameters:
     - user_IDs_UTF8: Set of User IDs whose dynamic message have to be reset
    """
    pass

  def dynamic_message_get_user_IDs(self):
    """
    Returns the list of all user IDs (UTF8 string) present in terminal database having dynamic message

    """
    pass

  def external_db_get_id(self):
    """
    Get id from terminal polling buffer for external database verification.

    @return id for external database verification
    """
    pass

  def external_db_verify_user(self, user_id_UTF8, user_data):
    """
    Verify external database user data.

    @return Verify_result_code

    Parameters:
     - user_id_UTF8: User ID
     - user_data: User data
    """
    pass

  def external_db_clear_id(self):
    """
    clears the id from terminal polling buffer

    @return none
    """
    pass

  def cls_get_info(self, timeout_in_sec):
    """
    Get contactless card information<br>
    Containing the Smartcard CSN as per the configuration, wheather Standard CSN or Reverse CSN

    Parameters:
     - timeout_in_sec: Duration max. of the operation in seconds
    """
    pass

  def cls_read(self, timeout_in_sec, cards):
    """
    Read files from a contactless card.


    @return The list of read files/data

    Parameters:
     - timeout_in_sec: Duration max. of the operation in seconds
     - cards: List of card to support
    """
    pass

  def cls_write(self, timeout_in_sec, cards):
    """
    Write files on a contactless card.

    Parameters:
     - timeout_in_sec: Duration max. of the operation in seconds
     - cards: List of card to support
    """
    pass

  def cls_write_user_card(self, timeout_in_sec, card_data):
    """
    Encode an user contactless card


    The card is encoded according to terminal configuration.
    The card will contains fields required for access on Morpho terminals.
    This command supports only pkcompv2 template data write on card.

    Parameters:
     - timeout_in_sec: Duration max. of the operation in seconds
     - card_data
    """
    pass

  def cls_write_admin_card(self, timeout_in_sec, card_type):
    """
    Encode an admin contactless card


    The card is encoded according to terminal configuration.
    The card will contain the new contactless keys to load on other Morpho terminals.

    Parameters:
     - timeout_in_sec: Duration max. of the operation in seconds
     - card_type: Admin card type to encode
    """
    pass

  def cls_erase(self, timeout_in_sec, cards):
    """
    Erase a contactless card


    For DESFire cards, according to the cards definition, this command will erase either one or several files,
    either one or several applications or will format the card.<br>
    In case of card formatting, the master PICC key will be set to 3DES legacy default value.


    For MIFARE cards, this command will set every writable sectors to 0xFF.<br>
    Sector keys will be set to NXP default keys (0x00).

    Parameters:
     - timeout_in_sec: Duration max. of the operation in seconds
     - cards: List of card to support
    """
    pass

  def key_load(self, crypto_keys):
    """
    Load contactless keys<br/><br/>

    - For MIFARE cards, this command will load CRYPTO1 (MIFARE Classic) and/or AES (MIFARE Plus) keys.<br/>
    - For DESFire cards, this command will load 3DES and/or AES keys.<br/>
    - For iClass cards, this command will load the iClass key.<br/>
    - For RSA, this command will load the RSA key(s).<br/>
    - For l1 cards, this command will load the L1 site key.<br/>

    Parameters:
     - crypto_keys: Crypto key object
    """
    pass

  def key_reset(self, types):
    """
    Restore default contactless keys<br/><br/>

    - For MIFARE cards, this command will restore all MIFARE Classic and/or MIFARE Plus keys to default value.<br/>

    - For DESFire cards, this command will restore all DESFire 3DES and/or DESFire AES keys to default value.<br/>

    - For iClass cards, this command will restore the default iClass key.

    Parameters:
     - types: List of keys to reset to default value
    """
    pass

  def terminal_reboot(self):
    """
    When the command returns, terminal is going to reboot
    """
    pass

  def terminal_echo(self, buffer):
    """
    Send back a received buffer

    Buffer shall be less than 64 bytes

    @return The received buffer

    Parameters:
     - buffer: Buffer to be repeated
    """
    pass

  def terminal_get_configuration(self, terminal_settings_type):
    """
    That functions is used to retrieve information like:
    <ol>
    <li> Terminal's local date and time </li>
    <li> Terminal's IP configuration </li>
    <li> Terminal's WIFI configuration </li>
    <li> Terminal's GPRS configuration </li>
    <li> Terminal's serial channel configuration </li>
    </ol>

    Parameters:
     - terminal_settings_type: Terminal setting options
    """
    pass

  def terminal_set_configuration(self, terminal_config):
    """
    That functions is used to configure:
    <ol>
      <li> Terminal's local date and time (i.e. not Network Time Protocol) </li>
      <li> Terminal's IP configuration </li>
      <li> Terminal's WIFI configuration </li>
      <li> Terminal's serial channel configuration </li>
    </ol>
    <b>Note:</b>
    <ul>
      <li>While setting the serial channel configuration, a delay of 3 seconds is provided after sending the response
          to the client, so that the configuration is applied only after the response is sent to the client.
    </ul>

    Parameters:
     - terminal_config: Structure that contains configuration to apply. <br>
    It can contain several configurations.
    """
    pass

  def time_get_predefined_time_zone_list(self):
    """
    Get the list of terminal's predefined time zones


    The terminal contains a list of predefined time zones that can be used
    to configure terminal's date and time (see @a terminal_set_configuration).

    @return  A list of UTF-8 strings that represents predefined time zones handled
             by the terminal
    """
    pass

  def distant_session_set_state(self, state):
    """
    Open or close a distant session


    When a distant session is opened, the terminal only waits for distant commands.
    No local operation can be done.

    Parameters:
     - state: Open or Close the distant session
    """
    pass

  def distant_session_get_state(self):
    """
    Get the terminal's distant session state


    When a distant session is opened, the terminal only waits for distant commands.
    No local operation can be done.

    @return The distant session's status (opened or closed)
    """
    pass

  def cancel_operation(self):
    """
    Cancel current delayed command
    """
    pass

  def terminal_get_version(self, firmware_type):
    """
    Get firmware versions


    Return firmware version of requested board type (Terminal or Sensor)

    @return Firmware version

    Parameters:
     - firmware_type: Board to retrieve firmware version from
    """
    pass

  def terminal_retrieve_peripherals(self):
    """
    Retrieve the list of terminal internal peripherals.
    """
    pass

  def product_get_info(self, info_type):
    """
    Get product information from terminal board and sensor board.

    @return Requested information

    Parameters:
     - info_type: List of requested information
    """
    pass

  def get_terminal_capabilities(self, capability_list):
    """
    Gets the specified capabilities of the terminal.

    Parameters:
     - capability_list: List of the capabilities required
    """
    pass

  def wiegand_clock_data_send_string(self, data_to_send):
    """
    send wiegand or clock&data string

    Parameters:
     - data_to_send: binary wiegand or clock & data data to send
    """
    pass

  def picture_capture(self, input_interface, format):
    """
    Capture a picture in specified format


    The terminal will capture a picture from camera or will perform a screenshot,
    and will return the picture in specified format.

    @return The raw data of the captured picture

    Parameters:
     - input_interface: Interface that will capture the picture (Cameras or screen)
     - format: Format of the picture to retrieve (JPEG, BMP ...)
    """
    pass

  def picture_display(self, format, picture_data, coordinates, duration_in_sec):
    """
    Display a picture in specified format


    The terminal will display a picture on the screen.<br>
    The picture will start at the specified coordinates and will be displayed
    during the specified duration

    Parameters:
     - format: Format of the picture to display (JPEG, BMP ...)
     - picture_data: Raw data of the picture file
     - coordinates: Screen coordinates of the right-upper corner of the picture
     - duration_in_sec: Duration in seconds during which the picture is displayed
    """
    pass

  def display_text(self, message_text, coordinates, duration_in_sec):
    """
    Display a text message


    The terminal will display a text message on the screen.<br>
    The text message will start at the specified coordinates and will be displayed
    during the specified duration.<br>
    Min-Max range for duration is (0-255 seconds) where 0 = infinite time.<br>
    Min-Max range for X- co-ordinate is (0-720).<br>
    Min-Max range for Y- co-ordinate is (0-450)

    Parameters:
     - message_text: String message text to be display on terminal screen
     - coordinates: Screen coordinates of the right-upper corner of the message text
     - duration_in_sec: Duration in seconds during which the text message is displayed
    """
    pass

  def file_load(self, file_details, chunk):
    """
    Load a file into the terminal.<br>
    <b>Note:</b>
    <ol>
      <li>The <code>File_types.File_chunk.action</code> shall be taken into consideration only for the last chunk,
        i.e., when <code>File_types.File_chunk.is_last</code> is true.
      <li>Maxixum file sizes:
        <ul>
          <li><code>File_types.File_type.video</code>:    10 MB
          <li><code>File_types.File_type.audio</code>:   500 KB
          <li><code>File_types.File_type.picture</code>:   1 MB
          <li>Others:                                      5 MB
        </ul>
      <li>Maximum chunk size is 10240 bytes, i.e. 10 KB
      <li>Make sure video file is in proper format. (MPEG4 or VP8)
      <li>While updating stolen card entries, all previous entries will be deleted
    </ol><br>
    <b>Warning:</b><br>
    <ol>
      <li>You shall need a modified version of the generated code that supports
          handling of several request/response messages for the single call to the command.
      <li>For file type <code>File_types.File_type.stolen_card_list</code>, No error will be return.
          And maximum 250000 valid stolen card entried will be stored and rest of the entries will be ignored.
    </ol><br>
    <b>Functionality change required in Thrift generated client code (C++ sample)</b><br>
    <pre>
    void Generic_commandsClient::file_load(const  ::Distant_cmd::File_details& file_details, const  ::Distant_cmd::File_chunk& chunk)
    {
        <span style="color:green">// Original code section in the generated code
        // send_file_load(file_details, chunk);
        // recv_file_load();</span>
    &nbsp;
        <span style="color:green">// BEGIN: Custom section for receiving and processing intermediate data
        // This is actually multi-request handling</span>
        ::Distant_cmd::File_chunk actual_chunk; <span style="color:green">// a non-const chunk required</span>
        while(true)
        {
            <span style="color:green">// Client's call-back is supposed to load the data that shall be available in the 'actual_chunk' parameter to send to the Thrift server.
            //  Note that in case of the last chunk of data to be uploaded the 'actual_chunk.is_last' flag must be set.</span>
            Multiresponse_handler::client_cb_file_load(actual_chunk);
            send_file_load(file_details, actual_chunk);
    &nbsp;
            recv_file_load(); <span style="color:green">// required to see if exception was received -- so that further sending is stopped</span>
    &nbsp;
            if(actual_chunk.is_last) <span style="color:green">// Exit the loop since the last chunk has been sent and its corresponding response received</span>
            {
                break;
            }
        }
        <span style="color:green">// END: Custom section for receiving and processing intermediate data</span>
    }
    </pre>

    Parameters:
     - file_details: In cases where file name is required, the file shall be uploaded with the same name as the file name provided
     - chunk: The chunk of the file
    """
    pass

  def file_get(self, file_details):
    """
    Retrieve a file from the terminal.<br>
    <b>Functionality change required in Thrift generated client code (C++ sample)</b><br>
    <pre>
     void Generic_commandsClient::file_get( ::Distant_cmd::File_chunk& _return, const  ::Distant_cmd::File_details& file_details)
     {
         send_file_get(file_details);
         <span style="color:green">// recv_file_get(_return); // Original line in the generated code</span>
    &nbsp;
         <span style="color:green">// BEGIN: Custom section for receiving and processing intermediate data</span>
         while (true)
         {
             recv_file_get(_return); <span style="color:green">// Multiple reception in loop</span>
    &nbsp;
             <span style="color:green">// Following is the client's callaback assumed to take necessary action on the received data,
             //  e.g., keep writing the received partial data to the file until the last chunk of data is received.</span>
             Multiresponse_handler::client_cb_file_get(_return);
    &nbsp;
             if(_return.is_last) <span style="color:green">// Exit the loop if the data received was last of all the multiple data received, i.e., no more data to be received</span>
             {
                 break;
             }
         }
         <span style="color:green">// END: Custom section for receiving and processing intermediate data</span>
     }
    </pre>

    Parameters:
     - file_details: File details of the file to obtain
    (<code>File_types.File_details.name_UTF8</code> shall be ignored except where multiple files exist)
    """
    pass

  def file_get_filenames(self, file_type):
    """
    Retrieve all the files name for a given file type

    <h5>Returns</h5> List of structure for files' details

    Parameters:
     - file_type
    """
    pass

  def file_erase(self, file_details):
    """
    Erase a file represented by name and type

    Parameters:
     - file_details
    """
    pass

  def get_sdac_status(self):
    """
    Returns a structure containing 4 integers. The values in list are as follows :
    <ul>
    <li> SDAC mode : 0=Off, 1=On </li>
    <li> Relay state : 0=Door locked, 1=Door unlocked </li>
    <li> Door status : 0=Closed, 1=Open, -1=Error </li>
    <li> Request to exit state : 0=Off, 1=On, -1=Error </li>
    </ul>
    """
    pass

  def trigger_relay(self, duration_in_sec):
    """
    Trigger the relay for a given duration. A duration less or equal to 0 is forbidden.

    Parameters:
     - duration_in_sec: duration in second for relay activation
    """
    pass

  def authorized_IP_get_list(self, ip_protocol_type):
    """
    Returns a list of string of authorized IPs

    Parameters:
     - ip_protocol_type: IP protocol type i.e. v4, v6 or all
    """
    pass

  def authorized_IP_add(self, str_ip):
    """
    Adds an authorized IP

    Parameters:
     - str_ip: UTF8 string containing authorized IP
    """
    pass

  def authorized_IP_delete(self, str_ip):
    """
    Remove an authorized IP

    Parameters:
     - str_ip: UTF8 string containing authorized IP to be deleted
    """
    pass

  def authorized_IP_get_range_list(self, ip_protocol_type):
    """
    Returns a list of string of authorized IP ranges

    Parameters:
     - ip_protocol_type: IP protocol type i.e. v4, v6 or all
    """
    pass

  def authorized_IP_add_range(self, str_start_ip, str_end_ip):
    """
    Adds an authorized IP range

    Parameters:
     - str_start_ip: UTF8 string containing authorized IP range start address
     - str_end_ip: UTF8 string containing authorized IP range end address
    """
    pass

  def authorized_IP_delete_range(self, str_start_ip, str_end_ip):
    """
    Remove an authorized IP range

    Parameters:
     - str_start_ip: UTF8 string containing an authorized IP range start address to be deleted
     - str_end_ip: UTF8 string containing an authorized IP range end address to be deleted
    """
    pass

  def password_set(self, id, password_old, password_new):
    """
    To set a password

    @return True, if set successfully.


    Parameters:
     - id: password ID<br>
    Must be 0 (terminal password)
     - password_old: old password
     - password_new: new password
    """
    pass

  def password_verify(self, id, password):
    """
    To verify a given password with stored password

    @return True, if verify successfully.


    Parameters:
     - id: password ID<br>
    Must be 0 (terminal password)
     - password: password to be verified with stored password
    """
    pass

  def password_reset(self, id):
    """
    To reset a password

    @return True, if reset successfully.


    Parameters:
     - id: password ID<br>
    Must be 0 (terminal password)
    """
    pass

  def passphrase_set(self, id, passphrase):
    """
    To set a passphrase

    @return True, if set successfully.


    Parameters:
     - id: passphrase ID
     - passphrase: passphrase
    """
    pass

  def passphrase_reset(self, id):
    """
    To reset a passphrase

    @return True, if reset successfully.


    Parameters:
     - id: passphrase ID
    """
    pass

  def retrieve_keypad_input(self, timeout_in_sec):
    """
    To get user input from LCD GUI

    @return entered input from terminal

    Parameters:
     - timeout_in_sec: timeout in second for getting input
    """
    pass

  def access_schedule_retrieve(self, schedule_index):
    """
    Command to get the access schedule entries.

    @return list of access_schedule data according to schedule_index.
            List of Access_schedule provides data from sunday to saturday.


    Parameters:
     - schedule_index: access schedule index. Value should be between 1 to 58.
    Schedule 0 is never allowed schedule.
    Schedule 63 is always allowed schedule.
    Schedule 59 to 62 are reserved schedule.
    """
    pass

  def access_schedule_store(self, schedule_data):
    """
    Command to set the access schedule entries.

    Parameters:
     - schedule_data: access schedule data. List of Access_schedule takes data from sunday to saturday
    """
    pass

  def access_schedule_delete(self, schedule_index):
    """
    Command to reset the access schedule entries.

    Parameters:
     - schedule_index: access schedule index. Value should be between 1 to 58.
    Schedule 0 is never allowed schedule.
    Schedule 63 is always allowed schedule.
    Schedule 59 to 62 are reserved schedule.
    """
    pass

  def door_open_schedule_retrieve(self):
    """
    Command to get the door open schedule entries.

    @return list of Door_open_schedule data
            List of Door_open_schedule provides data from sunday to saturday.

    """
    pass

  def door_open_schedule_store(self, schedule_data):
    """
    Command to set the door open schedule entries.

    Parameters:
     - schedule_data: door open schedule data. List of Door_open_schedule takes data from sunday to saturday.
    """
    pass

  def door_open_schedule_delete(self):
    """
    Command to reset the door open schedule entries.
    """
    pass

  def holiday_schedule_retrieve(self, schedule_index):
    """
     * Command to get the Holiday schedule entries.
     *
     * @return list of Holi_schedule data according to schedule_index
    *

    Parameters:
     - schedule_index: holiday schedule index .  Value should be between 0 to 63
    """
    pass

  def holiday_schedule_store(self, schedule_data):
    """
    Command to set the holiday schedule entries.

    Parameters:
     - schedule_data: holiday schedule data
    """
    pass

  def holiday_schedule_delete(self, schedule_index):
    """
    Command to reset the holiday schedule entries.

    Parameters:
     - schedule_index: holiday schedule index . Value should be between 0 to 63
    """
    pass

  def scan_WIFI_networks(self):
    """
    Command to scan WIFI networks
    @return list of WIFI_network_info which contains network informations
    """
    pass

  def events_set_config(self, events):
    """
         Set one or more event configurations.<br />
         Following table shows which configurations are allowed for given event.<br /><br />
    <div style="margin:0 0 0 30px">
    <table border="5" cellpadding="0" cellspacing="0" width="800"><colgroup><col width="185"/><col width="64" span="6"/></colgroup><tbody><tr height="20"><td height="20" width="185"><strong>Event Name</strong></td><td width="64"><strong>Enable</strong></td><td width="64"><strong>Send To Cotroller</strong></td><td width="64"><strong>Trigger TTL0</strong></td><td width="64"><strong>Trigger TTL1</strong></td><td width="64"><strong>Trigger TTL2</strong></td><td width="64"><strong>Clock n Data ID</strong></td></tr>
    <tr height="20"><td height="20"><strong>tlac_duress_finger_detected</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20"><strong>tlac_fake_finger_detected</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="40"><td height="40" width="185"><strong>tlac_user_control_successful</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes
    </td><td> Yes </td><td></td></tr><tr height="20"><td height="20" width="185"><strong>tlac_biometric_mismatch</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20" width="185"><strong>tlac_pin_mismatch</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20" width="185"><strong>tlac_user_id_not_in_db</strong></td><td> Yes </td><td> Yes </td><td> Yes </td>
    <td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20" width="185"><strong>tlac_control_timed_out</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20" width="185"><strong>tlac_rejected_by_schedule</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td> Yes </td></tr><tr height="20"><td height="20" width="185"><strong>tlac_temp_validity_expired</strong></td><td> Yes
    </td><td> Yes </td><td></td><td></td><td></td><td> Yes </td></tr><tr height="20"><td height="20" width="185"><strong>tlac_useruser_not_in_white_list</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20"><strong>tlac_black_listed_card</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20"><strong>tlac_face_not_detected</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td> Yes </td></tr><tr height="20"><td height="20"><strong>tlac_multi_user_intermediate_id</strong></td><td> Yes
    </td><td></td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_transaction_log_full</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_controller_feedback_action</strong></td><td> Yes </td><td></td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_job_code_check_failure</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td> Yes </td></tr><tr height="20"><td height="20"><strong>tlac_door_opened_for_too_long</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr>
    <tr height="20"><td height="20"><strong>tlac_door_forced_open</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_door_closed_after_alarm</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_door_unlocked</strong></td><td> Yes </td><td> Yes
    </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_door_locked_back</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_management_menu_login</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td></td></tr><tr height="20"><td height="20"><strong>tlac_management_menu_logout</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr>
    <tr height="20"><td height="20"><strong>tlac_database_deleted</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_enrollment_completed</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_user_deleted</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_user_modification_completed</strong></td><td> Yes </td><td> Yes
    </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_cls_card_encoded</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_cls_card_reset</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_settings_changed</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_cls_card_security_key_reset</strong></td>
    <td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_security_policy_changed</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_tamper_detected</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20"><strong>tlac_tamper_cleared</strong></td><td> Yes
    </td><td></td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_terminal_boot_completed</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td></td></tr><tr height="20"><td height="20"><strong>tlac_firmware_upgrade</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_add_user</strong></td><td> Yes </td><td> Yes </td><td></td>
    <td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_reboot_initiated</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_user_rule_check_failure</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td> Yes </td></tr></tbody></table></div>

    Parameters:
     - events: Mapping of Event IDs to their config structure fields
    """
    pass

  def events_get_config(self, event_IDs):
    """
    Returns one or more event configuration.


    @return A map of Event IDs and their corresponding records.<br>

    Parameters:
     - event_IDs: List of Event IDs to return
    """
    pass

  def licenses_add(self, license):
    """
    Add license(s) to terminal

    Parameters:
     - license: License file content
    """
    pass

  def licenses_get(self):
    """
    Retrieve the list of the licenses stored in the terminal
    @return A list of the licenses contained in the terminal (empty list if the terminal doesn't contain license)
    """
    pass

  def config_get_video_phone_params(self):
    """
    Gets the list of video phone profiles.
    """
    pass

  def config_set_video_phone_params(self, params_video_phone):
    """
    Sets the list of video phone profiles<BR>
    <B>Note:</B>
    <ol>
     <li>A maximum of 20 profiles shall be stored.
     <li>If the number of profiles stored is less than 20, say 15, a fresh copy of the profiles,
             the 15 which are provided, and the remaining 5 blank profiles shall be stored.<br>
             For any GUI application, the blank profiles are like empty slots, which may not be required to be displayed.
     <li>To erase all profiles, the parameter <code>params_video_phone</code> with <i>zero</i> size must be passed.
     <li>To edit one or more profiles, and set them, the remaining profiles shall be preserved only if the latter profiles
             are again provided to set as is.<br>
             For instance, if you want to edit profiles #2 and #3, get all the profiles
             (via <code>config_get_video_phone_params</code>), edit the profiles of interest (profile #2 and #3),
             and using this API, set all the 20 profiles back. This way, the profiles other than profiles #2 and #3
             are preserved and not deleted. In case you pass <i>only</i> profiles #2 and #3 to this API, the rest of the profiles
             shall be stored as blank profiles, i.e., effectively deleting them.
     <li>Any profile entry with all of its parameters empty, i.e., empty strings and <code>0</code> for
             <code>Video_phone_params.port</code>, shall be considered as a blank profile (empty slot).
     <li>Any profile entry with not all of its parameters empty shall throw appropriate exception.
    </ol>

    Parameters:
     - params_video_phone: The list of video phone parameters. The list size to be maximum 20.
    """
    pass

  def send_to_host(self, host_config, data):
    """
    That functions is used to send data on host:
    <ol>
    <li> Send data to host on IP network </li>
    <li> Send data to host on serial channel </li>
    </ol>

    Parameters:
     - host_config: Structure that contains configuration of host channel. <br>
    It can contain several configurations.
     - data: data to send on host channel
    """
    pass

  def retrieve_language_file_list(self):
    """
    Retrieve the list of language files stored in /rootfs_data/Translation
    @return A list of string of the language files
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def job_code_load_lists(self, list_values):
    """
    To load one or more job code lists

    This command will add job code list and if list is already
    exist then it will update the list

    Parameters:
     - list_values: List number to be created
    """
    self.send_job_code_load_lists(list_values)
    self.recv_job_code_load_lists()

  def send_job_code_load_lists(self, list_values):
    self._oprot.writeMessageBegin('job_code_load_lists', TMessageType.CALL, self._seqid)
    args = job_code_load_lists_args()
    args.list_values = list_values
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_job_code_load_lists(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = job_code_load_lists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.jc_invalid_list_ex is not None:
      raise result.jc_invalid_list_ex
    if result.jc_list_full_ex is not None:
      raise result.jc_list_full_ex
    if result.jc_invalid_array_length_ex is not None:
      raise result.jc_invalid_array_length_ex
    return

  def job_code_retrieve_lists(self, list_numbers):
    """
    To retrieve one or more job code lists data

    @return The job code list array.

    Parameters:
     - list_numbers: List numbers to be retrieved
    """
    self.send_job_code_retrieve_lists(list_numbers)
    return self.recv_job_code_retrieve_lists()

  def send_job_code_retrieve_lists(self, list_numbers):
    self._oprot.writeMessageBegin('job_code_retrieve_lists', TMessageType.CALL, self._seqid)
    args = job_code_retrieve_lists_args()
    args.list_numbers = list_numbers
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_job_code_retrieve_lists(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = job_code_retrieve_lists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.jc_invalid_list_ex is not None:
      raise result.jc_invalid_list_ex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "job_code_retrieve_lists failed: unknown result");

  def job_code_retrieve_list_indices(self):
    """
    To retrieve all job code list number and name

    @return All job code list number and name.
    """
    self.send_job_code_retrieve_list_indices()
    return self.recv_job_code_retrieve_list_indices()

  def send_job_code_retrieve_list_indices(self):
    self._oprot.writeMessageBegin('job_code_retrieve_list_indices', TMessageType.CALL, self._seqid)
    args = job_code_retrieve_list_indices_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_job_code_retrieve_list_indices(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = job_code_retrieve_list_indices_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "job_code_retrieve_list_indices failed: unknown result");

  def job_code_check_value_against_user(self, user_id, jobcode_value):
    """
    Job code value validate against user


    Parameters:
     - user_id: User ID for which job code is to be checked
     - jobcode_value: Job code value to be validated
    """
    self.send_job_code_check_value_against_user(user_id, jobcode_value)
    self.recv_job_code_check_value_against_user()

  def send_job_code_check_value_against_user(self, user_id, jobcode_value):
    self._oprot.writeMessageBegin('job_code_check_value_against_user', TMessageType.CALL, self._seqid)
    args = job_code_check_value_against_user_args()
    args.user_id = user_id
    args.jobcode_value = jobcode_value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_job_code_check_value_against_user(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = job_code_check_value_against_user_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.jc_validation_failed_ex is not None:
      raise result.jc_validation_failed_ex
    return

  def job_code_empty_lists(self, list_numbers):
    """
    To remove one or more job code lists
    @return Map of list number to the delete status, if successful then 'true'

    Parameters:
     - list_numbers: List array to be removed
    """
    self.send_job_code_empty_lists(list_numbers)
    return self.recv_job_code_empty_lists()

  def send_job_code_empty_lists(self, list_numbers):
    self._oprot.writeMessageBegin('job_code_empty_lists', TMessageType.CALL, self._seqid)
    args = job_code_empty_lists_args()
    args.list_numbers = list_numbers
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_job_code_empty_lists(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = job_code_empty_lists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "job_code_empty_lists failed: unknown result");

  def job_code_remove_all_lists(self):
    """
    To remove all job code lists

    """
    self.send_job_code_remove_all_lists()
    self.recv_job_code_remove_all_lists()

  def send_job_code_remove_all_lists(self):
    self._oprot.writeMessageBegin('job_code_remove_all_lists', TMessageType.CALL, self._seqid)
    args = job_code_remove_all_lists_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_job_code_remove_all_lists(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = job_code_remove_all_lists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    return

  def transaction_log_get_status(self, filter):
    """
    Command to get the transaction log status.

    @return Transaction log status values.


    Parameters:
     - filter: Filter to be applied for getting transaction log count as per filter.
    """
    self.send_transaction_log_get_status(filter)
    return self.recv_transaction_log_get_status()

  def send_transaction_log_get_status(self, filter):
    self._oprot.writeMessageBegin('transaction_log_get_status', TMessageType.CALL, self._seqid)
    args = transaction_log_get_status_args()
    args.filter = filter
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_transaction_log_get_status(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = transaction_log_get_status_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_arg_xcept is not None:
      raise result.invalid_arg_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "transaction_log_get_status failed: unknown result");

  def transaction_log_retrieve(self, filter, required_fields):
    """
    Command to retrieve the transaction log entries.

    This command is multi response command. It will give data in multiresponse.
    @return List of the transaction log entries as per the filter applied.<br></br>
    <b>Functionality change required in Thrift generated client code (C++ sample)</b><br>
    <pre>
    void Generic_commandsClient::transaction_log_retrieve(std::vector< ::Distant_cmd::Transaction_log_DB_record> & _return, const  ::Distant_cmd::Transaction_log_filter& filter, const std::set< ::Distant_cmd::Transaction_log_DB_fields::type> & required_fields)
    {
        send_transaction_log_retrieve(filter, required_fields);
        <span style="color:green">// recv_transaction_log_retrieve(_return); // Original line in the generate code</span>
    &nbsp;
        <span style="color:green">// BEGIN: Custom section for receiving and processing intermediate data</span>
        uint32_t loop_id = 0;
        while (true)
        {
            recv_transaction_log_retrieve (_return);
    &nbsp;
            <span style="color:green">// Check if the perticular data chunk is final or not.
            //If it is the final data chunk, the data will be returned in normal way not as callback.</span>
            if (_return.empty() || _return[_return.size() - 1].is_final_response)
            {
                break;
            }
            else
            {
                <span style="color:green">// If the data chunk is not final, the data chunk will be returned as callback function manner
                // Following is the client's callaback, if set, assumed to take necessary action on the received data,
                // e.g. Do process (store somewhere in file or memory) the retrieved transaction log chunk as other chunks are yet to be received.</span>
                if (Multiresponse_handler::client_tlog_command)
                {
                    Multiresponse_handler::client_tlog_command(_return);
                }
            }
        }
        <span style="color:green">// END: Custom section for receiving and processing intermediate data</span>
    }
    </pre>

    Parameters:
     - filter: Filter to be applied for retrieving transaction logs.
     - required_fields: List of the transaction log fields to be retrieved
    """
    self.send_transaction_log_retrieve(filter, required_fields)
    return self.recv_transaction_log_retrieve()

  def send_transaction_log_retrieve(self, filter, required_fields):
    self._oprot.writeMessageBegin('transaction_log_retrieve', TMessageType.CALL, self._seqid)
    args = transaction_log_retrieve_args()
    args.filter = filter
    args.required_fields = required_fields
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_transaction_log_retrieve(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = transaction_log_retrieve_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_arg_xcept is not None:
      raise result.invalid_arg_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "transaction_log_retrieve failed: unknown result");

  def transaction_log_delete_all(self):
    """
    Command to delete all the transaction log entries.
    """
    self.send_transaction_log_delete_all()
    self.recv_transaction_log_delete_all()

  def send_transaction_log_delete_all(self):
    self._oprot.writeMessageBegin('transaction_log_delete_all', TMessageType.CALL, self._seqid)
    args = transaction_log_delete_all_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_transaction_log_delete_all(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = transaction_log_delete_all_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    return

  def transaction_log_get_fields(self):
    """
    Gets the available fields in the transaction log records

    @return The list of available transaction log record fields.
    """
    self.send_transaction_log_get_fields()
    return self.recv_transaction_log_get_fields()

  def send_transaction_log_get_fields(self):
    self._oprot.writeMessageBegin('transaction_log_get_fields', TMessageType.CALL, self._seqid)
    args = transaction_log_get_fields_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_transaction_log_get_fields(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = transaction_log_get_fields_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "transaction_log_get_fields failed: unknown result");

  def config_get_all_params_name(self):
    """
    Returns a list of name of all terminal parameters
    """
    self.send_config_get_all_params_name()
    return self.recv_config_get_all_params_name()

  def send_config_get_all_params_name(self):
    self._oprot.writeMessageBegin('config_get_all_params_name', TMessageType.CALL, self._seqid)
    args = config_get_all_params_name_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_config_get_all_params_name(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = config_get_all_params_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "config_get_all_params_name failed: unknown result");

  def config_get_params(self, param_list_UTF8):
    """
    Returns a list of values corresponding to requested parameters

    Parameters:
     - param_list_UTF8: List of UTF8 string representing names of requested parameters
    """
    self.send_config_get_params(param_list_UTF8)
    return self.recv_config_get_params()

  def send_config_get_params(self, param_list_UTF8):
    self._oprot.writeMessageBegin('config_get_params', TMessageType.CALL, self._seqid)
    args = config_get_params_args()
    args.param_list_UTF8 = param_list_UTF8
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_config_get_params(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = config_get_params_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.inexistant_param_xcept is not None:
      raise result.inexistant_param_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "config_get_params failed: unknown result");

  def config_set_params(self, param_map):
    """
    Set requested parameters with given values

    Parameters:
     - param_map: List of key-value pairs.<br>
    Parameters are represented by a UTF8 string
    """
    self.send_config_set_params(param_map)
    self.recv_config_set_params()

  def send_config_set_params(self, param_map):
    self._oprot.writeMessageBegin('config_set_params', TMessageType.CALL, self._seqid)
    args = config_set_params_args()
    args.param_map = param_map
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_config_set_params(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = config_set_params_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.inexistant_param_xcept is not None:
      raise result.inexistant_param_xcept
    if result.invalid_value_xcept is not None:
      raise result.invalid_value_xcept
    if result.license_not_xcept is not None:
      raise result.license_not_xcept
    if result.sd_card_not_found_xcept is not None:
      raise result.sd_card_not_found_xcept
    return

  def config_get_range(self, param_keys):
    """
    Get the value range of the required or all configuration parameters.


    Parameters:
     - param_keys: List of key-value pairs.<br>
    Parameters are represented by a UTF8 string
    """
    self.send_config_get_range(param_keys)
    return self.recv_config_get_range()

  def send_config_get_range(self, param_keys):
    self._oprot.writeMessageBegin('config_get_range', TMessageType.CALL, self._seqid)
    args = config_get_range_args()
    args.param_keys = param_keys
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_config_get_range(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = config_get_range_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.inexistant_param_xcept is not None:
      raise result.inexistant_param_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "config_get_range failed: unknown result");

  def cls_authenticate_user(self, timeout_in_sec, authent_param):
    """
    Use data contained in a contactless card to authenticate an user (biometric and/or PIN and/or BIOPIN check)<br><br>
    <b>Functionality change required in Thrift generated client code (C++ sample)</b><br>
    Similar to the <a href=#SampleBiofingerIdentify>C++ sample code</a> provided for the method <code>biofinger_identify</code>

    Parameters:
     - timeout_in_sec: Max. duration of Smartcard detection process<br>
    0 implies an infinite process.
     - authent_param: Contactless authentication parameters
    """
    self.send_cls_authenticate_user(timeout_in_sec, authent_param)
    return self.recv_cls_authenticate_user()

  def send_cls_authenticate_user(self, timeout_in_sec, authent_param):
    self._oprot.writeMessageBegin('cls_authenticate_user', TMessageType.CALL, self._seqid)
    args = cls_authenticate_user_args()
    args.timeout_in_sec = timeout_in_sec
    args.authent_param = authent_param
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cls_authenticate_user(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cls_authenticate_user_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.timeout_xcept is not None:
      raise result.timeout_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    if result.cancelled_xcept is not None:
      raise result.cancelled_xcept
    if result.misplaced_finger_xcept is not None:
      raise result.misplaced_finger_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cls_authenticate_user failed: unknown result");

  def biofinger_identify(self, database_id, timeout_in_sec, threshold, enable_intermediate_replies, optional_param):
    """
    Identify an user using its finger against the terminal database

    The reference templates are stored in one (and only one) specified record.<br>
    The search template is compared to all the templates found in the database

    <b>Warning:</b> If @a enable_intermediate_replies is true, you will need a modified version of the Thrift client that supports
             the reception of several T_REPLY messages for one command.<br><br>
    <b id="SampleBiofingerIdentify">Functionality change required in Thrift generated client code (C++ sample)</b><br>
    <pre>
    void Generic_commandsClient::biofinger_identify(::Distant_cmd::Biofinger_control_operation_reply& _return,
            const int8_t database_id, const int32_t timeout_in_sec, const int8_t threshold,
            const bool enable_intermediate_replies, const ::Distant_cmd::Biofinger_control_optional_param& optional_param)
    {
        send_biofinger_identify(database_id, timeout_in_sec, threshold, enable_intermediate_replies, optional_param);
        <span style="color:green">// recv_biofinger_identify(_return); // Original line in the generated code</span>
    &nbsp;
        <span style="color:green">// BEGIN: Custom section for receiving and processing intermediate data</span>
        uint32_t loop_id = 0;
        while (true)
        {
            <span style="color:green">// receive intermediate response</span>
            recv_biofinger_identify(_return);
    &nbsp;
            <span style="color:green">// check for final_result status</span>
            if (_return.__isset.final_result)
            {
                break; <span style="color:green">// if final_result callback, break from loop</span>
            }
            else if (_return.__isset.cb_bio_command) <span style="color:green">// check for interested callback</span>
            {
                _return.__isset.cb_bio_command = false; <span style="color:green">// reset the callback flag</span>
                if (Multiresponse_handler::client_cb_bio_command)
                {
                    <span style="color:green">// process callback data</span>
                    Multiresponse_handler::client_cb_bio_command(_return.cb_bio_command);
                }
            }
            else if (_return.__isset.cb_low_resol_live_image)
            {
                <span style="color:green">// Process similar to "if (_return.__isset.cb_bio_command)" block</span>
            }
            else if (_return.__isset.cb_high_resol_capture_image)
            {
                <span style="color:green">// Process similar to "if (_return.__isset.cb_bio_command)" block</span>
            }
            else if (_return.__isset.cb_capture_quality)
            {
                <span style="color:green">// Process similar to "if (_return.__isset.cb_bio_command)" block</span>
            }
            else if (_return.__isset.cb_live_quality)
            {
                <span style="color:green">// Process similar to "if (_return.__isset.cb_bio_command)" block</span>
            }
        }
        <span style="color:green">// END: Custom section for receiving and processing intermediate data</span>
    }
    </pre>

    Parameters:
     - database_id: Database identifier
     - timeout_in_sec: Max. duration of identification process<br>
    0 implies an infinite process.
     - threshold: This parameter specifies the value of the False Acceptance Ratio (FAR) of the MorphoSmart\99 device.<br>
    The value of this parameter can be set from 0 to 10, by 1 value steps.
     - enable_intermediate_replies: If set to false, you will receive only one reply containing the final result of the
    identification, otherwise you may also receive asynchronous replies containing the
    progress status of the identification.
     - optional_param: Identification optional parameters
    """
    self.send_biofinger_identify(database_id, timeout_in_sec, threshold, enable_intermediate_replies, optional_param)
    return self.recv_biofinger_identify()

  def send_biofinger_identify(self, database_id, timeout_in_sec, threshold, enable_intermediate_replies, optional_param):
    self._oprot.writeMessageBegin('biofinger_identify', TMessageType.CALL, self._seqid)
    args = biofinger_identify_args()
    args.database_id = database_id
    args.timeout_in_sec = timeout_in_sec
    args.threshold = threshold
    args.enable_intermediate_replies = enable_intermediate_replies
    args.optional_param = optional_param
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_biofinger_identify(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = biofinger_identify_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.DB_empty_xcept is not None:
      raise result.DB_empty_xcept
    if result.timeout_xcept is not None:
      raise result.timeout_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    if result.cancelled_xcept is not None:
      raise result.cancelled_xcept
    if result.misplaced_finger_xcept is not None:
      raise result.misplaced_finger_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "biofinger_identify failed: unknown result");

  def biofinger_authenticate_db(self, database_id, timeout_in_sec, threshold, user_id_UTF8, enable_intermediate_replies, optional_param):
    """
    Authenticates an user using its finger against its database references


    The reference templates are stored in one (and only one) specified record.<br>
    The search template is compared to all the templates found in the specified record
    (the number of fingerprint templates depends on the database format).


    <b>Warning:</b> If @a enable_intermediate_replies is true, you will need a modified version of the Thrift client that supports
             the reception of several T_REPLY messages for one command.<br><br>
    <b>Functionality change required in Thrift generated client code (C++ sample)</b><br>
    Similar to the <a href=#SampleBiofingerIdentify>C++ sample code</a> provided for the method <code>biofinger_identify</code>

    Parameters:
     - database_id: Database identifier
     - timeout_in_sec: Max. duration of authentication process<br>
    0 implies an infinite process.
     - threshold: This parameter specifies the value of the False Acceptance Ratio (FAR) of the MorphoSmart\99 device.<br>
    The value of this parameter can be set from 0 to 10, by 1 value steps.
     - user_id_UTF8: User ID to authenticate (UTF8 string)
     - enable_intermediate_replies: If set to false, you will receive only one reply containing the final result of the
    authentication, otherwise you may also receive asynchronous replies containing the
    progress status of the authentication.
     - optional_param: Authentication optional parameters
    """
    self.send_biofinger_authenticate_db(database_id, timeout_in_sec, threshold, user_id_UTF8, enable_intermediate_replies, optional_param)
    return self.recv_biofinger_authenticate_db()

  def send_biofinger_authenticate_db(self, database_id, timeout_in_sec, threshold, user_id_UTF8, enable_intermediate_replies, optional_param):
    self._oprot.writeMessageBegin('biofinger_authenticate_db', TMessageType.CALL, self._seqid)
    args = biofinger_authenticate_db_args()
    args.database_id = database_id
    args.timeout_in_sec = timeout_in_sec
    args.threshold = threshold
    args.user_id_UTF8 = user_id_UTF8
    args.enable_intermediate_replies = enable_intermediate_replies
    args.optional_param = optional_param
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_biofinger_authenticate_db(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = biofinger_authenticate_db_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.inexistant_user_xcept is not None:
      raise result.inexistant_user_xcept
    if result.DB_empty_xcept is not None:
      raise result.DB_empty_xcept
    if result.timeout_xcept is not None:
      raise result.timeout_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    if result.cancelled_xcept is not None:
      raise result.cancelled_xcept
    if result.misplaced_finger_xcept is not None:
      raise result.misplaced_finger_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "biofinger_authenticate_db failed: unknown result");

  def biofinger_authenticate_ref(self, timeout_in_sec, threshold, ref_template_list, enable_intermediate_replies, optional_param):
    """
    <b>Functionality change required in Thrift generated client code (C++ sample)</b><br>
    Similar to the <a href=#SampleBiofingerIdentify>C++ sample code</a> provided for the method <code>biofinger_identify</code>

    Parameters:
     - timeout_in_sec: Max. duration of authentication process<br>
    0 implies an infinite process.
     - threshold: This parameter specifies the value of the False Acceptance Ratio (FAR) of the MorphoSmart\99 device.<br>
    The value of this parameter can be set from 0 to 10, by 1 value steps.
     - ref_template_list:                                                                * List of reference templates<br>
                                                                   * The templates can be in any format handled by the terminal<br>
    * Max number of templates per list is 20
     - enable_intermediate_replies: If set to false, you will receive only one reply containing the final result of the
    authentication, otherwise you may also receive asynchronous replies containing the
    progress status of the authentication.
     - optional_param: Authentication optional parameters
    """
    self.send_biofinger_authenticate_ref(timeout_in_sec, threshold, ref_template_list, enable_intermediate_replies, optional_param)
    return self.recv_biofinger_authenticate_ref()

  def send_biofinger_authenticate_ref(self, timeout_in_sec, threshold, ref_template_list, enable_intermediate_replies, optional_param):
    self._oprot.writeMessageBegin('biofinger_authenticate_ref', TMessageType.CALL, self._seqid)
    args = biofinger_authenticate_ref_args()
    args.timeout_in_sec = timeout_in_sec
    args.threshold = threshold
    args.ref_template_list = ref_template_list
    args.enable_intermediate_replies = enable_intermediate_replies
    args.optional_param = optional_param
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_biofinger_authenticate_ref(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = biofinger_authenticate_ref_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.unsupported_format_xcept is not None:
      raise result.unsupported_format_xcept
    if result.incomptible_ref_xcept is not None:
      raise result.incomptible_ref_xcept
    if result.timeout_xcept is not None:
      raise result.timeout_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    if result.cancelled_xcept is not None:
      raise result.cancelled_xcept
    if result.misplaced_finger_xcept is not None:
      raise result.misplaced_finger_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "biofinger_authenticate_ref failed: unknown result");

  def biofinger_enroll(self, database_id, timeout_in_sec, enrollment_type, nb_of_finger, user_id_UTF8, user_fields, enable_intermediate_replies, optional_param):
    """
    Captures user fingers, optionally stores them in terminal database,
    and/or returns finger templates, and/or returns fingerprint images.


    The template is calculated after three finger acquisitions (the user has to put each finger three times on the sensor).<br>
    To obtain the best accuracy, users are advised to use the fore, the thumb or the middle fingers.<br><br>
    <b>Functionality change required in Thrift generated client code (C++ sample)</b><br>
    Similar to the <a href=#SampleBiofingerIdentify>C++ sample code</a> provided for the method <code>biofinger_identify</code>

    Parameters:
     - database_id: Database identifier<br>
    That parameter is useless if the function does not store in terminal database
     - timeout_in_sec: Max. duration of authentication process<br>
    0 implies an infinite process. Allowed range is 0 - 65535 seconds
     - enrollment_type: This function can create a new record in terminal user database,
    or can return the captured templated, or can perform both.
     - nb_of_finger: Number of fingers to enroll.
    It can be 1, 2 or 3 fingers.
     - user_id_UTF8: User ID to enroll<br>
    That parameter is useless if the function does not store in terminal database
     - user_fields: The user's data to store along with templates<br>
    That parameter is useless if the function does not store in terminal database
     - enable_intermediate_replies: If set to false, you will receive only one reply containing the final result of the
    enrollment, otherwise you may also receive asynchronous replies containing the
    progress status of the enrollment.
     - optional_param: Enrollment optional parameter
    """
    self.send_biofinger_enroll(database_id, timeout_in_sec, enrollment_type, nb_of_finger, user_id_UTF8, user_fields, enable_intermediate_replies, optional_param)
    return self.recv_biofinger_enroll()

  def send_biofinger_enroll(self, database_id, timeout_in_sec, enrollment_type, nb_of_finger, user_id_UTF8, user_fields, enable_intermediate_replies, optional_param):
    self._oprot.writeMessageBegin('biofinger_enroll', TMessageType.CALL, self._seqid)
    args = biofinger_enroll_args()
    args.database_id = database_id
    args.timeout_in_sec = timeout_in_sec
    args.enrollment_type = enrollment_type
    args.nb_of_finger = nb_of_finger
    args.user_id_UTF8 = user_id_UTF8
    args.user_fields = user_fields
    args.enable_intermediate_replies = enable_intermediate_replies
    args.optional_param = optional_param
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_biofinger_enroll(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = biofinger_enroll_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.incompatbile_ref_xcept is not None:
      raise result.incompatbile_ref_xcept
    if result.timeout_xcept is not None:
      raise result.timeout_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    if result.cancelled_xcept is not None:
      raise result.cancelled_xcept
    if result.duplicate_record_xcept is not None:
      raise result.duplicate_record_xcept
    if result.DB_full_xcept is not None:
      raise result.DB_full_xcept
    if result.unavailable_field_xcept is not None:
      raise result.unavailable_field_xcept
    if result.duplicated_finger_xcept is not None:
      raise result.duplicated_finger_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "biofinger_enroll failed: unknown result");

  def PIN_authenticate_db(self, timeout_in_sec, user_id_UTF8):
    """
    Authenticates an user using its PIN code stored in terminal database


    User has to enter a PIN code on the terminal keypad.


    @return True, if the code keyed by the user matches the database user's PIN code, otherwise false.

    Parameters:
     - timeout_in_sec: Max. duration of authentication process<br>
    Limited to 60s.
     - user_id_UTF8: User ID to authenticate (UTF8 string)
    """
    self.send_PIN_authenticate_db(timeout_in_sec, user_id_UTF8)
    return self.recv_PIN_authenticate_db()

  def send_PIN_authenticate_db(self, timeout_in_sec, user_id_UTF8):
    self._oprot.writeMessageBegin('PIN_authenticate_db', TMessageType.CALL, self._seqid)
    args = PIN_authenticate_db_args()
    args.timeout_in_sec = timeout_in_sec
    args.user_id_UTF8 = user_id_UTF8
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_PIN_authenticate_db(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = PIN_authenticate_db_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "PIN_authenticate_db failed: unknown result");

  def reset_factory_settings(self, list_of_settings):
    """
    Reset selected parameters to factory settings.


    Parameters:
     - list_of_settings: List of the settings to reset.
    """
    self.send_reset_factory_settings(list_of_settings)
    self.recv_reset_factory_settings()

  def send_reset_factory_settings(self, list_of_settings):
    self._oprot.writeMessageBegin('reset_factory_settings', TMessageType.CALL, self._seqid)
    args = reset_factory_settings_args()
    args.list_of_settings = list_of_settings
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_reset_factory_settings(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = reset_factory_settings_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    return

  def user_DB_get_status(self, type):
    """
    Gets the user's database status

    @return The database capacity and number of records.

    Parameters:
     - type: Type of user to retrieve status
    """
    self.send_user_DB_get_status(type)
    return self.recv_user_DB_get_status()

  def send_user_DB_get_status(self, type):
    self._oprot.writeMessageBegin('user_DB_get_status', TMessageType.CALL, self._seqid)
    args = user_DB_get_status_args()
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_user_DB_get_status(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = user_DB_get_status_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "user_DB_get_status failed: unknown result");

  def user_DB_get_fields(self):
    """
    Gets the available fields


    This command returns the list of available user fields in the terminal database.

    @return The list of available user fields.
    """
    self.send_user_DB_get_fields()
    return self.recv_user_DB_get_fields()

  def send_user_DB_get_fields(self):
    self._oprot.writeMessageBegin('user_DB_get_fields', TMessageType.CALL, self._seqid)
    args = user_DB_get_fields_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_user_DB_get_fields(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = user_DB_get_fields_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "user_DB_get_fields failed: unknown result");

  def user_DB_set_users(self, users, enable_similar_finger_check):
    """
    Adds or modify one or more user records in the database


    Only the fields which are present in the DB_record structure will be modified.

    <b>Warning:</b> If the command is used to set non compressed templates, they all shall be of the same type.
     users list should be limited to 100 entries otherwise terminal may misbehave.

    Parameters:
     - users: Mapping of User IDs (UTF8 string) to their database fields
     - enable_similar_finger_check: If set to true,  checks  on  reference  templates  are performed:  same  finger  cannot  be  used  twice,<br>
    and  the  person  must  not  be  already  enrolled.<br>
    If set to false, these checks are not performed.<br>
    This  option  is  useful  to  reduce  the  time  taken  to  fill  large databases.<br>
    In this case, the database coherence must be previously checked.
    """
    self.send_user_DB_set_users(users, enable_similar_finger_check)
    self.recv_user_DB_set_users()

  def send_user_DB_set_users(self, users, enable_similar_finger_check):
    self._oprot.writeMessageBegin('user_DB_set_users', TMessageType.CALL, self._seqid)
    args = user_DB_set_users_args()
    args.users = users
    args.enable_similar_finger_check = enable_similar_finger_check
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_user_DB_set_users(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = user_DB_set_users_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.DB_full_xcept is not None:
      raise result.DB_full_xcept
    if result.unavailable_field_xcept is not None:
      raise result.unavailable_field_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    if result.duplicate_finger_xcept is not None:
      raise result.duplicate_finger_xcept
    if result.duplicate_user_xcept is not None:
      raise result.duplicate_user_xcept
    return

  def user_DB_delete_records(self, user_IDs_UTF8):
    """
    Deletes one or more user record from the terminal database


    <b>Warning:</b> If a user is not found, no error is reported.

    Parameters:
     - user_IDs_UTF8: User IDs (UTF8 string) of records to delete
    """
    self.send_user_DB_delete_records(user_IDs_UTF8)
    return self.recv_user_DB_delete_records()

  def send_user_DB_delete_records(self, user_IDs_UTF8):
    self._oprot.writeMessageBegin('user_DB_delete_records', TMessageType.CALL, self._seqid)
    args = user_DB_delete_records_args()
    args.user_IDs_UTF8 = user_IDs_UTF8
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_user_DB_delete_records(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = user_DB_delete_records_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "user_DB_delete_records failed: unknown result");

  def user_DB_delete_all_records(self):
    """
    Deletes all user records from the terminal database
    """
    self.send_user_DB_delete_all_records()
    self.recv_user_DB_delete_all_records()

  def send_user_DB_delete_all_records(self):
    self._oprot.writeMessageBegin('user_DB_delete_all_records', TMessageType.CALL, self._seqid)
    args = user_DB_delete_all_records_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_user_DB_delete_all_records(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = user_DB_delete_all_records_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    return

  def user_DB_get_users(self, user_IDs_UTF8, requested_fields):
    """
    Returns one or more user records.


    <b>Warning:</b> The list of user ID shall be limited to 100 items max.


    @return A map of UserIDs and their corresponding records.<br>
            If a user_IDs is not found, it will not be present in the map.

    Parameters:
     - user_IDs_UTF8: List of User IDs to return
     - requested_fields: Fields to return in the DB_record structure. It can be empty if you just
    want to check for a User ID presence.
    """
    self.send_user_DB_get_users(user_IDs_UTF8, requested_fields)
    return self.recv_user_DB_get_users()

  def send_user_DB_get_users(self, user_IDs_UTF8, requested_fields):
    self._oprot.writeMessageBegin('user_DB_get_users', TMessageType.CALL, self._seqid)
    args = user_DB_get_users_args()
    args.user_IDs_UTF8 = user_IDs_UTF8
    args.requested_fields = requested_fields
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_user_DB_get_users(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = user_DB_get_users_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "user_DB_get_users failed: unknown result");

  def user_DB_get_user_IDs(self, type):
    """
    Returns the list of all user IDs (UTF8 string) present in terminal database based on user type

    @note For the moment, only the users ID of users in biometric database or in white list can be retrieved.

    Parameters:
     - type: Kind of user to retrieve
    """
    self.send_user_DB_get_user_IDs(type)
    return self.recv_user_DB_get_user_IDs()

  def send_user_DB_get_user_IDs(self, type):
    self._oprot.writeMessageBegin('user_DB_get_user_IDs', TMessageType.CALL, self._seqid)
    args = user_DB_get_user_IDs_args()
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_user_DB_get_user_IDs(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = user_DB_get_user_IDs_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "user_DB_get_user_IDs failed: unknown result");

  def dynamic_message_set(self, dm_list):
    """
    Set dynamic message of users.

    <b>Warning:</b> Dynamic messages list should be limited to 500 entries otherwise terminal may misbehave.

    Parameters:
     - dm_list: Mapping of User IDs (UTF8 string) to their dynamic message database fields
    """
    self.send_dynamic_message_set(dm_list)
    self.recv_dynamic_message_set()

  def send_dynamic_message_set(self, dm_list):
    self._oprot.writeMessageBegin('dynamic_message_set', TMessageType.CALL, self._seqid)
    args = dynamic_message_set_args()
    args.dm_list = dm_list
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_dynamic_message_set(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = dynamic_message_set_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    if result.sd_card_not_found_xcept is not None:
      raise result.sd_card_not_found_xcept
    return

  def dynamic_message_get(self, user_IDs_UTF8):
    """
    Get dynamic message of users.

    <b>Warning:</b> User IDs list should be limited to 500 entries otherwise terminal may misbehave.

    @return The list of read files/data

    Parameters:
     - user_IDs_UTF8: Set of User IDs to return
    """
    self.send_dynamic_message_get(user_IDs_UTF8)
    return self.recv_dynamic_message_get()

  def send_dynamic_message_get(self, user_IDs_UTF8):
    self._oprot.writeMessageBegin('dynamic_message_get', TMessageType.CALL, self._seqid)
    args = dynamic_message_get_args()
    args.user_IDs_UTF8 = user_IDs_UTF8
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_dynamic_message_get(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = dynamic_message_get_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    if result.sd_card_not_found_xcept is not None:
      raise result.sd_card_not_found_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "dynamic_message_get failed: unknown result");

  def dynamic_message_reset(self, user_IDs_UTF8):
    """
    Reset dynamic message data of users.


    Parameters:
     - user_IDs_UTF8: Set of User IDs whose dynamic message have to be reset
    """
    self.send_dynamic_message_reset(user_IDs_UTF8)
    self.recv_dynamic_message_reset()

  def send_dynamic_message_reset(self, user_IDs_UTF8):
    self._oprot.writeMessageBegin('dynamic_message_reset', TMessageType.CALL, self._seqid)
    args = dynamic_message_reset_args()
    args.user_IDs_UTF8 = user_IDs_UTF8
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_dynamic_message_reset(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = dynamic_message_reset_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    if result.sd_card_not_found_xcept is not None:
      raise result.sd_card_not_found_xcept
    return

  def dynamic_message_get_user_IDs(self):
    """
    Returns the list of all user IDs (UTF8 string) present in terminal database having dynamic message

    """
    self.send_dynamic_message_get_user_IDs()
    return self.recv_dynamic_message_get_user_IDs()

  def send_dynamic_message_get_user_IDs(self):
    self._oprot.writeMessageBegin('dynamic_message_get_user_IDs', TMessageType.CALL, self._seqid)
    args = dynamic_message_get_user_IDs_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_dynamic_message_get_user_IDs(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = dynamic_message_get_user_IDs_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.sd_card_not_found_xcept is not None:
      raise result.sd_card_not_found_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "dynamic_message_get_user_IDs failed: unknown result");

  def external_db_get_id(self):
    """
    Get id from terminal polling buffer for external database verification.

    @return id for external database verification
    """
    self.send_external_db_get_id()
    return self.recv_external_db_get_id()

  def send_external_db_get_id(self):
    self._oprot.writeMessageBegin('external_db_get_id', TMessageType.CALL, self._seqid)
    args = external_db_get_id_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_external_db_get_id(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = external_db_get_id_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "external_db_get_id failed: unknown result");

  def external_db_verify_user(self, user_id_UTF8, user_data):
    """
    Verify external database user data.

    @return Verify_result_code

    Parameters:
     - user_id_UTF8: User ID
     - user_data: User data
    """
    self.send_external_db_verify_user(user_id_UTF8, user_data)
    return self.recv_external_db_verify_user()

  def send_external_db_verify_user(self, user_id_UTF8, user_data):
    self._oprot.writeMessageBegin('external_db_verify_user', TMessageType.CALL, self._seqid)
    args = external_db_verify_user_args()
    args.user_id_UTF8 = user_id_UTF8
    args.user_data = user_data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_external_db_verify_user(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = external_db_verify_user_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "external_db_verify_user failed: unknown result");

  def external_db_clear_id(self):
    """
    clears the id from terminal polling buffer

    @return none
    """
    self.send_external_db_clear_id()
    self.recv_external_db_clear_id()

  def send_external_db_clear_id(self):
    self._oprot.writeMessageBegin('external_db_clear_id', TMessageType.CALL, self._seqid)
    args = external_db_clear_id_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_external_db_clear_id(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = external_db_clear_id_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    return

  def cls_get_info(self, timeout_in_sec):
    """
    Get contactless card information<br>
    Containing the Smartcard CSN as per the configuration, wheather Standard CSN or Reverse CSN

    Parameters:
     - timeout_in_sec: Duration max. of the operation in seconds
    """
    self.send_cls_get_info(timeout_in_sec)
    return self.recv_cls_get_info()

  def send_cls_get_info(self, timeout_in_sec):
    self._oprot.writeMessageBegin('cls_get_info', TMessageType.CALL, self._seqid)
    args = cls_get_info_args()
    args.timeout_in_sec = timeout_in_sec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cls_get_info(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cls_get_info_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.ex1 is not None:
      raise result.ex1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cls_get_info failed: unknown result");

  def cls_read(self, timeout_in_sec, cards):
    """
    Read files from a contactless card.


    @return The list of read files/data

    Parameters:
     - timeout_in_sec: Duration max. of the operation in seconds
     - cards: List of card to support
    """
    self.send_cls_read(timeout_in_sec, cards)
    return self.recv_cls_read()

  def send_cls_read(self, timeout_in_sec, cards):
    self._oprot.writeMessageBegin('cls_read', TMessageType.CALL, self._seqid)
    args = cls_read_args()
    args.timeout_in_sec = timeout_in_sec
    args.cards = cards
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cls_read(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cls_read_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.ex1 is not None:
      raise result.ex1
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cls_read failed: unknown result");

  def cls_write(self, timeout_in_sec, cards):
    """
    Write files on a contactless card.

    Parameters:
     - timeout_in_sec: Duration max. of the operation in seconds
     - cards: List of card to support
    """
    self.send_cls_write(timeout_in_sec, cards)
    self.recv_cls_write()

  def send_cls_write(self, timeout_in_sec, cards):
    self._oprot.writeMessageBegin('cls_write', TMessageType.CALL, self._seqid)
    args = cls_write_args()
    args.timeout_in_sec = timeout_in_sec
    args.cards = cards
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cls_write(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cls_write_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.ex1 is not None:
      raise result.ex1
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def cls_write_user_card(self, timeout_in_sec, card_data):
    """
    Encode an user contactless card


    The card is encoded according to terminal configuration.
    The card will contains fields required for access on Morpho terminals.
    This command supports only pkcompv2 template data write on card.

    Parameters:
     - timeout_in_sec: Duration max. of the operation in seconds
     - card_data
    """
    self.send_cls_write_user_card(timeout_in_sec, card_data)
    self.recv_cls_write_user_card()

  def send_cls_write_user_card(self, timeout_in_sec, card_data):
    self._oprot.writeMessageBegin('cls_write_user_card', TMessageType.CALL, self._seqid)
    args = cls_write_user_card_args()
    args.timeout_in_sec = timeout_in_sec
    args.card_data = card_data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cls_write_user_card(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cls_write_user_card_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.ex1 is not None:
      raise result.ex1
    if result.ex2 is not None:
      raise result.ex2
    return

  def cls_write_admin_card(self, timeout_in_sec, card_type):
    """
    Encode an admin contactless card


    The card is encoded according to terminal configuration.
    The card will contain the new contactless keys to load on other Morpho terminals.

    Parameters:
     - timeout_in_sec: Duration max. of the operation in seconds
     - card_type: Admin card type to encode
    """
    self.send_cls_write_admin_card(timeout_in_sec, card_type)
    self.recv_cls_write_admin_card()

  def send_cls_write_admin_card(self, timeout_in_sec, card_type):
    self._oprot.writeMessageBegin('cls_write_admin_card', TMessageType.CALL, self._seqid)
    args = cls_write_admin_card_args()
    args.timeout_in_sec = timeout_in_sec
    args.card_type = card_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cls_write_admin_card(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cls_write_admin_card_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.ex1 is not None:
      raise result.ex1
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def cls_erase(self, timeout_in_sec, cards):
    """
    Erase a contactless card


    For DESFire cards, according to the cards definition, this command will erase either one or several files,
    either one or several applications or will format the card.<br>
    In case of card formatting, the master PICC key will be set to 3DES legacy default value.


    For MIFARE cards, this command will set every writable sectors to 0xFF.<br>
    Sector keys will be set to NXP default keys (0x00).

    Parameters:
     - timeout_in_sec: Duration max. of the operation in seconds
     - cards: List of card to support
    """
    self.send_cls_erase(timeout_in_sec, cards)
    self.recv_cls_erase()

  def send_cls_erase(self, timeout_in_sec, cards):
    self._oprot.writeMessageBegin('cls_erase', TMessageType.CALL, self._seqid)
    args = cls_erase_args()
    args.timeout_in_sec = timeout_in_sec
    args.cards = cards
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cls_erase(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cls_erase_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.ex1 is not None:
      raise result.ex1
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def key_load(self, crypto_keys):
    """
    Load contactless keys<br/><br/>

    - For MIFARE cards, this command will load CRYPTO1 (MIFARE Classic) and/or AES (MIFARE Plus) keys.<br/>
    - For DESFire cards, this command will load 3DES and/or AES keys.<br/>
    - For iClass cards, this command will load the iClass key.<br/>
    - For RSA, this command will load the RSA key(s).<br/>
    - For l1 cards, this command will load the L1 site key.<br/>

    Parameters:
     - crypto_keys: Crypto key object
    """
    self.send_key_load(crypto_keys)
    self.recv_key_load()

  def send_key_load(self, crypto_keys):
    self._oprot.writeMessageBegin('key_load', TMessageType.CALL, self._seqid)
    args = key_load_args()
    args.crypto_keys = crypto_keys
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_key_load(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = key_load_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.ex1 is not None:
      raise result.ex1
    return

  def key_reset(self, types):
    """
    Restore default contactless keys<br/><br/>

    - For MIFARE cards, this command will restore all MIFARE Classic and/or MIFARE Plus keys to default value.<br/>

    - For DESFire cards, this command will restore all DESFire 3DES and/or DESFire AES keys to default value.<br/>

    - For iClass cards, this command will restore the default iClass key.

    Parameters:
     - types: List of keys to reset to default value
    """
    self.send_key_reset(types)
    self.recv_key_reset()

  def send_key_reset(self, types):
    self._oprot.writeMessageBegin('key_reset', TMessageType.CALL, self._seqid)
    args = key_reset_args()
    args.types = types
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_key_reset(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = key_reset_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.ex1 is not None:
      raise result.ex1
    return

  def terminal_reboot(self):
    """
    When the command returns, terminal is going to reboot
    """
    self.send_terminal_reboot()
    self.recv_terminal_reboot()

  def send_terminal_reboot(self):
    self._oprot.writeMessageBegin('terminal_reboot', TMessageType.CALL, self._seqid)
    args = terminal_reboot_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_terminal_reboot(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = terminal_reboot_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    return

  def terminal_echo(self, buffer):
    """
    Send back a received buffer

    Buffer shall be less than 64 bytes

    @return The received buffer

    Parameters:
     - buffer: Buffer to be repeated
    """
    self.send_terminal_echo(buffer)
    return self.recv_terminal_echo()

  def send_terminal_echo(self, buffer):
    self._oprot.writeMessageBegin('terminal_echo', TMessageType.CALL, self._seqid)
    args = terminal_echo_args()
    args.buffer = buffer
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_terminal_echo(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = terminal_echo_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.out_of_memory_xcept is not None:
      raise result.out_of_memory_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "terminal_echo failed: unknown result");

  def terminal_get_configuration(self, terminal_settings_type):
    """
    That functions is used to retrieve information like:
    <ol>
    <li> Terminal's local date and time </li>
    <li> Terminal's IP configuration </li>
    <li> Terminal's WIFI configuration </li>
    <li> Terminal's GPRS configuration </li>
    <li> Terminal's serial channel configuration </li>
    </ol>

    Parameters:
     - terminal_settings_type: Terminal setting options
    """
    self.send_terminal_get_configuration(terminal_settings_type)
    return self.recv_terminal_get_configuration()

  def send_terminal_get_configuration(self, terminal_settings_type):
    self._oprot.writeMessageBegin('terminal_get_configuration', TMessageType.CALL, self._seqid)
    args = terminal_get_configuration_args()
    args.terminal_settings_type = terminal_settings_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_terminal_get_configuration(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = terminal_get_configuration_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.ethernet_config_xcept is not None:
      raise result.ethernet_config_xcept
    if result.WIFI_mod_xcept is not None:
      raise result.WIFI_mod_xcept
    if result.license_not_xcept is not None:
      raise result.license_not_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "terminal_get_configuration failed: unknown result");

  def terminal_set_configuration(self, terminal_config):
    """
    That functions is used to configure:
    <ol>
      <li> Terminal's local date and time (i.e. not Network Time Protocol) </li>
      <li> Terminal's IP configuration </li>
      <li> Terminal's WIFI configuration </li>
      <li> Terminal's serial channel configuration </li>
    </ol>
    <b>Note:</b>
    <ul>
      <li>While setting the serial channel configuration, a delay of 3 seconds is provided after sending the response
          to the client, so that the configuration is applied only after the response is sent to the client.
    </ul>

    Parameters:
     - terminal_config: Structure that contains configuration to apply. <br>
    It can contain several configurations.
    """
    self.send_terminal_set_configuration(terminal_config)
    self.recv_terminal_set_configuration()

  def send_terminal_set_configuration(self, terminal_config):
    self._oprot.writeMessageBegin('terminal_set_configuration', TMessageType.CALL, self._seqid)
    args = terminal_set_configuration_args()
    args.terminal_config = terminal_config
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_terminal_set_configuration(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = terminal_set_configuration_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_arg_xcept is not None:
      raise result.invalid_arg_xcept
    if result.ethernet_config_xcept is not None:
      raise result.ethernet_config_xcept
    if result.WIFI_mod_xcept is not None:
      raise result.WIFI_mod_xcept
    if result.license_not_xcept is not None:
      raise result.license_not_xcept
    return

  def time_get_predefined_time_zone_list(self):
    """
    Get the list of terminal's predefined time zones


    The terminal contains a list of predefined time zones that can be used
    to configure terminal's date and time (see @a terminal_set_configuration).

    @return  A list of UTF-8 strings that represents predefined time zones handled
             by the terminal
    """
    self.send_time_get_predefined_time_zone_list()
    return self.recv_time_get_predefined_time_zone_list()

  def send_time_get_predefined_time_zone_list(self):
    self._oprot.writeMessageBegin('time_get_predefined_time_zone_list', TMessageType.CALL, self._seqid)
    args = time_get_predefined_time_zone_list_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time_get_predefined_time_zone_list(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = time_get_predefined_time_zone_list_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "time_get_predefined_time_zone_list failed: unknown result");

  def distant_session_set_state(self, state):
    """
    Open or close a distant session


    When a distant session is opened, the terminal only waits for distant commands.
    No local operation can be done.

    Parameters:
     - state: Open or Close the distant session
    """
    self.send_distant_session_set_state(state)
    self.recv_distant_session_set_state()

  def send_distant_session_set_state(self, state):
    self._oprot.writeMessageBegin('distant_session_set_state', TMessageType.CALL, self._seqid)
    args = distant_session_set_state_args()
    args.state = state
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_distant_session_set_state(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = distant_session_set_state_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    return

  def distant_session_get_state(self):
    """
    Get the terminal's distant session state


    When a distant session is opened, the terminal only waits for distant commands.
    No local operation can be done.

    @return The distant session's status (opened or closed)
    """
    self.send_distant_session_get_state()
    return self.recv_distant_session_get_state()

  def send_distant_session_get_state(self):
    self._oprot.writeMessageBegin('distant_session_get_state', TMessageType.CALL, self._seqid)
    args = distant_session_get_state_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_distant_session_get_state(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = distant_session_get_state_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "distant_session_get_state failed: unknown result");

  def cancel_operation(self):
    """
    Cancel current delayed command
    """
    self.send_cancel_operation()
    self.recv_cancel_operation()

  def send_cancel_operation(self):
    self._oprot.writeMessageBegin('cancel_operation', TMessageType.CALL, self._seqid)
    args = cancel_operation_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cancel_operation(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cancel_operation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    return

  def terminal_get_version(self, firmware_type):
    """
    Get firmware versions


    Return firmware version of requested board type (Terminal or Sensor)

    @return Firmware version

    Parameters:
     - firmware_type: Board to retrieve firmware version from
    """
    self.send_terminal_get_version(firmware_type)
    return self.recv_terminal_get_version()

  def send_terminal_get_version(self, firmware_type):
    self._oprot.writeMessageBegin('terminal_get_version', TMessageType.CALL, self._seqid)
    args = terminal_get_version_args()
    args.firmware_type = firmware_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_terminal_get_version(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = terminal_get_version_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "terminal_get_version failed: unknown result");

  def terminal_retrieve_peripherals(self):
    """
    Retrieve the list of terminal internal peripherals.
    """
    self.send_terminal_retrieve_peripherals()
    return self.recv_terminal_retrieve_peripherals()

  def send_terminal_retrieve_peripherals(self):
    self._oprot.writeMessageBegin('terminal_retrieve_peripherals', TMessageType.CALL, self._seqid)
    args = terminal_retrieve_peripherals_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_terminal_retrieve_peripherals(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = terminal_retrieve_peripherals_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "terminal_retrieve_peripherals failed: unknown result");

  def product_get_info(self, info_type):
    """
    Get product information from terminal board and sensor board.

    @return Requested information

    Parameters:
     - info_type: List of requested information
    """
    self.send_product_get_info(info_type)
    return self.recv_product_get_info()

  def send_product_get_info(self, info_type):
    self._oprot.writeMessageBegin('product_get_info', TMessageType.CALL, self._seqid)
    args = product_get_info_args()
    args.info_type = info_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_product_get_info(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = product_get_info_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "product_get_info failed: unknown result");

  def get_terminal_capabilities(self, capability_list):
    """
    Gets the specified capabilities of the terminal.

    Parameters:
     - capability_list: List of the capabilities required
    """
    self.send_get_terminal_capabilities(capability_list)
    return self.recv_get_terminal_capabilities()

  def send_get_terminal_capabilities(self, capability_list):
    self._oprot.writeMessageBegin('get_terminal_capabilities', TMessageType.CALL, self._seqid)
    args = get_terminal_capabilities_args()
    args.capability_list = capability_list
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_terminal_capabilities(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_terminal_capabilities_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_terminal_capabilities failed: unknown result");

  def wiegand_clock_data_send_string(self, data_to_send):
    """
    send wiegand or clock&data string

    Parameters:
     - data_to_send: binary wiegand or clock & data data to send
    """
    self.send_wiegand_clock_data_send_string(data_to_send)
    self.recv_wiegand_clock_data_send_string()

  def send_wiegand_clock_data_send_string(self, data_to_send):
    self._oprot.writeMessageBegin('wiegand_clock_data_send_string', TMessageType.CALL, self._seqid)
    args = wiegand_clock_data_send_string_args()
    args.data_to_send = data_to_send
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_wiegand_clock_data_send_string(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = wiegand_clock_data_send_string_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_wiegand_string_exception is not None:
      raise result.invalid_wiegand_string_exception
    if result.wiegand_out_disable_exception is not None:
      raise result.wiegand_out_disable_exception
    return

  def picture_capture(self, input_interface, format):
    """
    Capture a picture in specified format


    The terminal will capture a picture from camera or will perform a screenshot,
    and will return the picture in specified format.

    @return The raw data of the captured picture

    Parameters:
     - input_interface: Interface that will capture the picture (Cameras or screen)
     - format: Format of the picture to retrieve (JPEG, BMP ...)
    """
    self.send_picture_capture(input_interface, format)
    return self.recv_picture_capture()

  def send_picture_capture(self, input_interface, format):
    self._oprot.writeMessageBegin('picture_capture', TMessageType.CALL, self._seqid)
    args = picture_capture_args()
    args.input_interface = input_interface
    args.format = format
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_picture_capture(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = picture_capture_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "picture_capture failed: unknown result");

  def picture_display(self, format, picture_data, coordinates, duration_in_sec):
    """
    Display a picture in specified format


    The terminal will display a picture on the screen.<br>
    The picture will start at the specified coordinates and will be displayed
    during the specified duration

    Parameters:
     - format: Format of the picture to display (JPEG, BMP ...)
     - picture_data: Raw data of the picture file
     - coordinates: Screen coordinates of the right-upper corner of the picture
     - duration_in_sec: Duration in seconds during which the picture is displayed
    """
    self.send_picture_display(format, picture_data, coordinates, duration_in_sec)
    self.recv_picture_display()

  def send_picture_display(self, format, picture_data, coordinates, duration_in_sec):
    self._oprot.writeMessageBegin('picture_display', TMessageType.CALL, self._seqid)
    args = picture_display_args()
    args.format = format
    args.picture_data = picture_data
    args.coordinates = coordinates
    args.duration_in_sec = duration_in_sec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_picture_display(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = picture_display_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    return

  def display_text(self, message_text, coordinates, duration_in_sec):
    """
    Display a text message


    The terminal will display a text message on the screen.<br>
    The text message will start at the specified coordinates and will be displayed
    during the specified duration.<br>
    Min-Max range for duration is (0-255 seconds) where 0 = infinite time.<br>
    Min-Max range for X- co-ordinate is (0-720).<br>
    Min-Max range for Y- co-ordinate is (0-450)

    Parameters:
     - message_text: String message text to be display on terminal screen
     - coordinates: Screen coordinates of the right-upper corner of the message text
     - duration_in_sec: Duration in seconds during which the text message is displayed
    """
    self.send_display_text(message_text, coordinates, duration_in_sec)
    self.recv_display_text()

  def send_display_text(self, message_text, coordinates, duration_in_sec):
    self._oprot.writeMessageBegin('display_text', TMessageType.CALL, self._seqid)
    args = display_text_args()
    args.message_text = message_text
    args.coordinates = coordinates
    args.duration_in_sec = duration_in_sec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_display_text(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = display_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    return

  def file_load(self, file_details, chunk):
    """
    Load a file into the terminal.<br>
    <b>Note:</b>
    <ol>
      <li>The <code>File_types.File_chunk.action</code> shall be taken into consideration only for the last chunk,
        i.e., when <code>File_types.File_chunk.is_last</code> is true.
      <li>Maxixum file sizes:
        <ul>
          <li><code>File_types.File_type.video</code>:    10 MB
          <li><code>File_types.File_type.audio</code>:   500 KB
          <li><code>File_types.File_type.picture</code>:   1 MB
          <li>Others:                                      5 MB
        </ul>
      <li>Maximum chunk size is 10240 bytes, i.e. 10 KB
      <li>Make sure video file is in proper format. (MPEG4 or VP8)
      <li>While updating stolen card entries, all previous entries will be deleted
    </ol><br>
    <b>Warning:</b><br>
    <ol>
      <li>You shall need a modified version of the generated code that supports
          handling of several request/response messages for the single call to the command.
      <li>For file type <code>File_types.File_type.stolen_card_list</code>, No error will be return.
          And maximum 250000 valid stolen card entried will be stored and rest of the entries will be ignored.
    </ol><br>
    <b>Functionality change required in Thrift generated client code (C++ sample)</b><br>
    <pre>
    void Generic_commandsClient::file_load(const  ::Distant_cmd::File_details& file_details, const  ::Distant_cmd::File_chunk& chunk)
    {
        <span style="color:green">// Original code section in the generated code
        // send_file_load(file_details, chunk);
        // recv_file_load();</span>
    &nbsp;
        <span style="color:green">// BEGIN: Custom section for receiving and processing intermediate data
        // This is actually multi-request handling</span>
        ::Distant_cmd::File_chunk actual_chunk; <span style="color:green">// a non-const chunk required</span>
        while(true)
        {
            <span style="color:green">// Client's call-back is supposed to load the data that shall be available in the 'actual_chunk' parameter to send to the Thrift server.
            //  Note that in case of the last chunk of data to be uploaded the 'actual_chunk.is_last' flag must be set.</span>
            Multiresponse_handler::client_cb_file_load(actual_chunk);
            send_file_load(file_details, actual_chunk);
    &nbsp;
            recv_file_load(); <span style="color:green">// required to see if exception was received -- so that further sending is stopped</span>
    &nbsp;
            if(actual_chunk.is_last) <span style="color:green">// Exit the loop since the last chunk has been sent and its corresponding response received</span>
            {
                break;
            }
        }
        <span style="color:green">// END: Custom section for receiving and processing intermediate data</span>
    }
    </pre>

    Parameters:
     - file_details: In cases where file name is required, the file shall be uploaded with the same name as the file name provided
     - chunk: The chunk of the file
    """
    self.send_file_load(file_details, chunk)
    self.recv_file_load()

  def send_file_load(self, file_details, chunk):
    self._oprot.writeMessageBegin('file_load', TMessageType.CALL, self._seqid)
    args = file_load_args()
    args.file_details = file_details
    args.chunk = chunk
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_file_load(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = file_load_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.file_inexistent_xcept is not None:
      raise result.file_inexistent_xcept
    if result.file_large_xcept is not None:
      raise result.file_large_xcept
    if result.file_name_missing_xcept is not None:
      raise result.file_name_missing_xcept
    if result.invalid_file_ext_xcept is not None:
      raise result.invalid_file_ext_xcept
    if result.SD_card_not_found_xcept is not None:
      raise result.SD_card_not_found_xcept
    return

  def file_get(self, file_details):
    """
    Retrieve a file from the terminal.<br>
    <b>Functionality change required in Thrift generated client code (C++ sample)</b><br>
    <pre>
     void Generic_commandsClient::file_get( ::Distant_cmd::File_chunk& _return, const  ::Distant_cmd::File_details& file_details)
     {
         send_file_get(file_details);
         <span style="color:green">// recv_file_get(_return); // Original line in the generated code</span>
    &nbsp;
         <span style="color:green">// BEGIN: Custom section for receiving and processing intermediate data</span>
         while (true)
         {
             recv_file_get(_return); <span style="color:green">// Multiple reception in loop</span>
    &nbsp;
             <span style="color:green">// Following is the client's callaback assumed to take necessary action on the received data,
             //  e.g., keep writing the received partial data to the file until the last chunk of data is received.</span>
             Multiresponse_handler::client_cb_file_get(_return);
    &nbsp;
             if(_return.is_last) <span style="color:green">// Exit the loop if the data received was last of all the multiple data received, i.e., no more data to be received</span>
             {
                 break;
             }
         }
         <span style="color:green">// END: Custom section for receiving and processing intermediate data</span>
     }
    </pre>

    Parameters:
     - file_details: File details of the file to obtain
    (<code>File_types.File_details.name_UTF8</code> shall be ignored except where multiple files exist)
    """
    self.send_file_get(file_details)
    return self.recv_file_get()

  def send_file_get(self, file_details):
    self._oprot.writeMessageBegin('file_get', TMessageType.CALL, self._seqid)
    args = file_get_args()
    args.file_details = file_details
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_file_get(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = file_get_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.file_inexistent_xcept is not None:
      raise result.file_inexistent_xcept
    if result.SD_card_not_found_xcept is not None:
      raise result.SD_card_not_found_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "file_get failed: unknown result");

  def file_get_filenames(self, file_type):
    """
    Retrieve all the files name for a given file type

    <h5>Returns</h5> List of structure for files' details

    Parameters:
     - file_type
    """
    self.send_file_get_filenames(file_type)
    return self.recv_file_get_filenames()

  def send_file_get_filenames(self, file_type):
    self._oprot.writeMessageBegin('file_get_filenames', TMessageType.CALL, self._seqid)
    args = file_get_filenames_args()
    args.file_type = file_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_file_get_filenames(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = file_get_filenames_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.file_inexistent_xcept is not None:
      raise result.file_inexistent_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "file_get_filenames failed: unknown result");

  def file_erase(self, file_details):
    """
    Erase a file represented by name and type

    Parameters:
     - file_details
    """
    self.send_file_erase(file_details)
    self.recv_file_erase()

  def send_file_erase(self, file_details):
    self._oprot.writeMessageBegin('file_erase', TMessageType.CALL, self._seqid)
    args = file_erase_args()
    args.file_details = file_details
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_file_erase(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = file_erase_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.file_inexistent_xcept is not None:
      raise result.file_inexistent_xcept
    if result.SD_card_not_found_xcept is not None:
      raise result.SD_card_not_found_xcept
    return

  def get_sdac_status(self):
    """
    Returns a structure containing 4 integers. The values in list are as follows :
    <ul>
    <li> SDAC mode : 0=Off, 1=On </li>
    <li> Relay state : 0=Door locked, 1=Door unlocked </li>
    <li> Door status : 0=Closed, 1=Open, -1=Error </li>
    <li> Request to exit state : 0=Off, 1=On, -1=Error </li>
    </ul>
    """
    self.send_get_sdac_status()
    return self.recv_get_sdac_status()

  def send_get_sdac_status(self):
    self._oprot.writeMessageBegin('get_sdac_status', TMessageType.CALL, self._seqid)
    args = get_sdac_status_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_sdac_status(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_sdac_status_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_sdac_status failed: unknown result");

  def trigger_relay(self, duration_in_sec):
    """
    Trigger the relay for a given duration. A duration less or equal to 0 is forbidden.

    Parameters:
     - duration_in_sec: duration in second for relay activation
    """
    self.send_trigger_relay(duration_in_sec)
    self.recv_trigger_relay()

  def send_trigger_relay(self, duration_in_sec):
    self._oprot.writeMessageBegin('trigger_relay', TMessageType.CALL, self._seqid)
    args = trigger_relay_args()
    args.duration_in_sec = duration_in_sec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_trigger_relay(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = trigger_relay_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    return

  def authorized_IP_get_list(self, ip_protocol_type):
    """
    Returns a list of string of authorized IPs

    Parameters:
     - ip_protocol_type: IP protocol type i.e. v4, v6 or all
    """
    self.send_authorized_IP_get_list(ip_protocol_type)
    return self.recv_authorized_IP_get_list()

  def send_authorized_IP_get_list(self, ip_protocol_type):
    self._oprot.writeMessageBegin('authorized_IP_get_list', TMessageType.CALL, self._seqid)
    args = authorized_IP_get_list_args()
    args.ip_protocol_type = ip_protocol_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authorized_IP_get_list(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authorized_IP_get_list_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authorized_IP_get_list failed: unknown result");

  def authorized_IP_add(self, str_ip):
    """
    Adds an authorized IP

    Parameters:
     - str_ip: UTF8 string containing authorized IP
    """
    self.send_authorized_IP_add(str_ip)
    self.recv_authorized_IP_add()

  def send_authorized_IP_add(self, str_ip):
    self._oprot.writeMessageBegin('authorized_IP_add', TMessageType.CALL, self._seqid)
    args = authorized_IP_add_args()
    args.str_ip = str_ip
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authorized_IP_add(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authorized_IP_add_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.DB_full_xcept is not None:
      raise result.DB_full_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    return

  def authorized_IP_delete(self, str_ip):
    """
    Remove an authorized IP

    Parameters:
     - str_ip: UTF8 string containing authorized IP to be deleted
    """
    self.send_authorized_IP_delete(str_ip)
    self.recv_authorized_IP_delete()

  def send_authorized_IP_delete(self, str_ip):
    self._oprot.writeMessageBegin('authorized_IP_delete', TMessageType.CALL, self._seqid)
    args = authorized_IP_delete_args()
    args.str_ip = str_ip
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authorized_IP_delete(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authorized_IP_delete_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    return

  def authorized_IP_get_range_list(self, ip_protocol_type):
    """
    Returns a list of string of authorized IP ranges

    Parameters:
     - ip_protocol_type: IP protocol type i.e. v4, v6 or all
    """
    self.send_authorized_IP_get_range_list(ip_protocol_type)
    return self.recv_authorized_IP_get_range_list()

  def send_authorized_IP_get_range_list(self, ip_protocol_type):
    self._oprot.writeMessageBegin('authorized_IP_get_range_list', TMessageType.CALL, self._seqid)
    args = authorized_IP_get_range_list_args()
    args.ip_protocol_type = ip_protocol_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authorized_IP_get_range_list(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authorized_IP_get_range_list_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authorized_IP_get_range_list failed: unknown result");

  def authorized_IP_add_range(self, str_start_ip, str_end_ip):
    """
    Adds an authorized IP range

    Parameters:
     - str_start_ip: UTF8 string containing authorized IP range start address
     - str_end_ip: UTF8 string containing authorized IP range end address
    """
    self.send_authorized_IP_add_range(str_start_ip, str_end_ip)
    self.recv_authorized_IP_add_range()

  def send_authorized_IP_add_range(self, str_start_ip, str_end_ip):
    self._oprot.writeMessageBegin('authorized_IP_add_range', TMessageType.CALL, self._seqid)
    args = authorized_IP_add_range_args()
    args.str_start_ip = str_start_ip
    args.str_end_ip = str_end_ip
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authorized_IP_add_range(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authorized_IP_add_range_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.DB_full_xcept is not None:
      raise result.DB_full_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    return

  def authorized_IP_delete_range(self, str_start_ip, str_end_ip):
    """
    Remove an authorized IP range

    Parameters:
     - str_start_ip: UTF8 string containing an authorized IP range start address to be deleted
     - str_end_ip: UTF8 string containing an authorized IP range end address to be deleted
    """
    self.send_authorized_IP_delete_range(str_start_ip, str_end_ip)
    self.recv_authorized_IP_delete_range()

  def send_authorized_IP_delete_range(self, str_start_ip, str_end_ip):
    self._oprot.writeMessageBegin('authorized_IP_delete_range', TMessageType.CALL, self._seqid)
    args = authorized_IP_delete_range_args()
    args.str_start_ip = str_start_ip
    args.str_end_ip = str_end_ip
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authorized_IP_delete_range(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authorized_IP_delete_range_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    return

  def password_set(self, id, password_old, password_new):
    """
    To set a password

    @return True, if set successfully.


    Parameters:
     - id: password ID<br>
    Must be 0 (terminal password)
     - password_old: old password
     - password_new: new password
    """
    self.send_password_set(id, password_old, password_new)
    return self.recv_password_set()

  def send_password_set(self, id, password_old, password_new):
    self._oprot.writeMessageBegin('password_set', TMessageType.CALL, self._seqid)
    args = password_set_args()
    args.id = id
    args.password_old = password_old
    args.password_new = password_new
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_password_set(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = password_set_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.default_password_xcept is not None:
      raise result.default_password_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "password_set failed: unknown result");

  def password_verify(self, id, password):
    """
    To verify a given password with stored password

    @return True, if verify successfully.


    Parameters:
     - id: password ID<br>
    Must be 0 (terminal password)
     - password: password to be verified with stored password
    """
    self.send_password_verify(id, password)
    return self.recv_password_verify()

  def send_password_verify(self, id, password):
    self._oprot.writeMessageBegin('password_verify', TMessageType.CALL, self._seqid)
    args = password_verify_args()
    args.id = id
    args.password = password
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_password_verify(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = password_verify_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    if result.default_password_xcept is not None:
      raise result.default_password_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "password_verify failed: unknown result");

  def password_reset(self, id):
    """
    To reset a password

    @return True, if reset successfully.


    Parameters:
     - id: password ID<br>
    Must be 0 (terminal password)
    """
    self.send_password_reset(id)
    return self.recv_password_reset()

  def send_password_reset(self, id):
    self._oprot.writeMessageBegin('password_reset', TMessageType.CALL, self._seqid)
    args = password_reset_args()
    args.id = id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_password_reset(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = password_reset_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "password_reset failed: unknown result");

  def passphrase_set(self, id, passphrase):
    """
    To set a passphrase

    @return True, if set successfully.


    Parameters:
     - id: passphrase ID
     - passphrase: passphrase
    """
    self.send_passphrase_set(id, passphrase)
    return self.recv_passphrase_set()

  def send_passphrase_set(self, id, passphrase):
    self._oprot.writeMessageBegin('passphrase_set', TMessageType.CALL, self._seqid)
    args = passphrase_set_args()
    args.id = id
    args.passphrase = passphrase
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_passphrase_set(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = passphrase_set_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "passphrase_set failed: unknown result");

  def passphrase_reset(self, id):
    """
    To reset a passphrase

    @return True, if reset successfully.


    Parameters:
     - id: passphrase ID
    """
    self.send_passphrase_reset(id)
    return self.recv_passphrase_reset()

  def send_passphrase_reset(self, id):
    self._oprot.writeMessageBegin('passphrase_reset', TMessageType.CALL, self._seqid)
    args = passphrase_reset_args()
    args.id = id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_passphrase_reset(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = passphrase_reset_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "passphrase_reset failed: unknown result");

  def retrieve_keypad_input(self, timeout_in_sec):
    """
    To get user input from LCD GUI

    @return entered input from terminal

    Parameters:
     - timeout_in_sec: timeout in second for getting input
    """
    self.send_retrieve_keypad_input(timeout_in_sec)
    return self.recv_retrieve_keypad_input()

  def send_retrieve_keypad_input(self, timeout_in_sec):
    self._oprot.writeMessageBegin('retrieve_keypad_input', TMessageType.CALL, self._seqid)
    args = retrieve_keypad_input_args()
    args.timeout_in_sec = timeout_in_sec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_retrieve_keypad_input(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = retrieve_keypad_input_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.cancelled_xcept is not None:
      raise result.cancelled_xcept
    if result.timeout_xcept is not None:
      raise result.timeout_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "retrieve_keypad_input failed: unknown result");

  def access_schedule_retrieve(self, schedule_index):
    """
    Command to get the access schedule entries.

    @return list of access_schedule data according to schedule_index.
            List of Access_schedule provides data from sunday to saturday.


    Parameters:
     - schedule_index: access schedule index. Value should be between 1 to 58.
    Schedule 0 is never allowed schedule.
    Schedule 63 is always allowed schedule.
    Schedule 59 to 62 are reserved schedule.
    """
    self.send_access_schedule_retrieve(schedule_index)
    return self.recv_access_schedule_retrieve()

  def send_access_schedule_retrieve(self, schedule_index):
    self._oprot.writeMessageBegin('access_schedule_retrieve', TMessageType.CALL, self._seqid)
    args = access_schedule_retrieve_args()
    args.schedule_index = schedule_index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_access_schedule_retrieve(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = access_schedule_retrieve_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_schedule_index_ex is not None:
      raise result.invalid_schedule_index_ex
    if result.inexistant_param_xcept is not None:
      raise result.inexistant_param_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "access_schedule_retrieve failed: unknown result");

  def access_schedule_store(self, schedule_data):
    """
    Command to set the access schedule entries.

    Parameters:
     - schedule_data: access schedule data. List of Access_schedule takes data from sunday to saturday
    """
    self.send_access_schedule_store(schedule_data)
    self.recv_access_schedule_store()

  def send_access_schedule_store(self, schedule_data):
    self._oprot.writeMessageBegin('access_schedule_store', TMessageType.CALL, self._seqid)
    args = access_schedule_store_args()
    args.schedule_data = schedule_data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_access_schedule_store(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = access_schedule_store_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_schedule_index_ex is not None:
      raise result.invalid_schedule_index_ex
    if result.inexistant_param_xcept is not None:
      raise result.inexistant_param_xcept
    if result.invalid_value_xcept is not None:
      raise result.invalid_value_xcept
    return

  def access_schedule_delete(self, schedule_index):
    """
    Command to reset the access schedule entries.

    Parameters:
     - schedule_index: access schedule index. Value should be between 1 to 58.
    Schedule 0 is never allowed schedule.
    Schedule 63 is always allowed schedule.
    Schedule 59 to 62 are reserved schedule.
    """
    self.send_access_schedule_delete(schedule_index)
    self.recv_access_schedule_delete()

  def send_access_schedule_delete(self, schedule_index):
    self._oprot.writeMessageBegin('access_schedule_delete', TMessageType.CALL, self._seqid)
    args = access_schedule_delete_args()
    args.schedule_index = schedule_index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_access_schedule_delete(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = access_schedule_delete_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_schedule_index_ex is not None:
      raise result.invalid_schedule_index_ex
    if result.inexistant_param_xcept is not None:
      raise result.inexistant_param_xcept
    if result.invalid_value_xcept is not None:
      raise result.invalid_value_xcept
    return

  def door_open_schedule_retrieve(self):
    """
    Command to get the door open schedule entries.

    @return list of Door_open_schedule data
            List of Door_open_schedule provides data from sunday to saturday.

    """
    self.send_door_open_schedule_retrieve()
    return self.recv_door_open_schedule_retrieve()

  def send_door_open_schedule_retrieve(self):
    self._oprot.writeMessageBegin('door_open_schedule_retrieve', TMessageType.CALL, self._seqid)
    args = door_open_schedule_retrieve_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_door_open_schedule_retrieve(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = door_open_schedule_retrieve_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.inexistant_param_xcept is not None:
      raise result.inexistant_param_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "door_open_schedule_retrieve failed: unknown result");

  def door_open_schedule_store(self, schedule_data):
    """
    Command to set the door open schedule entries.

    Parameters:
     - schedule_data: door open schedule data. List of Door_open_schedule takes data from sunday to saturday.
    """
    self.send_door_open_schedule_store(schedule_data)
    self.recv_door_open_schedule_store()

  def send_door_open_schedule_store(self, schedule_data):
    self._oprot.writeMessageBegin('door_open_schedule_store', TMessageType.CALL, self._seqid)
    args = door_open_schedule_store_args()
    args.schedule_data = schedule_data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_door_open_schedule_store(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = door_open_schedule_store_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.inexistant_param_xcept is not None:
      raise result.inexistant_param_xcept
    if result.invalid_value_xcept is not None:
      raise result.invalid_value_xcept
    return

  def door_open_schedule_delete(self):
    """
    Command to reset the door open schedule entries.
    """
    self.send_door_open_schedule_delete()
    self.recv_door_open_schedule_delete()

  def send_door_open_schedule_delete(self):
    self._oprot.writeMessageBegin('door_open_schedule_delete', TMessageType.CALL, self._seqid)
    args = door_open_schedule_delete_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_door_open_schedule_delete(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = door_open_schedule_delete_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.inexistant_param_xcept is not None:
      raise result.inexistant_param_xcept
    if result.invalid_value_xcept is not None:
      raise result.invalid_value_xcept
    return

  def holiday_schedule_retrieve(self, schedule_index):
    """
     * Command to get the Holiday schedule entries.
     *
     * @return list of Holi_schedule data according to schedule_index
    *

    Parameters:
     - schedule_index: holiday schedule index .  Value should be between 0 to 63
    """
    self.send_holiday_schedule_retrieve(schedule_index)
    return self.recv_holiday_schedule_retrieve()

  def send_holiday_schedule_retrieve(self, schedule_index):
    self._oprot.writeMessageBegin('holiday_schedule_retrieve', TMessageType.CALL, self._seqid)
    args = holiday_schedule_retrieve_args()
    args.schedule_index = schedule_index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_holiday_schedule_retrieve(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = holiday_schedule_retrieve_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_schedule_index_ex is not None:
      raise result.invalid_schedule_index_ex
    if result.inexistant_param_xcept is not None:
      raise result.inexistant_param_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "holiday_schedule_retrieve failed: unknown result");

  def holiday_schedule_store(self, schedule_data):
    """
    Command to set the holiday schedule entries.

    Parameters:
     - schedule_data: holiday schedule data
    """
    self.send_holiday_schedule_store(schedule_data)
    self.recv_holiday_schedule_store()

  def send_holiday_schedule_store(self, schedule_data):
    self._oprot.writeMessageBegin('holiday_schedule_store', TMessageType.CALL, self._seqid)
    args = holiday_schedule_store_args()
    args.schedule_data = schedule_data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_holiday_schedule_store(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = holiday_schedule_store_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_schedule_index_ex is not None:
      raise result.invalid_schedule_index_ex
    if result.inexistant_param_xcept is not None:
      raise result.inexistant_param_xcept
    if result.invalid_value_xcept is not None:
      raise result.invalid_value_xcept
    return

  def holiday_schedule_delete(self, schedule_index):
    """
    Command to reset the holiday schedule entries.

    Parameters:
     - schedule_index: holiday schedule index . Value should be between 0 to 63
    """
    self.send_holiday_schedule_delete(schedule_index)
    self.recv_holiday_schedule_delete()

  def send_holiday_schedule_delete(self, schedule_index):
    self._oprot.writeMessageBegin('holiday_schedule_delete', TMessageType.CALL, self._seqid)
    args = holiday_schedule_delete_args()
    args.schedule_index = schedule_index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_holiday_schedule_delete(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = holiday_schedule_delete_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_schedule_index_ex is not None:
      raise result.invalid_schedule_index_ex
    if result.inexistant_param_xcept is not None:
      raise result.inexistant_param_xcept
    if result.invalid_value_xcept is not None:
      raise result.invalid_value_xcept
    return

  def scan_WIFI_networks(self):
    """
    Command to scan WIFI networks
    @return list of WIFI_network_info which contains network informations
    """
    self.send_scan_WIFI_networks()
    return self.recv_scan_WIFI_networks()

  def send_scan_WIFI_networks(self):
    self._oprot.writeMessageBegin('scan_WIFI_networks', TMessageType.CALL, self._seqid)
    args = scan_WIFI_networks_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_scan_WIFI_networks(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = scan_WIFI_networks_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.WIFI_module_connect_xcept is not None:
      raise result.WIFI_module_connect_xcept
    if result.license_not_xcept is not None:
      raise result.license_not_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "scan_WIFI_networks failed: unknown result");

  def events_set_config(self, events):
    """
         Set one or more event configurations.<br />
         Following table shows which configurations are allowed for given event.<br /><br />
    <div style="margin:0 0 0 30px">
    <table border="5" cellpadding="0" cellspacing="0" width="800"><colgroup><col width="185"/><col width="64" span="6"/></colgroup><tbody><tr height="20"><td height="20" width="185"><strong>Event Name</strong></td><td width="64"><strong>Enable</strong></td><td width="64"><strong>Send To Cotroller</strong></td><td width="64"><strong>Trigger TTL0</strong></td><td width="64"><strong>Trigger TTL1</strong></td><td width="64"><strong>Trigger TTL2</strong></td><td width="64"><strong>Clock n Data ID</strong></td></tr>
    <tr height="20"><td height="20"><strong>tlac_duress_finger_detected</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20"><strong>tlac_fake_finger_detected</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="40"><td height="40" width="185"><strong>tlac_user_control_successful</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes
    </td><td> Yes </td><td></td></tr><tr height="20"><td height="20" width="185"><strong>tlac_biometric_mismatch</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20" width="185"><strong>tlac_pin_mismatch</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20" width="185"><strong>tlac_user_id_not_in_db</strong></td><td> Yes </td><td> Yes </td><td> Yes </td>
    <td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20" width="185"><strong>tlac_control_timed_out</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20" width="185"><strong>tlac_rejected_by_schedule</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td> Yes </td></tr><tr height="20"><td height="20" width="185"><strong>tlac_temp_validity_expired</strong></td><td> Yes
    </td><td> Yes </td><td></td><td></td><td></td><td> Yes </td></tr><tr height="20"><td height="20" width="185"><strong>tlac_useruser_not_in_white_list</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20"><strong>tlac_black_listed_card</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20"><strong>tlac_face_not_detected</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td> Yes </td></tr><tr height="20"><td height="20"><strong>tlac_multi_user_intermediate_id</strong></td><td> Yes
    </td><td></td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_transaction_log_full</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_controller_feedback_action</strong></td><td> Yes </td><td></td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_job_code_check_failure</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td> Yes </td></tr><tr height="20"><td height="20"><strong>tlac_door_opened_for_too_long</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr>
    <tr height="20"><td height="20"><strong>tlac_door_forced_open</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_door_closed_after_alarm</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_door_unlocked</strong></td><td> Yes </td><td> Yes
    </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_door_locked_back</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_management_menu_login</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td></td></tr><tr height="20"><td height="20"><strong>tlac_management_menu_logout</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr>
    <tr height="20"><td height="20"><strong>tlac_database_deleted</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_enrollment_completed</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_user_deleted</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_user_modification_completed</strong></td><td> Yes </td><td> Yes
    </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_cls_card_encoded</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_cls_card_reset</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_settings_changed</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_cls_card_security_key_reset</strong></td>
    <td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_security_policy_changed</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_tamper_detected</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td></tr><tr height="20"><td height="20"><strong>tlac_tamper_cleared</strong></td><td> Yes
    </td><td></td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_terminal_boot_completed</strong></td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td> Yes </td><td></td></tr><tr height="20"><td height="20"><strong>tlac_firmware_upgrade</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_add_user</strong></td><td> Yes </td><td> Yes </td><td></td>
    <td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_reboot_initiated</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td></td></tr><tr height="20"><td height="20"><strong>tlac_user_rule_check_failure</strong></td><td> Yes </td><td> Yes </td><td></td><td></td><td></td><td> Yes </td></tr></tbody></table></div>

    Parameters:
     - events: Mapping of Event IDs to their config structure fields
    """
    self.send_events_set_config(events)
    self.recv_events_set_config()

  def send_events_set_config(self, events):
    self._oprot.writeMessageBegin('events_set_config', TMessageType.CALL, self._seqid)
    args = events_set_config_args()
    args.events = events
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_events_set_config(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = events_set_config_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    return

  def events_get_config(self, event_IDs):
    """
    Returns one or more event configuration.


    @return A map of Event IDs and their corresponding records.<br>

    Parameters:
     - event_IDs: List of Event IDs to return
    """
    self.send_events_get_config(event_IDs)
    return self.recv_events_get_config()

  def send_events_get_config(self, event_IDs):
    self._oprot.writeMessageBegin('events_get_config', TMessageType.CALL, self._seqid)
    args = events_get_config_args()
    args.event_IDs = event_IDs
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_events_get_config(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = events_get_config_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "events_get_config failed: unknown result");

  def licenses_add(self, license):
    """
    Add license(s) to terminal

    Parameters:
     - license: License file content
    """
    self.send_licenses_add(license)
    self.recv_licenses_add()

  def send_licenses_add(self, license):
    self._oprot.writeMessageBegin('licenses_add', TMessageType.CALL, self._seqid)
    args = licenses_add_args()
    args.license = license
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_licenses_add(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = licenses_add_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    if result.sd_card_not_found_xcept is not None:
      raise result.sd_card_not_found_xcept
    return

  def licenses_get(self):
    """
    Retrieve the list of the licenses stored in the terminal
    @return A list of the licenses contained in the terminal (empty list if the terminal doesn't contain license)
    """
    self.send_licenses_get()
    return self.recv_licenses_get()

  def send_licenses_get(self):
    self._oprot.writeMessageBegin('licenses_get', TMessageType.CALL, self._seqid)
    args = licenses_get_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_licenses_get(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = licenses_get_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "licenses_get failed: unknown result");

  def config_get_video_phone_params(self):
    """
    Gets the list of video phone profiles.
    """
    self.send_config_get_video_phone_params()
    return self.recv_config_get_video_phone_params()

  def send_config_get_video_phone_params(self):
    self._oprot.writeMessageBegin('config_get_video_phone_params', TMessageType.CALL, self._seqid)
    args = config_get_video_phone_params_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_config_get_video_phone_params(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = config_get_video_phone_params_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "config_get_video_phone_params failed: unknown result");

  def config_set_video_phone_params(self, params_video_phone):
    """
    Sets the list of video phone profiles<BR>
    <B>Note:</B>
    <ol>
     <li>A maximum of 20 profiles shall be stored.
     <li>If the number of profiles stored is less than 20, say 15, a fresh copy of the profiles,
             the 15 which are provided, and the remaining 5 blank profiles shall be stored.<br>
             For any GUI application, the blank profiles are like empty slots, which may not be required to be displayed.
     <li>To erase all profiles, the parameter <code>params_video_phone</code> with <i>zero</i> size must be passed.
     <li>To edit one or more profiles, and set them, the remaining profiles shall be preserved only if the latter profiles
             are again provided to set as is.<br>
             For instance, if you want to edit profiles #2 and #3, get all the profiles
             (via <code>config_get_video_phone_params</code>), edit the profiles of interest (profile #2 and #3),
             and using this API, set all the 20 profiles back. This way, the profiles other than profiles #2 and #3
             are preserved and not deleted. In case you pass <i>only</i> profiles #2 and #3 to this API, the rest of the profiles
             shall be stored as blank profiles, i.e., effectively deleting them.
     <li>Any profile entry with all of its parameters empty, i.e., empty strings and <code>0</code> for
             <code>Video_phone_params.port</code>, shall be considered as a blank profile (empty slot).
     <li>Any profile entry with not all of its parameters empty shall throw appropriate exception.
    </ol>

    Parameters:
     - params_video_phone: The list of video phone parameters. The list size to be maximum 20.
    """
    self.send_config_set_video_phone_params(params_video_phone)
    self.recv_config_set_video_phone_params()

  def send_config_set_video_phone_params(self, params_video_phone):
    self._oprot.writeMessageBegin('config_set_video_phone_params', TMessageType.CALL, self._seqid)
    args = config_set_video_phone_params_args()
    args.params_video_phone = params_video_phone
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_config_set_video_phone_params(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = config_set_video_phone_params_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.xcept_invalid_IP is not None:
      raise result.xcept_invalid_IP
    if result.xcept_invalid_size is not None:
      raise result.xcept_invalid_size
    if result.xcept_invalid_value is not None:
      raise result.xcept_invalid_value
    return

  def send_to_host(self, host_config, data):
    """
    That functions is used to send data on host:
    <ol>
    <li> Send data to host on IP network </li>
    <li> Send data to host on serial channel </li>
    </ol>

    Parameters:
     - host_config: Structure that contains configuration of host channel. <br>
    It can contain several configurations.
     - data: data to send on host channel
    """
    self.send_send_to_host(host_config, data)
    self.recv_send_to_host()

  def send_send_to_host(self, host_config, data):
    self._oprot.writeMessageBegin('send_to_host', TMessageType.CALL, self._seqid)
    args = send_to_host_args()
    args.host_config = host_config
    args.data = data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_send_to_host(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = send_to_host_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.generic_xcept is not None:
      raise result.generic_xcept
    if result.invalid_argument_xcept is not None:
      raise result.invalid_argument_xcept
    if result.host_not_found_xcept is not None:
      raise result.host_not_found_xcept
    return

  def retrieve_language_file_list(self):
    """
    Retrieve the list of language files stored in /rootfs_data/Translation
    @return A list of string of the language files
    """
    self.send_retrieve_language_file_list()
    return self.recv_retrieve_language_file_list()

  def send_retrieve_language_file_list(self):
    self._oprot.writeMessageBegin('retrieve_language_file_list', TMessageType.CALL, self._seqid)
    args = retrieve_language_file_list_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_retrieve_language_file_list(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = retrieve_language_file_list_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.generic_xcept is not None:
      raise result.generic_xcept
    raise TApplicationException(TApplicationException.MISSING_RESULT, "retrieve_language_file_list failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["job_code_load_lists"] = Processor.process_job_code_load_lists
    self._processMap["job_code_retrieve_lists"] = Processor.process_job_code_retrieve_lists
    self._processMap["job_code_retrieve_list_indices"] = Processor.process_job_code_retrieve_list_indices
    self._processMap["job_code_check_value_against_user"] = Processor.process_job_code_check_value_against_user
    self._processMap["job_code_empty_lists"] = Processor.process_job_code_empty_lists
    self._processMap["job_code_remove_all_lists"] = Processor.process_job_code_remove_all_lists
    self._processMap["transaction_log_get_status"] = Processor.process_transaction_log_get_status
    self._processMap["transaction_log_retrieve"] = Processor.process_transaction_log_retrieve
    self._processMap["transaction_log_delete_all"] = Processor.process_transaction_log_delete_all
    self._processMap["transaction_log_get_fields"] = Processor.process_transaction_log_get_fields
    self._processMap["config_get_all_params_name"] = Processor.process_config_get_all_params_name
    self._processMap["config_get_params"] = Processor.process_config_get_params
    self._processMap["config_set_params"] = Processor.process_config_set_params
    self._processMap["config_get_range"] = Processor.process_config_get_range
    self._processMap["cls_authenticate_user"] = Processor.process_cls_authenticate_user
    self._processMap["biofinger_identify"] = Processor.process_biofinger_identify
    self._processMap["biofinger_authenticate_db"] = Processor.process_biofinger_authenticate_db
    self._processMap["biofinger_authenticate_ref"] = Processor.process_biofinger_authenticate_ref
    self._processMap["biofinger_enroll"] = Processor.process_biofinger_enroll
    self._processMap["PIN_authenticate_db"] = Processor.process_PIN_authenticate_db
    self._processMap["reset_factory_settings"] = Processor.process_reset_factory_settings
    self._processMap["user_DB_get_status"] = Processor.process_user_DB_get_status
    self._processMap["user_DB_get_fields"] = Processor.process_user_DB_get_fields
    self._processMap["user_DB_set_users"] = Processor.process_user_DB_set_users
    self._processMap["user_DB_delete_records"] = Processor.process_user_DB_delete_records
    self._processMap["user_DB_delete_all_records"] = Processor.process_user_DB_delete_all_records
    self._processMap["user_DB_get_users"] = Processor.process_user_DB_get_users
    self._processMap["user_DB_get_user_IDs"] = Processor.process_user_DB_get_user_IDs
    self._processMap["dynamic_message_set"] = Processor.process_dynamic_message_set
    self._processMap["dynamic_message_get"] = Processor.process_dynamic_message_get
    self._processMap["dynamic_message_reset"] = Processor.process_dynamic_message_reset
    self._processMap["dynamic_message_get_user_IDs"] = Processor.process_dynamic_message_get_user_IDs
    self._processMap["external_db_get_id"] = Processor.process_external_db_get_id
    self._processMap["external_db_verify_user"] = Processor.process_external_db_verify_user
    self._processMap["external_db_clear_id"] = Processor.process_external_db_clear_id
    self._processMap["cls_get_info"] = Processor.process_cls_get_info
    self._processMap["cls_read"] = Processor.process_cls_read
    self._processMap["cls_write"] = Processor.process_cls_write
    self._processMap["cls_write_user_card"] = Processor.process_cls_write_user_card
    self._processMap["cls_write_admin_card"] = Processor.process_cls_write_admin_card
    self._processMap["cls_erase"] = Processor.process_cls_erase
    self._processMap["key_load"] = Processor.process_key_load
    self._processMap["key_reset"] = Processor.process_key_reset
    self._processMap["terminal_reboot"] = Processor.process_terminal_reboot
    self._processMap["terminal_echo"] = Processor.process_terminal_echo
    self._processMap["terminal_get_configuration"] = Processor.process_terminal_get_configuration
    self._processMap["terminal_set_configuration"] = Processor.process_terminal_set_configuration
    self._processMap["time_get_predefined_time_zone_list"] = Processor.process_time_get_predefined_time_zone_list
    self._processMap["distant_session_set_state"] = Processor.process_distant_session_set_state
    self._processMap["distant_session_get_state"] = Processor.process_distant_session_get_state
    self._processMap["cancel_operation"] = Processor.process_cancel_operation
    self._processMap["terminal_get_version"] = Processor.process_terminal_get_version
    self._processMap["terminal_retrieve_peripherals"] = Processor.process_terminal_retrieve_peripherals
    self._processMap["product_get_info"] = Processor.process_product_get_info
    self._processMap["get_terminal_capabilities"] = Processor.process_get_terminal_capabilities
    self._processMap["wiegand_clock_data_send_string"] = Processor.process_wiegand_clock_data_send_string
    self._processMap["picture_capture"] = Processor.process_picture_capture
    self._processMap["picture_display"] = Processor.process_picture_display
    self._processMap["display_text"] = Processor.process_display_text
    self._processMap["file_load"] = Processor.process_file_load
    self._processMap["file_get"] = Processor.process_file_get
    self._processMap["file_get_filenames"] = Processor.process_file_get_filenames
    self._processMap["file_erase"] = Processor.process_file_erase
    self._processMap["get_sdac_status"] = Processor.process_get_sdac_status
    self._processMap["trigger_relay"] = Processor.process_trigger_relay
    self._processMap["authorized_IP_get_list"] = Processor.process_authorized_IP_get_list
    self._processMap["authorized_IP_add"] = Processor.process_authorized_IP_add
    self._processMap["authorized_IP_delete"] = Processor.process_authorized_IP_delete
    self._processMap["authorized_IP_get_range_list"] = Processor.process_authorized_IP_get_range_list
    self._processMap["authorized_IP_add_range"] = Processor.process_authorized_IP_add_range
    self._processMap["authorized_IP_delete_range"] = Processor.process_authorized_IP_delete_range
    self._processMap["password_set"] = Processor.process_password_set
    self._processMap["password_verify"] = Processor.process_password_verify
    self._processMap["password_reset"] = Processor.process_password_reset
    self._processMap["passphrase_set"] = Processor.process_passphrase_set
    self._processMap["passphrase_reset"] = Processor.process_passphrase_reset
    self._processMap["retrieve_keypad_input"] = Processor.process_retrieve_keypad_input
    self._processMap["access_schedule_retrieve"] = Processor.process_access_schedule_retrieve
    self._processMap["access_schedule_store"] = Processor.process_access_schedule_store
    self._processMap["access_schedule_delete"] = Processor.process_access_schedule_delete
    self._processMap["door_open_schedule_retrieve"] = Processor.process_door_open_schedule_retrieve
    self._processMap["door_open_schedule_store"] = Processor.process_door_open_schedule_store
    self._processMap["door_open_schedule_delete"] = Processor.process_door_open_schedule_delete
    self._processMap["holiday_schedule_retrieve"] = Processor.process_holiday_schedule_retrieve
    self._processMap["holiday_schedule_store"] = Processor.process_holiday_schedule_store
    self._processMap["holiday_schedule_delete"] = Processor.process_holiday_schedule_delete
    self._processMap["scan_WIFI_networks"] = Processor.process_scan_WIFI_networks
    self._processMap["events_set_config"] = Processor.process_events_set_config
    self._processMap["events_get_config"] = Processor.process_events_get_config
    self._processMap["licenses_add"] = Processor.process_licenses_add
    self._processMap["licenses_get"] = Processor.process_licenses_get
    self._processMap["config_get_video_phone_params"] = Processor.process_config_get_video_phone_params
    self._processMap["config_set_video_phone_params"] = Processor.process_config_set_video_phone_params
    self._processMap["send_to_host"] = Processor.process_send_to_host
    self._processMap["retrieve_language_file_list"] = Processor.process_retrieve_language_file_list

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_job_code_load_lists(self, seqid, iprot, oprot):
    args = job_code_load_lists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = job_code_load_lists_result()
    try:
      self._handler.job_code_load_lists(args.list_values)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Db_types.ttypes.Job_code_list_data_invalid, jc_invalid_list_ex:
      result.jc_invalid_list_ex = jc_invalid_list_ex
    except Db_types.ttypes.Job_code_list_array_full, jc_list_full_ex:
      result.jc_list_full_ex = jc_list_full_ex
    except Db_types.ttypes.Invalid_job_code_array_length, jc_invalid_array_length_ex:
      result.jc_invalid_array_length_ex = jc_invalid_array_length_ex
    oprot.writeMessageBegin("job_code_load_lists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_job_code_retrieve_lists(self, seqid, iprot, oprot):
    args = job_code_retrieve_lists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = job_code_retrieve_lists_result()
    try:
      result.success = self._handler.job_code_retrieve_lists(args.list_numbers)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Db_types.ttypes.Job_code_list_data_invalid, jc_invalid_list_ex:
      result.jc_invalid_list_ex = jc_invalid_list_ex
    oprot.writeMessageBegin("job_code_retrieve_lists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_job_code_retrieve_list_indices(self, seqid, iprot, oprot):
    args = job_code_retrieve_list_indices_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = job_code_retrieve_list_indices_result()
    try:
      result.success = self._handler.job_code_retrieve_list_indices()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("job_code_retrieve_list_indices", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_job_code_check_value_against_user(self, seqid, iprot, oprot):
    args = job_code_check_value_against_user_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = job_code_check_value_against_user_result()
    try:
      self._handler.job_code_check_value_against_user(args.user_id, args.jobcode_value)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Db_types.ttypes.Job_code_validation_failed, jc_validation_failed_ex:
      result.jc_validation_failed_ex = jc_validation_failed_ex
    oprot.writeMessageBegin("job_code_check_value_against_user", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_job_code_empty_lists(self, seqid, iprot, oprot):
    args = job_code_empty_lists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = job_code_empty_lists_result()
    try:
      result.success = self._handler.job_code_empty_lists(args.list_numbers)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("job_code_empty_lists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_job_code_remove_all_lists(self, seqid, iprot, oprot):
    args = job_code_remove_all_lists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = job_code_remove_all_lists_result()
    try:
      self._handler.job_code_remove_all_lists()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("job_code_remove_all_lists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_transaction_log_get_status(self, seqid, iprot, oprot):
    args = transaction_log_get_status_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = transaction_log_get_status_result()
    try:
      result.success = self._handler.transaction_log_get_status(args.filter)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_arg_xcept:
      result.invalid_arg_xcept = invalid_arg_xcept
    oprot.writeMessageBegin("transaction_log_get_status", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_transaction_log_retrieve(self, seqid, iprot, oprot):
    args = transaction_log_retrieve_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = transaction_log_retrieve_result()
    try:
      result.success = self._handler.transaction_log_retrieve(args.filter, args.required_fields)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_arg_xcept:
      result.invalid_arg_xcept = invalid_arg_xcept
    oprot.writeMessageBegin("transaction_log_retrieve", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_transaction_log_delete_all(self, seqid, iprot, oprot):
    args = transaction_log_delete_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = transaction_log_delete_all_result()
    try:
      self._handler.transaction_log_delete_all()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("transaction_log_delete_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_transaction_log_get_fields(self, seqid, iprot, oprot):
    args = transaction_log_get_fields_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = transaction_log_get_fields_result()
    try:
      result.success = self._handler.transaction_log_get_fields()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("transaction_log_get_fields", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_config_get_all_params_name(self, seqid, iprot, oprot):
    args = config_get_all_params_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = config_get_all_params_name_result()
    try:
      result.success = self._handler.config_get_all_params_name()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("config_get_all_params_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_config_get_params(self, seqid, iprot, oprot):
    args = config_get_params_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = config_get_params_result()
    try:
      result.success = self._handler.config_get_params(args.param_list_UTF8)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Config_types.ttypes.Config_inexistent_parameter_error, inexistant_param_xcept:
      result.inexistant_param_xcept = inexistant_param_xcept
    oprot.writeMessageBegin("config_get_params", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_config_set_params(self, seqid, iprot, oprot):
    args = config_set_params_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = config_set_params_result()
    try:
      self._handler.config_set_params(args.param_map)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Config_types.ttypes.Config_inexistent_parameter_error, inexistant_param_xcept:
      result.inexistant_param_xcept = inexistant_param_xcept
    except Config_types.ttypes.Config_invalid_value_error, invalid_value_xcept:
      result.invalid_value_xcept = invalid_value_xcept
    except Generic_types.ttypes.License_not_found, license_not_xcept:
      result.license_not_xcept = license_not_xcept
    except Generic_types.ttypes.SD_card_not_found, sd_card_not_found_xcept:
      result.sd_card_not_found_xcept = sd_card_not_found_xcept
    oprot.writeMessageBegin("config_set_params", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_config_get_range(self, seqid, iprot, oprot):
    args = config_get_range_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = config_get_range_result()
    try:
      result.success = self._handler.config_get_range(args.param_keys)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Config_types.ttypes.Config_inexistent_parameter_error, inexistant_param_xcept:
      result.inexistant_param_xcept = inexistant_param_xcept
    oprot.writeMessageBegin("config_get_range", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cls_authenticate_user(self, seqid, iprot, oprot):
    args = cls_authenticate_user_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cls_authenticate_user_result()
    try:
      result.success = self._handler.cls_authenticate_user(args.timeout_in_sec, args.authent_param)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Timeout_error, timeout_xcept:
      result.timeout_xcept = timeout_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    except Generic_types.ttypes.Cancelled_error, cancelled_xcept:
      result.cancelled_xcept = cancelled_xcept
    except Biofinger_types.ttypes.Misplaced_finger_error, misplaced_finger_xcept:
      result.misplaced_finger_xcept = misplaced_finger_xcept
    oprot.writeMessageBegin("cls_authenticate_user", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_biofinger_identify(self, seqid, iprot, oprot):
    args = biofinger_identify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = biofinger_identify_result()
    try:
      result.success = self._handler.biofinger_identify(args.database_id, args.timeout_in_sec, args.threshold, args.enable_intermediate_replies, args.optional_param)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Db_types.ttypes.DB_empty_error, DB_empty_xcept:
      result.DB_empty_xcept = DB_empty_xcept
    except Generic_types.ttypes.Timeout_error, timeout_xcept:
      result.timeout_xcept = timeout_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    except Generic_types.ttypes.Cancelled_error, cancelled_xcept:
      result.cancelled_xcept = cancelled_xcept
    except Biofinger_types.ttypes.Misplaced_finger_error, misplaced_finger_xcept:
      result.misplaced_finger_xcept = misplaced_finger_xcept
    oprot.writeMessageBegin("biofinger_identify", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_biofinger_authenticate_db(self, seqid, iprot, oprot):
    args = biofinger_authenticate_db_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = biofinger_authenticate_db_result()
    try:
      result.success = self._handler.biofinger_authenticate_db(args.database_id, args.timeout_in_sec, args.threshold, args.user_id_UTF8, args.enable_intermediate_replies, args.optional_param)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Inexistent_user_id_error, inexistant_user_xcept:
      result.inexistant_user_xcept = inexistant_user_xcept
    except Db_types.ttypes.DB_empty_error, DB_empty_xcept:
      result.DB_empty_xcept = DB_empty_xcept
    except Generic_types.ttypes.Timeout_error, timeout_xcept:
      result.timeout_xcept = timeout_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    except Generic_types.ttypes.Cancelled_error, cancelled_xcept:
      result.cancelled_xcept = cancelled_xcept
    except Biofinger_types.ttypes.Misplaced_finger_error, misplaced_finger_xcept:
      result.misplaced_finger_xcept = misplaced_finger_xcept
    oprot.writeMessageBegin("biofinger_authenticate_db", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_biofinger_authenticate_ref(self, seqid, iprot, oprot):
    args = biofinger_authenticate_ref_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = biofinger_authenticate_ref_result()
    try:
      result.success = self._handler.biofinger_authenticate_ref(args.timeout_in_sec, args.threshold, args.ref_template_list, args.enable_intermediate_replies, args.optional_param)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Biofinger_types.ttypes.Unsupported_format_error, unsupported_format_xcept:
      result.unsupported_format_xcept = unsupported_format_xcept
    except Biofinger_types.ttypes.Incompatible_ref_error, incomptible_ref_xcept:
      result.incomptible_ref_xcept = incomptible_ref_xcept
    except Generic_types.ttypes.Timeout_error, timeout_xcept:
      result.timeout_xcept = timeout_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    except Generic_types.ttypes.Cancelled_error, cancelled_xcept:
      result.cancelled_xcept = cancelled_xcept
    except Biofinger_types.ttypes.Misplaced_finger_error, misplaced_finger_xcept:
      result.misplaced_finger_xcept = misplaced_finger_xcept
    oprot.writeMessageBegin("biofinger_authenticate_ref", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_biofinger_enroll(self, seqid, iprot, oprot):
    args = biofinger_enroll_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = biofinger_enroll_result()
    try:
      result.success = self._handler.biofinger_enroll(args.database_id, args.timeout_in_sec, args.enrollment_type, args.nb_of_finger, args.user_id_UTF8, args.user_fields, args.enable_intermediate_replies, args.optional_param)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Biofinger_types.ttypes.Incompatible_ref_error, incompatbile_ref_xcept:
      result.incompatbile_ref_xcept = incompatbile_ref_xcept
    except Generic_types.ttypes.Timeout_error, timeout_xcept:
      result.timeout_xcept = timeout_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    except Generic_types.ttypes.Cancelled_error, cancelled_xcept:
      result.cancelled_xcept = cancelled_xcept
    except Db_types.ttypes.DB_duplicate_record_error, duplicate_record_xcept:
      result.duplicate_record_xcept = duplicate_record_xcept
    except Db_types.ttypes.DB_full_error, DB_full_xcept:
      result.DB_full_xcept = DB_full_xcept
    except Db_types.ttypes.User_DB_unavailable_field, unavailable_field_xcept:
      result.unavailable_field_xcept = unavailable_field_xcept
    except Biofinger_types.ttypes.Duplicated_finger_error, duplicated_finger_xcept:
      result.duplicated_finger_xcept = duplicated_finger_xcept
    oprot.writeMessageBegin("biofinger_enroll", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_PIN_authenticate_db(self, seqid, iprot, oprot):
    args = PIN_authenticate_db_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = PIN_authenticate_db_result()
    try:
      result.success = self._handler.PIN_authenticate_db(args.timeout_in_sec, args.user_id_UTF8)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("PIN_authenticate_db", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_reset_factory_settings(self, seqid, iprot, oprot):
    args = reset_factory_settings_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = reset_factory_settings_result()
    try:
      self._handler.reset_factory_settings(args.list_of_settings)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("reset_factory_settings", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_user_DB_get_status(self, seqid, iprot, oprot):
    args = user_DB_get_status_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = user_DB_get_status_result()
    try:
      result.success = self._handler.user_DB_get_status(args.type)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("user_DB_get_status", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_user_DB_get_fields(self, seqid, iprot, oprot):
    args = user_DB_get_fields_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = user_DB_get_fields_result()
    try:
      result.success = self._handler.user_DB_get_fields()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("user_DB_get_fields", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_user_DB_set_users(self, seqid, iprot, oprot):
    args = user_DB_set_users_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = user_DB_set_users_result()
    try:
      self._handler.user_DB_set_users(args.users, args.enable_similar_finger_check)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Db_types.ttypes.DB_full_error, DB_full_xcept:
      result.DB_full_xcept = DB_full_xcept
    except Db_types.ttypes.User_DB_unavailable_field, unavailable_field_xcept:
      result.unavailable_field_xcept = unavailable_field_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    except Biofinger_types.ttypes.Duplicated_finger_error, duplicate_finger_xcept:
      result.duplicate_finger_xcept = duplicate_finger_xcept
    except Db_types.ttypes.DB_duplicate_record_error, duplicate_user_xcept:
      result.duplicate_user_xcept = duplicate_user_xcept
    oprot.writeMessageBegin("user_DB_set_users", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_user_DB_delete_records(self, seqid, iprot, oprot):
    args = user_DB_delete_records_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = user_DB_delete_records_result()
    try:
      result.success = self._handler.user_DB_delete_records(args.user_IDs_UTF8)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("user_DB_delete_records", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_user_DB_delete_all_records(self, seqid, iprot, oprot):
    args = user_DB_delete_all_records_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = user_DB_delete_all_records_result()
    try:
      self._handler.user_DB_delete_all_records()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("user_DB_delete_all_records", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_user_DB_get_users(self, seqid, iprot, oprot):
    args = user_DB_get_users_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = user_DB_get_users_result()
    try:
      result.success = self._handler.user_DB_get_users(args.user_IDs_UTF8, args.requested_fields)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("user_DB_get_users", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_user_DB_get_user_IDs(self, seqid, iprot, oprot):
    args = user_DB_get_user_IDs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = user_DB_get_user_IDs_result()
    try:
      result.success = self._handler.user_DB_get_user_IDs(args.type)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("user_DB_get_user_IDs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_dynamic_message_set(self, seqid, iprot, oprot):
    args = dynamic_message_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = dynamic_message_set_result()
    try:
      self._handler.dynamic_message_set(args.dm_list)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    except Generic_types.ttypes.SD_card_not_found, sd_card_not_found_xcept:
      result.sd_card_not_found_xcept = sd_card_not_found_xcept
    oprot.writeMessageBegin("dynamic_message_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_dynamic_message_get(self, seqid, iprot, oprot):
    args = dynamic_message_get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = dynamic_message_get_result()
    try:
      result.success = self._handler.dynamic_message_get(args.user_IDs_UTF8)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    except Generic_types.ttypes.SD_card_not_found, sd_card_not_found_xcept:
      result.sd_card_not_found_xcept = sd_card_not_found_xcept
    oprot.writeMessageBegin("dynamic_message_get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_dynamic_message_reset(self, seqid, iprot, oprot):
    args = dynamic_message_reset_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = dynamic_message_reset_result()
    try:
      self._handler.dynamic_message_reset(args.user_IDs_UTF8)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    except Generic_types.ttypes.SD_card_not_found, sd_card_not_found_xcept:
      result.sd_card_not_found_xcept = sd_card_not_found_xcept
    oprot.writeMessageBegin("dynamic_message_reset", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_dynamic_message_get_user_IDs(self, seqid, iprot, oprot):
    args = dynamic_message_get_user_IDs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = dynamic_message_get_user_IDs_result()
    try:
      result.success = self._handler.dynamic_message_get_user_IDs()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.SD_card_not_found, sd_card_not_found_xcept:
      result.sd_card_not_found_xcept = sd_card_not_found_xcept
    oprot.writeMessageBegin("dynamic_message_get_user_IDs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_external_db_get_id(self, seqid, iprot, oprot):
    args = external_db_get_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = external_db_get_id_result()
    try:
      result.success = self._handler.external_db_get_id()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("external_db_get_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_external_db_verify_user(self, seqid, iprot, oprot):
    args = external_db_verify_user_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = external_db_verify_user_result()
    try:
      result.success = self._handler.external_db_verify_user(args.user_id_UTF8, args.user_data)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("external_db_verify_user", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_external_db_clear_id(self, seqid, iprot, oprot):
    args = external_db_clear_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = external_db_clear_id_result()
    try:
      self._handler.external_db_clear_id()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("external_db_clear_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cls_get_info(self, seqid, iprot, oprot):
    args = cls_get_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cls_get_info_result()
    try:
      result.success = self._handler.cls_get_info(args.timeout_in_sec)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Timeout_error, ex1:
      result.ex1 = ex1
    oprot.writeMessageBegin("cls_get_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cls_read(self, seqid, iprot, oprot):
    args = cls_read_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cls_read_result()
    try:
      result.success = self._handler.cls_read(args.timeout_in_sec, args.cards)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Timeout_error, ex1:
      result.ex1 = ex1
    except Generic_types.ttypes.Invalid_argument_error, ex2:
      result.ex2 = ex2
    except Cls_types.ttypes.Cls_invalid_key_error, ex3:
      result.ex3 = ex3
    oprot.writeMessageBegin("cls_read", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cls_write(self, seqid, iprot, oprot):
    args = cls_write_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cls_write_result()
    try:
      self._handler.cls_write(args.timeout_in_sec, args.cards)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Timeout_error, ex1:
      result.ex1 = ex1
    except Generic_types.ttypes.Invalid_argument_error, ex2:
      result.ex2 = ex2
    except Cls_types.ttypes.Cls_invalid_key_error, ex3:
      result.ex3 = ex3
    oprot.writeMessageBegin("cls_write", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cls_write_user_card(self, seqid, iprot, oprot):
    args = cls_write_user_card_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cls_write_user_card_result()
    try:
      self._handler.cls_write_user_card(args.timeout_in_sec, args.card_data)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Timeout_error, ex1:
      result.ex1 = ex1
    except Generic_types.ttypes.Invalid_argument_error, ex2:
      result.ex2 = ex2
    oprot.writeMessageBegin("cls_write_user_card", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cls_write_admin_card(self, seqid, iprot, oprot):
    args = cls_write_admin_card_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cls_write_admin_card_result()
    try:
      self._handler.cls_write_admin_card(args.timeout_in_sec, args.card_type)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Timeout_error, ex1:
      result.ex1 = ex1
    except Generic_types.ttypes.Invalid_argument_error, ex2:
      result.ex2 = ex2
    except Cls_types.ttypes.Cls_invalid_card_type_error, ex3:
      result.ex3 = ex3
    oprot.writeMessageBegin("cls_write_admin_card", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cls_erase(self, seqid, iprot, oprot):
    args = cls_erase_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cls_erase_result()
    try:
      self._handler.cls_erase(args.timeout_in_sec, args.cards)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Timeout_error, ex1:
      result.ex1 = ex1
    except Generic_types.ttypes.Invalid_argument_error, ex2:
      result.ex2 = ex2
    except Cls_types.ttypes.Cls_invalid_key_error, ex3:
      result.ex3 = ex3
    oprot.writeMessageBegin("cls_erase", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_key_load(self, seqid, iprot, oprot):
    args = key_load_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = key_load_result()
    try:
      self._handler.key_load(args.crypto_keys)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Cls_types.ttypes.Cls_invalid_key_error, ex1:
      result.ex1 = ex1
    oprot.writeMessageBegin("key_load", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_key_reset(self, seqid, iprot, oprot):
    args = key_reset_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = key_reset_result()
    try:
      self._handler.key_reset(args.types)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, ex1:
      result.ex1 = ex1
    oprot.writeMessageBegin("key_reset", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_terminal_reboot(self, seqid, iprot, oprot):
    args = terminal_reboot_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = terminal_reboot_result()
    try:
      self._handler.terminal_reboot()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("terminal_reboot", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_terminal_echo(self, seqid, iprot, oprot):
    args = terminal_echo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = terminal_echo_result()
    try:
      result.success = self._handler.terminal_echo(args.buffer)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Out_of_memory_error, out_of_memory_xcept:
      result.out_of_memory_xcept = out_of_memory_xcept
    oprot.writeMessageBegin("terminal_echo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_terminal_get_configuration(self, seqid, iprot, oprot):
    args = terminal_get_configuration_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = terminal_get_configuration_result()
    try:
      result.success = self._handler.terminal_get_configuration(args.terminal_settings_type)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Ethernet_config_not_found, ethernet_config_xcept:
      result.ethernet_config_xcept = ethernet_config_xcept
    except Generic_types.ttypes.WIFI_module_not_connected, WIFI_mod_xcept:
      result.WIFI_mod_xcept = WIFI_mod_xcept
    except Generic_types.ttypes.License_not_found, license_not_xcept:
      result.license_not_xcept = license_not_xcept
    oprot.writeMessageBegin("terminal_get_configuration", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_terminal_set_configuration(self, seqid, iprot, oprot):
    args = terminal_set_configuration_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = terminal_set_configuration_result()
    try:
      self._handler.terminal_set_configuration(args.terminal_config)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_arg_xcept:
      result.invalid_arg_xcept = invalid_arg_xcept
    except Generic_types.ttypes.Ethernet_configuration_failed, ethernet_config_xcept:
      result.ethernet_config_xcept = ethernet_config_xcept
    except Generic_types.ttypes.WIFI_module_not_connected, WIFI_mod_xcept:
      result.WIFI_mod_xcept = WIFI_mod_xcept
    except Generic_types.ttypes.License_not_found, license_not_xcept:
      result.license_not_xcept = license_not_xcept
    oprot.writeMessageBegin("terminal_set_configuration", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time_get_predefined_time_zone_list(self, seqid, iprot, oprot):
    args = time_get_predefined_time_zone_list_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time_get_predefined_time_zone_list_result()
    try:
      result.success = self._handler.time_get_predefined_time_zone_list()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("time_get_predefined_time_zone_list", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_distant_session_set_state(self, seqid, iprot, oprot):
    args = distant_session_set_state_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = distant_session_set_state_result()
    try:
      self._handler.distant_session_set_state(args.state)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("distant_session_set_state", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_distant_session_get_state(self, seqid, iprot, oprot):
    args = distant_session_get_state_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = distant_session_get_state_result()
    try:
      result.success = self._handler.distant_session_get_state()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("distant_session_get_state", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cancel_operation(self, seqid, iprot, oprot):
    args = cancel_operation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cancel_operation_result()
    try:
      self._handler.cancel_operation()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("cancel_operation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_terminal_get_version(self, seqid, iprot, oprot):
    args = terminal_get_version_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = terminal_get_version_result()
    try:
      result.success = self._handler.terminal_get_version(args.firmware_type)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("terminal_get_version", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_terminal_retrieve_peripherals(self, seqid, iprot, oprot):
    args = terminal_retrieve_peripherals_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = terminal_retrieve_peripherals_result()
    try:
      result.success = self._handler.terminal_retrieve_peripherals()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("terminal_retrieve_peripherals", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_product_get_info(self, seqid, iprot, oprot):
    args = product_get_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = product_get_info_result()
    try:
      result.success = self._handler.product_get_info(args.info_type)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("product_get_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_terminal_capabilities(self, seqid, iprot, oprot):
    args = get_terminal_capabilities_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_terminal_capabilities_result()
    try:
      result.success = self._handler.get_terminal_capabilities(args.capability_list)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("get_terminal_capabilities", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_wiegand_clock_data_send_string(self, seqid, iprot, oprot):
    args = wiegand_clock_data_send_string_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = wiegand_clock_data_send_string_result()
    try:
      self._handler.wiegand_clock_data_send_string(args.data_to_send)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_wiegand_string, invalid_wiegand_string_exception:
      result.invalid_wiegand_string_exception = invalid_wiegand_string_exception
    except Generic_types.ttypes.Wiegand_output_disabled, wiegand_out_disable_exception:
      result.wiegand_out_disable_exception = wiegand_out_disable_exception
    oprot.writeMessageBegin("wiegand_clock_data_send_string", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_picture_capture(self, seqid, iprot, oprot):
    args = picture_capture_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = picture_capture_result()
    try:
      result.success = self._handler.picture_capture(args.input_interface, args.format)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("picture_capture", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_picture_display(self, seqid, iprot, oprot):
    args = picture_display_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = picture_display_result()
    try:
      self._handler.picture_display(args.format, args.picture_data, args.coordinates, args.duration_in_sec)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("picture_display", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_display_text(self, seqid, iprot, oprot):
    args = display_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = display_text_result()
    try:
      self._handler.display_text(args.message_text, args.coordinates, args.duration_in_sec)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("display_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_file_load(self, seqid, iprot, oprot):
    args = file_load_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = file_load_result()
    try:
      self._handler.file_load(args.file_details, args.chunk)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.File_inexistent_error, file_inexistent_xcept:
      result.file_inexistent_xcept = file_inexistent_xcept
    except Generic_types.ttypes.File_too_large_error, file_large_xcept:
      result.file_large_xcept = file_large_xcept
    except Generic_types.ttypes.File_name_missing_error, file_name_missing_xcept:
      result.file_name_missing_xcept = file_name_missing_xcept
    except Generic_types.ttypes.Invalid_file_extension_error, invalid_file_ext_xcept:
      result.invalid_file_ext_xcept = invalid_file_ext_xcept
    except Generic_types.ttypes.SD_card_not_found, SD_card_not_found_xcept:
      result.SD_card_not_found_xcept = SD_card_not_found_xcept
    oprot.writeMessageBegin("file_load", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_file_get(self, seqid, iprot, oprot):
    args = file_get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = file_get_result()
    try:
      result.success = self._handler.file_get(args.file_details)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.File_inexistent_error, file_inexistent_xcept:
      result.file_inexistent_xcept = file_inexistent_xcept
    except Generic_types.ttypes.SD_card_not_found, SD_card_not_found_xcept:
      result.SD_card_not_found_xcept = SD_card_not_found_xcept
    oprot.writeMessageBegin("file_get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_file_get_filenames(self, seqid, iprot, oprot):
    args = file_get_filenames_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = file_get_filenames_result()
    try:
      result.success = self._handler.file_get_filenames(args.file_type)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.File_inexistent_error, file_inexistent_xcept:
      result.file_inexistent_xcept = file_inexistent_xcept
    oprot.writeMessageBegin("file_get_filenames", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_file_erase(self, seqid, iprot, oprot):
    args = file_erase_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = file_erase_result()
    try:
      self._handler.file_erase(args.file_details)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.File_inexistent_error, file_inexistent_xcept:
      result.file_inexistent_xcept = file_inexistent_xcept
    except Generic_types.ttypes.SD_card_not_found, SD_card_not_found_xcept:
      result.SD_card_not_found_xcept = SD_card_not_found_xcept
    oprot.writeMessageBegin("file_erase", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_sdac_status(self, seqid, iprot, oprot):
    args = get_sdac_status_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_sdac_status_result()
    try:
      result.success = self._handler.get_sdac_status()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("get_sdac_status", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_trigger_relay(self, seqid, iprot, oprot):
    args = trigger_relay_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = trigger_relay_result()
    try:
      self._handler.trigger_relay(args.duration_in_sec)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("trigger_relay", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authorized_IP_get_list(self, seqid, iprot, oprot):
    args = authorized_IP_get_list_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authorized_IP_get_list_result()
    try:
      result.success = self._handler.authorized_IP_get_list(args.ip_protocol_type)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("authorized_IP_get_list", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authorized_IP_add(self, seqid, iprot, oprot):
    args = authorized_IP_add_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authorized_IP_add_result()
    try:
      self._handler.authorized_IP_add(args.str_ip)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Db_types.ttypes.DB_full_error, DB_full_xcept:
      result.DB_full_xcept = DB_full_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("authorized_IP_add", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authorized_IP_delete(self, seqid, iprot, oprot):
    args = authorized_IP_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authorized_IP_delete_result()
    try:
      self._handler.authorized_IP_delete(args.str_ip)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("authorized_IP_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authorized_IP_get_range_list(self, seqid, iprot, oprot):
    args = authorized_IP_get_range_list_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authorized_IP_get_range_list_result()
    try:
      result.success = self._handler.authorized_IP_get_range_list(args.ip_protocol_type)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("authorized_IP_get_range_list", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authorized_IP_add_range(self, seqid, iprot, oprot):
    args = authorized_IP_add_range_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authorized_IP_add_range_result()
    try:
      self._handler.authorized_IP_add_range(args.str_start_ip, args.str_end_ip)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Db_types.ttypes.DB_full_error, DB_full_xcept:
      result.DB_full_xcept = DB_full_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("authorized_IP_add_range", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authorized_IP_delete_range(self, seqid, iprot, oprot):
    args = authorized_IP_delete_range_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authorized_IP_delete_range_result()
    try:
      self._handler.authorized_IP_delete_range(args.str_start_ip, args.str_end_ip)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("authorized_IP_delete_range", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_password_set(self, seqid, iprot, oprot):
    args = password_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = password_set_result()
    try:
      result.success = self._handler.password_set(args.id, args.password_old, args.password_new)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Security_default_password, default_password_xcept:
      result.default_password_xcept = default_password_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("password_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_password_verify(self, seqid, iprot, oprot):
    args = password_verify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = password_verify_result()
    try:
      result.success = self._handler.password_verify(args.id, args.password)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    except Generic_types.ttypes.Security_default_password, default_password_xcept:
      result.default_password_xcept = default_password_xcept
    oprot.writeMessageBegin("password_verify", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_password_reset(self, seqid, iprot, oprot):
    args = password_reset_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = password_reset_result()
    try:
      result.success = self._handler.password_reset(args.id)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("password_reset", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_passphrase_set(self, seqid, iprot, oprot):
    args = passphrase_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = passphrase_set_result()
    try:
      result.success = self._handler.passphrase_set(args.id, args.passphrase)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("passphrase_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_passphrase_reset(self, seqid, iprot, oprot):
    args = passphrase_reset_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = passphrase_reset_result()
    try:
      result.success = self._handler.passphrase_reset(args.id)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("passphrase_reset", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_retrieve_keypad_input(self, seqid, iprot, oprot):
    args = retrieve_keypad_input_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = retrieve_keypad_input_result()
    try:
      result.success = self._handler.retrieve_keypad_input(args.timeout_in_sec)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Cancelled_error, cancelled_xcept:
      result.cancelled_xcept = cancelled_xcept
    except Generic_types.ttypes.Timeout_error, timeout_xcept:
      result.timeout_xcept = timeout_xcept
    oprot.writeMessageBegin("retrieve_keypad_input", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_access_schedule_retrieve(self, seqid, iprot, oprot):
    args = access_schedule_retrieve_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = access_schedule_retrieve_result()
    try:
      result.success = self._handler.access_schedule_retrieve(args.schedule_index)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Db_types.ttypes.Invalid_schedule_index, invalid_schedule_index_ex:
      result.invalid_schedule_index_ex = invalid_schedule_index_ex
    except Config_types.ttypes.Config_inexistent_parameter_error, inexistant_param_xcept:
      result.inexistant_param_xcept = inexistant_param_xcept
    oprot.writeMessageBegin("access_schedule_retrieve", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_access_schedule_store(self, seqid, iprot, oprot):
    args = access_schedule_store_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = access_schedule_store_result()
    try:
      self._handler.access_schedule_store(args.schedule_data)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Db_types.ttypes.Invalid_schedule_index, invalid_schedule_index_ex:
      result.invalid_schedule_index_ex = invalid_schedule_index_ex
    except Config_types.ttypes.Config_inexistent_parameter_error, inexistant_param_xcept:
      result.inexistant_param_xcept = inexistant_param_xcept
    except Config_types.ttypes.Config_invalid_value_error, invalid_value_xcept:
      result.invalid_value_xcept = invalid_value_xcept
    oprot.writeMessageBegin("access_schedule_store", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_access_schedule_delete(self, seqid, iprot, oprot):
    args = access_schedule_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = access_schedule_delete_result()
    try:
      self._handler.access_schedule_delete(args.schedule_index)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Db_types.ttypes.Invalid_schedule_index, invalid_schedule_index_ex:
      result.invalid_schedule_index_ex = invalid_schedule_index_ex
    except Config_types.ttypes.Config_inexistent_parameter_error, inexistant_param_xcept:
      result.inexistant_param_xcept = inexistant_param_xcept
    except Config_types.ttypes.Config_invalid_value_error, invalid_value_xcept:
      result.invalid_value_xcept = invalid_value_xcept
    oprot.writeMessageBegin("access_schedule_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_door_open_schedule_retrieve(self, seqid, iprot, oprot):
    args = door_open_schedule_retrieve_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = door_open_schedule_retrieve_result()
    try:
      result.success = self._handler.door_open_schedule_retrieve()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Config_types.ttypes.Config_inexistent_parameter_error, inexistant_param_xcept:
      result.inexistant_param_xcept = inexistant_param_xcept
    oprot.writeMessageBegin("door_open_schedule_retrieve", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_door_open_schedule_store(self, seqid, iprot, oprot):
    args = door_open_schedule_store_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = door_open_schedule_store_result()
    try:
      self._handler.door_open_schedule_store(args.schedule_data)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Config_types.ttypes.Config_inexistent_parameter_error, inexistant_param_xcept:
      result.inexistant_param_xcept = inexistant_param_xcept
    except Config_types.ttypes.Config_invalid_value_error, invalid_value_xcept:
      result.invalid_value_xcept = invalid_value_xcept
    oprot.writeMessageBegin("door_open_schedule_store", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_door_open_schedule_delete(self, seqid, iprot, oprot):
    args = door_open_schedule_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = door_open_schedule_delete_result()
    try:
      self._handler.door_open_schedule_delete()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Config_types.ttypes.Config_inexistent_parameter_error, inexistant_param_xcept:
      result.inexistant_param_xcept = inexistant_param_xcept
    except Config_types.ttypes.Config_invalid_value_error, invalid_value_xcept:
      result.invalid_value_xcept = invalid_value_xcept
    oprot.writeMessageBegin("door_open_schedule_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_holiday_schedule_retrieve(self, seqid, iprot, oprot):
    args = holiday_schedule_retrieve_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = holiday_schedule_retrieve_result()
    try:
      result.success = self._handler.holiday_schedule_retrieve(args.schedule_index)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Db_types.ttypes.Invalid_schedule_index, invalid_schedule_index_ex:
      result.invalid_schedule_index_ex = invalid_schedule_index_ex
    except Config_types.ttypes.Config_inexistent_parameter_error, inexistant_param_xcept:
      result.inexistant_param_xcept = inexistant_param_xcept
    oprot.writeMessageBegin("holiday_schedule_retrieve", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_holiday_schedule_store(self, seqid, iprot, oprot):
    args = holiday_schedule_store_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = holiday_schedule_store_result()
    try:
      self._handler.holiday_schedule_store(args.schedule_data)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Db_types.ttypes.Invalid_schedule_index, invalid_schedule_index_ex:
      result.invalid_schedule_index_ex = invalid_schedule_index_ex
    except Config_types.ttypes.Config_inexistent_parameter_error, inexistant_param_xcept:
      result.inexistant_param_xcept = inexistant_param_xcept
    except Config_types.ttypes.Config_invalid_value_error, invalid_value_xcept:
      result.invalid_value_xcept = invalid_value_xcept
    oprot.writeMessageBegin("holiday_schedule_store", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_holiday_schedule_delete(self, seqid, iprot, oprot):
    args = holiday_schedule_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = holiday_schedule_delete_result()
    try:
      self._handler.holiday_schedule_delete(args.schedule_index)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Db_types.ttypes.Invalid_schedule_index, invalid_schedule_index_ex:
      result.invalid_schedule_index_ex = invalid_schedule_index_ex
    except Config_types.ttypes.Config_inexistent_parameter_error, inexistant_param_xcept:
      result.inexistant_param_xcept = inexistant_param_xcept
    except Config_types.ttypes.Config_invalid_value_error, invalid_value_xcept:
      result.invalid_value_xcept = invalid_value_xcept
    oprot.writeMessageBegin("holiday_schedule_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_scan_WIFI_networks(self, seqid, iprot, oprot):
    args = scan_WIFI_networks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = scan_WIFI_networks_result()
    try:
      result.success = self._handler.scan_WIFI_networks()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.WIFI_module_not_connected, WIFI_module_connect_xcept:
      result.WIFI_module_connect_xcept = WIFI_module_connect_xcept
    except Generic_types.ttypes.License_not_found, license_not_xcept:
      result.license_not_xcept = license_not_xcept
    oprot.writeMessageBegin("scan_WIFI_networks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_events_set_config(self, seqid, iprot, oprot):
    args = events_set_config_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = events_set_config_result()
    try:
      self._handler.events_set_config(args.events)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("events_set_config", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_events_get_config(self, seqid, iprot, oprot):
    args = events_get_config_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = events_get_config_result()
    try:
      result.success = self._handler.events_get_config(args.event_IDs)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    oprot.writeMessageBegin("events_get_config", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_licenses_add(self, seqid, iprot, oprot):
    args = licenses_add_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = licenses_add_result()
    try:
      self._handler.licenses_add(args.license)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    except Generic_types.ttypes.SD_card_not_found, sd_card_not_found_xcept:
      result.sd_card_not_found_xcept = sd_card_not_found_xcept
    oprot.writeMessageBegin("licenses_add", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_licenses_get(self, seqid, iprot, oprot):
    args = licenses_get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = licenses_get_result()
    try:
      result.success = self._handler.licenses_get()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("licenses_get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_config_get_video_phone_params(self, seqid, iprot, oprot):
    args = config_get_video_phone_params_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = config_get_video_phone_params_result()
    try:
      result.success = self._handler.config_get_video_phone_params()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("config_get_video_phone_params", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_config_set_video_phone_params(self, seqid, iprot, oprot):
    args = config_set_video_phone_params_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = config_set_video_phone_params_result()
    try:
      self._handler.config_set_video_phone_params(args.params_video_phone)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_IP_error, xcept_invalid_IP:
      result.xcept_invalid_IP = xcept_invalid_IP
    except Generic_types.ttypes.Invalid_size_error, xcept_invalid_size:
      result.xcept_invalid_size = xcept_invalid_size
    except Config_types.ttypes.Config_invalid_value_error, xcept_invalid_value:
      result.xcept_invalid_value = xcept_invalid_value
    oprot.writeMessageBegin("config_set_video_phone_params", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_send_to_host(self, seqid, iprot, oprot):
    args = send_to_host_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = send_to_host_result()
    try:
      self._handler.send_to_host(args.host_config, args.data)
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    except Generic_types.ttypes.Invalid_argument_error, invalid_argument_xcept:
      result.invalid_argument_xcept = invalid_argument_xcept
    except Generic_types.ttypes.Host_not_found, host_not_found_xcept:
      result.host_not_found_xcept = host_not_found_xcept
    oprot.writeMessageBegin("send_to_host", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_retrieve_language_file_list(self, seqid, iprot, oprot):
    args = retrieve_language_file_list_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = retrieve_language_file_list_result()
    try:
      result.success = self._handler.retrieve_language_file_list()
    except Generic_types.ttypes.Generic_error, generic_xcept:
      result.generic_xcept = generic_xcept
    oprot.writeMessageBegin("retrieve_language_file_list", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class job_code_load_lists_args:
  """
  Attributes:
   - list_values: List number to be created
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'list_values', (TType.STRUCT,(Db_types.ttypes.Jobcode_list, Db_types.ttypes.Jobcode_list.thrift_spec)), None, ), # 1
  )

  def __init__(self, list_values=None,):
    self.list_values = list_values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.list_values = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = Db_types.ttypes.Jobcode_list()
            _elem5.read(iprot)
            self.list_values.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('job_code_load_lists_args')
    if self.list_values is not None:
      oprot.writeFieldBegin('list_values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.list_values))
      for iter6 in self.list_values:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class job_code_load_lists_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - jc_invalid_list_ex: List data is not valid
   - jc_list_full_ex: List array full, no more list can be added
   - jc_invalid_array_length_ex: Invalid job code array size
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'jc_invalid_list_ex', (Db_types.ttypes.Job_code_list_data_invalid, Db_types.ttypes.Job_code_list_data_invalid.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'jc_list_full_ex', (Db_types.ttypes.Job_code_list_array_full, Db_types.ttypes.Job_code_list_array_full.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'jc_invalid_array_length_ex', (Db_types.ttypes.Invalid_job_code_array_length, Db_types.ttypes.Invalid_job_code_array_length.thrift_spec), None, ), # 4
  )

  def __init__(self, generic_xcept=None, jc_invalid_list_ex=None, jc_list_full_ex=None, jc_invalid_array_length_ex=None,):
    self.generic_xcept = generic_xcept
    self.jc_invalid_list_ex = jc_invalid_list_ex
    self.jc_list_full_ex = jc_list_full_ex
    self.jc_invalid_array_length_ex = jc_invalid_array_length_ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.jc_invalid_list_ex = Db_types.ttypes.Job_code_list_data_invalid()
          self.jc_invalid_list_ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.jc_list_full_ex = Db_types.ttypes.Job_code_list_array_full()
          self.jc_list_full_ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.jc_invalid_array_length_ex = Db_types.ttypes.Invalid_job_code_array_length()
          self.jc_invalid_array_length_ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('job_code_load_lists_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.jc_invalid_list_ex is not None:
      oprot.writeFieldBegin('jc_invalid_list_ex', TType.STRUCT, 2)
      self.jc_invalid_list_ex.write(oprot)
      oprot.writeFieldEnd()
    if self.jc_list_full_ex is not None:
      oprot.writeFieldBegin('jc_list_full_ex', TType.STRUCT, 3)
      self.jc_list_full_ex.write(oprot)
      oprot.writeFieldEnd()
    if self.jc_invalid_array_length_ex is not None:
      oprot.writeFieldBegin('jc_invalid_array_length_ex', TType.STRUCT, 4)
      self.jc_invalid_array_length_ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class job_code_retrieve_lists_args:
  """
  Attributes:
   - list_numbers: List numbers to be retrieved
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'list_numbers', (TType.I16,None), None, ), # 1
  )

  def __init__(self, list_numbers=None,):
    self.list_numbers = list_numbers

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.list_numbers = set()
          (_etype10, _size7) = iprot.readSetBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readI16();
            self.list_numbers.add(_elem12)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('job_code_retrieve_lists_args')
    if self.list_numbers is not None:
      oprot.writeFieldBegin('list_numbers', TType.SET, 1)
      oprot.writeSetBegin(TType.I16, len(self.list_numbers))
      for iter13 in self.list_numbers:
        oprot.writeI16(iter13)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class job_code_retrieve_lists_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - jc_invalid_list_ex: List number is not valid
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Db_types.ttypes.Jobcode_list, Db_types.ttypes.Jobcode_list.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'jc_invalid_list_ex', (Db_types.ttypes.Job_code_list_data_invalid, Db_types.ttypes.Job_code_list_data_invalid.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, jc_invalid_list_ex=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.jc_invalid_list_ex = jc_invalid_list_ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = Db_types.ttypes.Jobcode_list()
            _elem19.read(iprot)
            self.success.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.jc_invalid_list_ex = Db_types.ttypes.Job_code_list_data_invalid()
          self.jc_invalid_list_ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('job_code_retrieve_lists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter20 in self.success:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.jc_invalid_list_ex is not None:
      oprot.writeFieldBegin('jc_invalid_list_ex', TType.STRUCT, 2)
      self.jc_invalid_list_ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class job_code_retrieve_list_indices_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('job_code_retrieve_list_indices_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class job_code_retrieve_list_indices_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Db_types.ttypes.Jobcode_list, Db_types.ttypes.Jobcode_list.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = Db_types.ttypes.Jobcode_list()
            _elem26.read(iprot)
            self.success.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('job_code_retrieve_list_indices_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter27 in self.success:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class job_code_check_value_against_user_args:
  """
  Attributes:
   - user_id: User ID for which job code is to be checked
   - jobcode_value: Job code value to be validated
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user_id', None, None, ), # 1
    (2, TType.I32, 'jobcode_value', None, None, ), # 2
  )

  def __init__(self, user_id=None, jobcode_value=None,):
    self.user_id = user_id
    self.jobcode_value = jobcode_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.jobcode_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('job_code_check_value_against_user_args')
    if self.user_id is not None:
      oprot.writeFieldBegin('user_id', TType.STRING, 1)
      oprot.writeString(self.user_id)
      oprot.writeFieldEnd()
    if self.jobcode_value is not None:
      oprot.writeFieldBegin('jobcode_value', TType.I32, 2)
      oprot.writeI32(self.jobcode_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class job_code_check_value_against_user_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - jc_validation_failed_ex: List number is not valid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'jc_validation_failed_ex', (Db_types.ttypes.Job_code_validation_failed, Db_types.ttypes.Job_code_validation_failed.thrift_spec), None, ), # 2
  )

  def __init__(self, generic_xcept=None, jc_validation_failed_ex=None,):
    self.generic_xcept = generic_xcept
    self.jc_validation_failed_ex = jc_validation_failed_ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.jc_validation_failed_ex = Db_types.ttypes.Job_code_validation_failed()
          self.jc_validation_failed_ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('job_code_check_value_against_user_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.jc_validation_failed_ex is not None:
      oprot.writeFieldBegin('jc_validation_failed_ex', TType.STRUCT, 2)
      self.jc_validation_failed_ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class job_code_empty_lists_args:
  """
  Attributes:
   - list_numbers: List array to be removed
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'list_numbers', (TType.I16,None), None, ), # 1
  )

  def __init__(self, list_numbers=None,):
    self.list_numbers = list_numbers

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.list_numbers = set()
          (_etype31, _size28) = iprot.readSetBegin()
          for _i32 in xrange(_size28):
            _elem33 = iprot.readI16();
            self.list_numbers.add(_elem33)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('job_code_empty_lists_args')
    if self.list_numbers is not None:
      oprot.writeFieldBegin('list_numbers', TType.SET, 1)
      oprot.writeSetBegin(TType.I16, len(self.list_numbers))
      for iter34 in self.list_numbers:
        oprot.writeI16(iter34)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class job_code_empty_lists_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I16,None,TType.BOOL,None), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype36, _vtype37, _size35 ) = iprot.readMapBegin()
          for _i39 in xrange(_size35):
            _key40 = iprot.readI16();
            _val41 = iprot.readBool();
            self.success[_key40] = _val41
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('job_code_empty_lists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I16, TType.BOOL, len(self.success))
      for kiter42,viter43 in self.success.items():
        oprot.writeI16(kiter42)
        oprot.writeBool(viter43)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class job_code_remove_all_lists_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('job_code_remove_all_lists_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class job_code_remove_all_lists_result:
  """
  Attributes:
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, generic_xcept=None,):
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('job_code_remove_all_lists_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class transaction_log_get_status_args:
  """
  Attributes:
   - filter: Filter to be applied for getting transaction log count as per filter.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'filter', (Db_types.ttypes.Transaction_log_filter, Db_types.ttypes.Transaction_log_filter.thrift_spec), None, ), # 1
  )

  def __init__(self, filter=None,):
    self.filter = filter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.filter = Db_types.ttypes.Transaction_log_filter()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('transaction_log_get_status_args')
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 1)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class transaction_log_get_status_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - invalid_arg_xcept: Invalid parameter set
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Db_types.ttypes.Transaction_log_status, Db_types.ttypes.Transaction_log_status.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_arg_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, invalid_arg_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.invalid_arg_xcept = invalid_arg_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Db_types.ttypes.Transaction_log_status()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_arg_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_arg_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('transaction_log_get_status_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_arg_xcept is not None:
      oprot.writeFieldBegin('invalid_arg_xcept', TType.STRUCT, 2)
      self.invalid_arg_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class transaction_log_retrieve_args:
  """
  Attributes:
   - filter: Filter to be applied for retrieving transaction logs.
   - required_fields: List of the transaction log fields to be retrieved
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'filter', (Db_types.ttypes.Transaction_log_filter, Db_types.ttypes.Transaction_log_filter.thrift_spec), None, ), # 1
    (2, TType.SET, 'required_fields', (TType.I32,None), None, ), # 2
  )

  def __init__(self, filter=None, required_fields=None,):
    self.filter = filter
    self.required_fields = required_fields

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.filter = Db_types.ttypes.Transaction_log_filter()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.required_fields = set()
          (_etype47, _size44) = iprot.readSetBegin()
          for _i48 in xrange(_size44):
            _elem49 = iprot.readI32();
            self.required_fields.add(_elem49)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('transaction_log_retrieve_args')
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 1)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    if self.required_fields is not None:
      oprot.writeFieldBegin('required_fields', TType.SET, 2)
      oprot.writeSetBegin(TType.I32, len(self.required_fields))
      for iter50 in self.required_fields:
        oprot.writeI32(iter50)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class transaction_log_retrieve_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - invalid_arg_xcept: Invalid parameter set
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Db_types.ttypes.Transaction_log_DB_record, Db_types.ttypes.Transaction_log_DB_record.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_arg_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, invalid_arg_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.invalid_arg_xcept = invalid_arg_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype54, _size51) = iprot.readListBegin()
          for _i55 in xrange(_size51):
            _elem56 = Db_types.ttypes.Transaction_log_DB_record()
            _elem56.read(iprot)
            self.success.append(_elem56)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_arg_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_arg_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('transaction_log_retrieve_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter57 in self.success:
        iter57.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_arg_xcept is not None:
      oprot.writeFieldBegin('invalid_arg_xcept', TType.STRUCT, 2)
      self.invalid_arg_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class transaction_log_delete_all_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('transaction_log_delete_all_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class transaction_log_delete_all_result:
  """
  Attributes:
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, generic_xcept=None,):
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('transaction_log_delete_all_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class transaction_log_get_fields_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('transaction_log_get_fields_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class transaction_log_get_fields_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype61, _size58) = iprot.readSetBegin()
          for _i62 in xrange(_size58):
            _elem63 = iprot.readI32();
            self.success.add(_elem63)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('transaction_log_get_fields_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I32, len(self.success))
      for iter64 in self.success:
        oprot.writeI32(iter64)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class config_get_all_params_name_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('config_get_all_params_name_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class config_get_all_params_name_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype68, _size65) = iprot.readSetBegin()
          for _i69 in xrange(_size65):
            _elem70 = iprot.readString();
            self.success.add(_elem70)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('config_get_all_params_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter71 in self.success:
        oprot.writeString(iter71)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class config_get_params_args:
  """
  Attributes:
   - param_list_UTF8: List of UTF8 string representing names of requested parameters
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'param_list_UTF8', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, param_list_UTF8=None,):
    self.param_list_UTF8 = param_list_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.param_list_UTF8 = []
          (_etype75, _size72) = iprot.readListBegin()
          for _i76 in xrange(_size72):
            _elem77 = iprot.readString();
            self.param_list_UTF8.append(_elem77)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('config_get_params_args')
    if self.param_list_UTF8 is not None:
      oprot.writeFieldBegin('param_list_UTF8', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.param_list_UTF8))
      for iter78 in self.param_list_UTF8:
        oprot.writeString(iter78)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class config_get_params_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - inexistant_param_xcept: A requested parameter does not exist in terminal
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Generic_types.ttypes.Variant, Generic_types.ttypes.Variant.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'inexistant_param_xcept', (Config_types.ttypes.Config_inexistent_parameter_error, Config_types.ttypes.Config_inexistent_parameter_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, inexistant_param_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.inexistant_param_xcept = inexistant_param_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype82, _size79) = iprot.readListBegin()
          for _i83 in xrange(_size79):
            _elem84 = Generic_types.ttypes.Variant()
            _elem84.read(iprot)
            self.success.append(_elem84)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.inexistant_param_xcept = Config_types.ttypes.Config_inexistent_parameter_error()
          self.inexistant_param_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('config_get_params_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter85 in self.success:
        iter85.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.inexistant_param_xcept is not None:
      oprot.writeFieldBegin('inexistant_param_xcept', TType.STRUCT, 2)
      self.inexistant_param_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class config_set_params_args:
  """
  Attributes:
   - param_map: List of key-value pairs.<br>
  Parameters are represented by a UTF8 string
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'param_map', (TType.STRING,None,TType.STRUCT,(Generic_types.ttypes.Variant, Generic_types.ttypes.Variant.thrift_spec)), None, ), # 1
  )

  def __init__(self, param_map=None,):
    self.param_map = param_map

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.param_map = {}
          (_ktype87, _vtype88, _size86 ) = iprot.readMapBegin()
          for _i90 in xrange(_size86):
            _key91 = iprot.readString();
            _val92 = Generic_types.ttypes.Variant()
            _val92.read(iprot)
            self.param_map[_key91] = _val92
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('config_set_params_args')
    if self.param_map is not None:
      oprot.writeFieldBegin('param_map', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.param_map))
      for kiter93,viter94 in self.param_map.items():
        oprot.writeString(kiter93)
        viter94.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class config_set_params_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - inexistant_param_xcept: A requested parameter does not exist in terminal
   - invalid_value_xcept: A parameter value is rejected by the terminal
   - license_not_xcept: License not found exception
   - sd_card_not_found_xcept: SD card not found
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'inexistant_param_xcept', (Config_types.ttypes.Config_inexistent_parameter_error, Config_types.ttypes.Config_inexistent_parameter_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'invalid_value_xcept', (Config_types.ttypes.Config_invalid_value_error, Config_types.ttypes.Config_invalid_value_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'license_not_xcept', (Generic_types.ttypes.License_not_found, Generic_types.ttypes.License_not_found.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'sd_card_not_found_xcept', (Generic_types.ttypes.SD_card_not_found, Generic_types.ttypes.SD_card_not_found.thrift_spec), None, ), # 5
  )

  def __init__(self, generic_xcept=None, inexistant_param_xcept=None, invalid_value_xcept=None, license_not_xcept=None, sd_card_not_found_xcept=None,):
    self.generic_xcept = generic_xcept
    self.inexistant_param_xcept = inexistant_param_xcept
    self.invalid_value_xcept = invalid_value_xcept
    self.license_not_xcept = license_not_xcept
    self.sd_card_not_found_xcept = sd_card_not_found_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.inexistant_param_xcept = Config_types.ttypes.Config_inexistent_parameter_error()
          self.inexistant_param_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.invalid_value_xcept = Config_types.ttypes.Config_invalid_value_error()
          self.invalid_value_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.license_not_xcept = Generic_types.ttypes.License_not_found()
          self.license_not_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.sd_card_not_found_xcept = Generic_types.ttypes.SD_card_not_found()
          self.sd_card_not_found_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('config_set_params_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.inexistant_param_xcept is not None:
      oprot.writeFieldBegin('inexistant_param_xcept', TType.STRUCT, 2)
      self.inexistant_param_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_value_xcept is not None:
      oprot.writeFieldBegin('invalid_value_xcept', TType.STRUCT, 3)
      self.invalid_value_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.license_not_xcept is not None:
      oprot.writeFieldBegin('license_not_xcept', TType.STRUCT, 4)
      self.license_not_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.sd_card_not_found_xcept is not None:
      oprot.writeFieldBegin('sd_card_not_found_xcept', TType.STRUCT, 5)
      self.sd_card_not_found_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class config_get_range_args:
  """
  Attributes:
   - param_keys: List of key-value pairs.<br>
  Parameters are represented by a UTF8 string
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'param_keys', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, param_keys=None,):
    self.param_keys = param_keys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.param_keys = []
          (_etype98, _size95) = iprot.readListBegin()
          for _i99 in xrange(_size95):
            _elem100 = iprot.readString();
            self.param_keys.append(_elem100)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('config_get_range_args')
    if self.param_keys is not None:
      oprot.writeFieldBegin('param_keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.param_keys))
      for iter101 in self.param_keys:
        oprot.writeString(iter101)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class config_get_range_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - inexistant_param_xcept: A requested parameter does not exist in terminal
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Generic_types.ttypes.Parameter_range, Generic_types.ttypes.Parameter_range.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'inexistant_param_xcept', (Config_types.ttypes.Config_inexistent_parameter_error, Config_types.ttypes.Config_inexistent_parameter_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, inexistant_param_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.inexistant_param_xcept = inexistant_param_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype103, _vtype104, _size102 ) = iprot.readMapBegin()
          for _i106 in xrange(_size102):
            _key107 = iprot.readString();
            _val108 = Generic_types.ttypes.Parameter_range()
            _val108.read(iprot)
            self.success[_key107] = _val108
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.inexistant_param_xcept = Config_types.ttypes.Config_inexistent_parameter_error()
          self.inexistant_param_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('config_get_range_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter109,viter110 in self.success.items():
        oprot.writeString(kiter109)
        viter110.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.inexistant_param_xcept is not None:
      oprot.writeFieldBegin('inexistant_param_xcept', TType.STRUCT, 2)
      self.inexistant_param_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_authenticate_user_args:
  """
  Attributes:
   - timeout_in_sec: Max. duration of Smartcard detection process<br>
  0 implies an infinite process.
   - authent_param: Contactless authentication parameters
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'timeout_in_sec', None, None, ), # 1
    (2, TType.STRUCT, 'authent_param', (Cls_types.ttypes.cls_authent_user_params, Cls_types.ttypes.cls_authent_user_params.thrift_spec), None, ), # 2
  )

  def __init__(self, timeout_in_sec=None, authent_param=None,):
    self.timeout_in_sec = timeout_in_sec
    self.authent_param = authent_param

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.timeout_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authent_param = Cls_types.ttypes.cls_authent_user_params()
          self.authent_param.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_authenticate_user_args')
    if self.timeout_in_sec is not None:
      oprot.writeFieldBegin('timeout_in_sec', TType.I32, 1)
      oprot.writeI32(self.timeout_in_sec)
      oprot.writeFieldEnd()
    if self.authent_param is not None:
      oprot.writeFieldBegin('authent_param', TType.STRUCT, 2)
      self.authent_param.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_authenticate_user_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - timeout_xcept: No finger or card was detected during process
   - invalid_argument_xcept: Invalid parameter
   - cancelled_xcept: Command is cancelled by distant command
   - misplaced_finger_xcept: Finger was misplaced or withdrawn during acquisition
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Cls_types.ttypes.cls_authent_user_reply, Cls_types.ttypes.cls_authent_user_reply.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'timeout_xcept', (Generic_types.ttypes.Timeout_error, Generic_types.ttypes.Timeout_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'cancelled_xcept', (Generic_types.ttypes.Cancelled_error, Generic_types.ttypes.Cancelled_error.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'misplaced_finger_xcept', (Biofinger_types.ttypes.Misplaced_finger_error, Biofinger_types.ttypes.Misplaced_finger_error.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, generic_xcept=None, timeout_xcept=None, invalid_argument_xcept=None, cancelled_xcept=None, misplaced_finger_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.timeout_xcept = timeout_xcept
    self.invalid_argument_xcept = invalid_argument_xcept
    self.cancelled_xcept = cancelled_xcept
    self.misplaced_finger_xcept = misplaced_finger_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Cls_types.ttypes.cls_authent_user_reply()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.timeout_xcept = Generic_types.ttypes.Timeout_error()
          self.timeout_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.cancelled_xcept = Generic_types.ttypes.Cancelled_error()
          self.cancelled_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.misplaced_finger_xcept = Biofinger_types.ttypes.Misplaced_finger_error()
          self.misplaced_finger_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_authenticate_user_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.timeout_xcept is not None:
      oprot.writeFieldBegin('timeout_xcept', TType.STRUCT, 2)
      self.timeout_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 3)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.cancelled_xcept is not None:
      oprot.writeFieldBegin('cancelled_xcept', TType.STRUCT, 4)
      self.cancelled_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.misplaced_finger_xcept is not None:
      oprot.writeFieldBegin('misplaced_finger_xcept', TType.STRUCT, 5)
      self.misplaced_finger_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class biofinger_identify_args:
  """
  Attributes:
   - database_id: Database identifier
   - timeout_in_sec: Max. duration of identification process<br>
  0 implies an infinite process.
   - threshold: This parameter specifies the value of the False Acceptance Ratio (FAR) of the MorphoSmart\99 device.<br>
  The value of this parameter can be set from 0 to 10, by 1 value steps.
   - enable_intermediate_replies: If set to false, you will receive only one reply containing the final result of the
  identification, otherwise you may also receive asynchronous replies containing the
  progress status of the identification.
   - optional_param: Identification optional parameters
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'database_id', None, None, ), # 1
    (2, TType.I32, 'timeout_in_sec', None, None, ), # 2
    (3, TType.BYTE, 'threshold', None, None, ), # 3
    (4, TType.BOOL, 'enable_intermediate_replies', None, None, ), # 4
    (5, TType.STRUCT, 'optional_param', (Biofinger_types.ttypes.Biofinger_control_optional_param, Biofinger_types.ttypes.Biofinger_control_optional_param.thrift_spec), None, ), # 5
  )

  def __init__(self, database_id=None, timeout_in_sec=None, threshold=None, enable_intermediate_replies=None, optional_param=None,):
    self.database_id = database_id
    self.timeout_in_sec = timeout_in_sec
    self.threshold = threshold
    self.enable_intermediate_replies = enable_intermediate_replies
    self.optional_param = optional_param

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.database_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.timeout_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.threshold = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.enable_intermediate_replies = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.optional_param = Biofinger_types.ttypes.Biofinger_control_optional_param()
          self.optional_param.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('biofinger_identify_args')
    if self.database_id is not None:
      oprot.writeFieldBegin('database_id', TType.BYTE, 1)
      oprot.writeByte(self.database_id)
      oprot.writeFieldEnd()
    if self.timeout_in_sec is not None:
      oprot.writeFieldBegin('timeout_in_sec', TType.I32, 2)
      oprot.writeI32(self.timeout_in_sec)
      oprot.writeFieldEnd()
    if self.threshold is not None:
      oprot.writeFieldBegin('threshold', TType.BYTE, 3)
      oprot.writeByte(self.threshold)
      oprot.writeFieldEnd()
    if self.enable_intermediate_replies is not None:
      oprot.writeFieldBegin('enable_intermediate_replies', TType.BOOL, 4)
      oprot.writeBool(self.enable_intermediate_replies)
      oprot.writeFieldEnd()
    if self.optional_param is not None:
      oprot.writeFieldBegin('optional_param', TType.STRUCT, 5)
      self.optional_param.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class biofinger_identify_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - DB_empty_xcept: The user database is empty.
   - timeout_xcept: No finger was detected during process
   - invalid_argument_xcept: Invalid parameter
   - cancelled_xcept: Command is cancelled by distant command
   - misplaced_finger_xcept: Finger was misplaced or withdrawn during acquisition
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Biofinger_types.ttypes.Biofinger_control_operation_reply, Biofinger_types.ttypes.Biofinger_control_operation_reply.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'DB_empty_xcept', (Db_types.ttypes.DB_empty_error, Db_types.ttypes.DB_empty_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'timeout_xcept', (Generic_types.ttypes.Timeout_error, Generic_types.ttypes.Timeout_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'cancelled_xcept', (Generic_types.ttypes.Cancelled_error, Generic_types.ttypes.Cancelled_error.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'misplaced_finger_xcept', (Biofinger_types.ttypes.Misplaced_finger_error, Biofinger_types.ttypes.Misplaced_finger_error.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_xcept=None, DB_empty_xcept=None, timeout_xcept=None, invalid_argument_xcept=None, cancelled_xcept=None, misplaced_finger_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.DB_empty_xcept = DB_empty_xcept
    self.timeout_xcept = timeout_xcept
    self.invalid_argument_xcept = invalid_argument_xcept
    self.cancelled_xcept = cancelled_xcept
    self.misplaced_finger_xcept = misplaced_finger_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Biofinger_types.ttypes.Biofinger_control_operation_reply()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.DB_empty_xcept = Db_types.ttypes.DB_empty_error()
          self.DB_empty_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.timeout_xcept = Generic_types.ttypes.Timeout_error()
          self.timeout_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.cancelled_xcept = Generic_types.ttypes.Cancelled_error()
          self.cancelled_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.misplaced_finger_xcept = Biofinger_types.ttypes.Misplaced_finger_error()
          self.misplaced_finger_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('biofinger_identify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.DB_empty_xcept is not None:
      oprot.writeFieldBegin('DB_empty_xcept', TType.STRUCT, 2)
      self.DB_empty_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.timeout_xcept is not None:
      oprot.writeFieldBegin('timeout_xcept', TType.STRUCT, 3)
      self.timeout_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 4)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.cancelled_xcept is not None:
      oprot.writeFieldBegin('cancelled_xcept', TType.STRUCT, 5)
      self.cancelled_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.misplaced_finger_xcept is not None:
      oprot.writeFieldBegin('misplaced_finger_xcept', TType.STRUCT, 6)
      self.misplaced_finger_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class biofinger_authenticate_db_args:
  """
  Attributes:
   - database_id: Database identifier
   - timeout_in_sec: Max. duration of authentication process<br>
  0 implies an infinite process.
   - threshold: This parameter specifies the value of the False Acceptance Ratio (FAR) of the MorphoSmart\99 device.<br>
  The value of this parameter can be set from 0 to 10, by 1 value steps.
   - user_id_UTF8: User ID to authenticate (UTF8 string)
   - enable_intermediate_replies: If set to false, you will receive only one reply containing the final result of the
  authentication, otherwise you may also receive asynchronous replies containing the
  progress status of the authentication.
   - optional_param: Authentication optional parameters
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'database_id', None, None, ), # 1
    (2, TType.I32, 'timeout_in_sec', None, None, ), # 2
    (3, TType.BYTE, 'threshold', None, None, ), # 3
    (4, TType.STRING, 'user_id_UTF8', None, None, ), # 4
    (5, TType.BOOL, 'enable_intermediate_replies', None, None, ), # 5
    (6, TType.STRUCT, 'optional_param', (Biofinger_types.ttypes.Biofinger_control_optional_param, Biofinger_types.ttypes.Biofinger_control_optional_param.thrift_spec), None, ), # 6
  )

  def __init__(self, database_id=None, timeout_in_sec=None, threshold=None, user_id_UTF8=None, enable_intermediate_replies=None, optional_param=None,):
    self.database_id = database_id
    self.timeout_in_sec = timeout_in_sec
    self.threshold = threshold
    self.user_id_UTF8 = user_id_UTF8
    self.enable_intermediate_replies = enable_intermediate_replies
    self.optional_param = optional_param

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.database_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.timeout_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.threshold = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.user_id_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.enable_intermediate_replies = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.optional_param = Biofinger_types.ttypes.Biofinger_control_optional_param()
          self.optional_param.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('biofinger_authenticate_db_args')
    if self.database_id is not None:
      oprot.writeFieldBegin('database_id', TType.BYTE, 1)
      oprot.writeByte(self.database_id)
      oprot.writeFieldEnd()
    if self.timeout_in_sec is not None:
      oprot.writeFieldBegin('timeout_in_sec', TType.I32, 2)
      oprot.writeI32(self.timeout_in_sec)
      oprot.writeFieldEnd()
    if self.threshold is not None:
      oprot.writeFieldBegin('threshold', TType.BYTE, 3)
      oprot.writeByte(self.threshold)
      oprot.writeFieldEnd()
    if self.user_id_UTF8 is not None:
      oprot.writeFieldBegin('user_id_UTF8', TType.STRING, 4)
      oprot.writeString(self.user_id_UTF8)
      oprot.writeFieldEnd()
    if self.enable_intermediate_replies is not None:
      oprot.writeFieldBegin('enable_intermediate_replies', TType.BOOL, 5)
      oprot.writeBool(self.enable_intermediate_replies)
      oprot.writeFieldEnd()
    if self.optional_param is not None:
      oprot.writeFieldBegin('optional_param', TType.STRUCT, 6)
      self.optional_param.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class biofinger_authenticate_db_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - inexistant_user_xcept: The specified user ID has not been found in the database.
   - DB_empty_xcept: The user database is empty.
   - timeout_xcept: No finger was detected during process
   - invalid_argument_xcept: Invalid parameter
   - cancelled_xcept: Command is cancelled by distant command
   - misplaced_finger_xcept: Finger was misplaced or withdrawn during acquisition
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Biofinger_types.ttypes.Biofinger_control_operation_reply, Biofinger_types.ttypes.Biofinger_control_operation_reply.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'inexistant_user_xcept', (Generic_types.ttypes.Inexistent_user_id_error, Generic_types.ttypes.Inexistent_user_id_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'DB_empty_xcept', (Db_types.ttypes.DB_empty_error, Db_types.ttypes.DB_empty_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'timeout_xcept', (Generic_types.ttypes.Timeout_error, Generic_types.ttypes.Timeout_error.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'cancelled_xcept', (Generic_types.ttypes.Cancelled_error, Generic_types.ttypes.Cancelled_error.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'misplaced_finger_xcept', (Biofinger_types.ttypes.Misplaced_finger_error, Biofinger_types.ttypes.Misplaced_finger_error.thrift_spec), None, ), # 7
  )

  def __init__(self, success=None, generic_xcept=None, inexistant_user_xcept=None, DB_empty_xcept=None, timeout_xcept=None, invalid_argument_xcept=None, cancelled_xcept=None, misplaced_finger_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.inexistant_user_xcept = inexistant_user_xcept
    self.DB_empty_xcept = DB_empty_xcept
    self.timeout_xcept = timeout_xcept
    self.invalid_argument_xcept = invalid_argument_xcept
    self.cancelled_xcept = cancelled_xcept
    self.misplaced_finger_xcept = misplaced_finger_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Biofinger_types.ttypes.Biofinger_control_operation_reply()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.inexistant_user_xcept = Generic_types.ttypes.Inexistent_user_id_error()
          self.inexistant_user_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.DB_empty_xcept = Db_types.ttypes.DB_empty_error()
          self.DB_empty_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.timeout_xcept = Generic_types.ttypes.Timeout_error()
          self.timeout_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.cancelled_xcept = Generic_types.ttypes.Cancelled_error()
          self.cancelled_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.misplaced_finger_xcept = Biofinger_types.ttypes.Misplaced_finger_error()
          self.misplaced_finger_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('biofinger_authenticate_db_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.inexistant_user_xcept is not None:
      oprot.writeFieldBegin('inexistant_user_xcept', TType.STRUCT, 2)
      self.inexistant_user_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.DB_empty_xcept is not None:
      oprot.writeFieldBegin('DB_empty_xcept', TType.STRUCT, 3)
      self.DB_empty_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.timeout_xcept is not None:
      oprot.writeFieldBegin('timeout_xcept', TType.STRUCT, 4)
      self.timeout_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 5)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.cancelled_xcept is not None:
      oprot.writeFieldBegin('cancelled_xcept', TType.STRUCT, 6)
      self.cancelled_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.misplaced_finger_xcept is not None:
      oprot.writeFieldBegin('misplaced_finger_xcept', TType.STRUCT, 7)
      self.misplaced_finger_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class biofinger_authenticate_ref_args:
  """
  Attributes:
   - timeout_in_sec: Max. duration of authentication process<br>
  0 implies an infinite process.
   - threshold: This parameter specifies the value of the False Acceptance Ratio (FAR) of the MorphoSmart\99 device.<br>
  The value of this parameter can be set from 0 to 10, by 1 value steps.
   - ref_template_list:                                                                * List of reference templates<br>
                                                                 * The templates can be in any format handled by the terminal<br>
  * Max number of templates per list is 20
   - enable_intermediate_replies: If set to false, you will receive only one reply containing the final result of the
  authentication, otherwise you may also receive asynchronous replies containing the
  progress status of the authentication.
   - optional_param: Authentication optional parameters
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'timeout_in_sec', None, None, ), # 1
    (2, TType.BYTE, 'threshold', None, None, ), # 2
    (3, TType.LIST, 'ref_template_list', (TType.STRUCT,(Biofinger_types.ttypes.User_templates, Biofinger_types.ttypes.User_templates.thrift_spec)), None, ), # 3
    (4, TType.BOOL, 'enable_intermediate_replies', None, None, ), # 4
    (5, TType.STRUCT, 'optional_param', (Biofinger_types.ttypes.Biofinger_control_optional_param, Biofinger_types.ttypes.Biofinger_control_optional_param.thrift_spec), None, ), # 5
  )

  def __init__(self, timeout_in_sec=None, threshold=None, ref_template_list=None, enable_intermediate_replies=None, optional_param=None,):
    self.timeout_in_sec = timeout_in_sec
    self.threshold = threshold
    self.ref_template_list = ref_template_list
    self.enable_intermediate_replies = enable_intermediate_replies
    self.optional_param = optional_param

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.timeout_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.threshold = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.ref_template_list = []
          (_etype114, _size111) = iprot.readListBegin()
          for _i115 in xrange(_size111):
            _elem116 = Biofinger_types.ttypes.User_templates()
            _elem116.read(iprot)
            self.ref_template_list.append(_elem116)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.enable_intermediate_replies = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.optional_param = Biofinger_types.ttypes.Biofinger_control_optional_param()
          self.optional_param.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('biofinger_authenticate_ref_args')
    if self.timeout_in_sec is not None:
      oprot.writeFieldBegin('timeout_in_sec', TType.I32, 1)
      oprot.writeI32(self.timeout_in_sec)
      oprot.writeFieldEnd()
    if self.threshold is not None:
      oprot.writeFieldBegin('threshold', TType.BYTE, 2)
      oprot.writeByte(self.threshold)
      oprot.writeFieldEnd()
    if self.ref_template_list is not None:
      oprot.writeFieldBegin('ref_template_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.ref_template_list))
      for iter117 in self.ref_template_list:
        iter117.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.enable_intermediate_replies is not None:
      oprot.writeFieldBegin('enable_intermediate_replies', TType.BOOL, 4)
      oprot.writeBool(self.enable_intermediate_replies)
      oprot.writeFieldEnd()
    if self.optional_param is not None:
      oprot.writeFieldBegin('optional_param', TType.STRUCT, 5)
      self.optional_param.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class biofinger_authenticate_ref_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - unsupported_format_xcept: A reference template is not supported by the terminal
   - incomptible_ref_xcept: A reference template does not match sensor security policy
   - timeout_xcept: No finger was detected during process
   - invalid_argument_xcept: Invalid parameter
   - cancelled_xcept: Command is cancelled by distant command
   - misplaced_finger_xcept: Finger was misplaced or withdrawn during acquisition
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Biofinger_types.ttypes.Biofinger_control_operation_reply, Biofinger_types.ttypes.Biofinger_control_operation_reply.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'unsupported_format_xcept', (Biofinger_types.ttypes.Unsupported_format_error, Biofinger_types.ttypes.Unsupported_format_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'incomptible_ref_xcept', (Biofinger_types.ttypes.Incompatible_ref_error, Biofinger_types.ttypes.Incompatible_ref_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'timeout_xcept', (Generic_types.ttypes.Timeout_error, Generic_types.ttypes.Timeout_error.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'cancelled_xcept', (Generic_types.ttypes.Cancelled_error, Generic_types.ttypes.Cancelled_error.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'misplaced_finger_xcept', (Biofinger_types.ttypes.Misplaced_finger_error, Biofinger_types.ttypes.Misplaced_finger_error.thrift_spec), None, ), # 7
  )

  def __init__(self, success=None, generic_xcept=None, unsupported_format_xcept=None, incomptible_ref_xcept=None, timeout_xcept=None, invalid_argument_xcept=None, cancelled_xcept=None, misplaced_finger_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.unsupported_format_xcept = unsupported_format_xcept
    self.incomptible_ref_xcept = incomptible_ref_xcept
    self.timeout_xcept = timeout_xcept
    self.invalid_argument_xcept = invalid_argument_xcept
    self.cancelled_xcept = cancelled_xcept
    self.misplaced_finger_xcept = misplaced_finger_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Biofinger_types.ttypes.Biofinger_control_operation_reply()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.unsupported_format_xcept = Biofinger_types.ttypes.Unsupported_format_error()
          self.unsupported_format_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.incomptible_ref_xcept = Biofinger_types.ttypes.Incompatible_ref_error()
          self.incomptible_ref_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.timeout_xcept = Generic_types.ttypes.Timeout_error()
          self.timeout_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.cancelled_xcept = Generic_types.ttypes.Cancelled_error()
          self.cancelled_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.misplaced_finger_xcept = Biofinger_types.ttypes.Misplaced_finger_error()
          self.misplaced_finger_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('biofinger_authenticate_ref_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.unsupported_format_xcept is not None:
      oprot.writeFieldBegin('unsupported_format_xcept', TType.STRUCT, 2)
      self.unsupported_format_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.incomptible_ref_xcept is not None:
      oprot.writeFieldBegin('incomptible_ref_xcept', TType.STRUCT, 3)
      self.incomptible_ref_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.timeout_xcept is not None:
      oprot.writeFieldBegin('timeout_xcept', TType.STRUCT, 4)
      self.timeout_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 5)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.cancelled_xcept is not None:
      oprot.writeFieldBegin('cancelled_xcept', TType.STRUCT, 6)
      self.cancelled_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.misplaced_finger_xcept is not None:
      oprot.writeFieldBegin('misplaced_finger_xcept', TType.STRUCT, 7)
      self.misplaced_finger_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class biofinger_enroll_args:
  """
  Attributes:
   - database_id: Database identifier<br>
  That parameter is useless if the function does not store in terminal database
   - timeout_in_sec: Max. duration of authentication process<br>
  0 implies an infinite process. Allowed range is 0 - 65535 seconds
   - enrollment_type: This function can create a new record in terminal user database,
  or can return the captured templated, or can perform both.
   - nb_of_finger: Number of fingers to enroll.
  It can be 1, 2 or 3 fingers.
   - user_id_UTF8: User ID to enroll<br>
  That parameter is useless if the function does not store in terminal database
   - user_fields: The user's data to store along with templates<br>
  That parameter is useless if the function does not store in terminal database
   - enable_intermediate_replies: If set to false, you will receive only one reply containing the final result of the
  enrollment, otherwise you may also receive asynchronous replies containing the
  progress status of the enrollment.
   - optional_param: Enrollment optional parameter
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'database_id', None, None, ), # 1
    (2, TType.I32, 'timeout_in_sec', None, None, ), # 2
    (3, TType.I32, 'enrollment_type', None, None, ), # 3
    (4, TType.BYTE, 'nb_of_finger', None, None, ), # 4
    (5, TType.STRING, 'user_id_UTF8', None, None, ), # 5
    (6, TType.STRUCT, 'user_fields', (Db_types.ttypes.User_DB_record, Db_types.ttypes.User_DB_record.thrift_spec), None, ), # 6
    (7, TType.BOOL, 'enable_intermediate_replies', None, None, ), # 7
    (8, TType.STRUCT, 'optional_param', (Biofinger_types.ttypes.Biofinger_enroll_optional_param, Biofinger_types.ttypes.Biofinger_enroll_optional_param.thrift_spec), None, ), # 8
  )

  def __init__(self, database_id=None, timeout_in_sec=None, enrollment_type=None, nb_of_finger=None, user_id_UTF8=None, user_fields=None, enable_intermediate_replies=None, optional_param=None,):
    self.database_id = database_id
    self.timeout_in_sec = timeout_in_sec
    self.enrollment_type = enrollment_type
    self.nb_of_finger = nb_of_finger
    self.user_id_UTF8 = user_id_UTF8
    self.user_fields = user_fields
    self.enable_intermediate_replies = enable_intermediate_replies
    self.optional_param = optional_param

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.database_id = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.timeout_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.enrollment_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.nb_of_finger = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.user_id_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.user_fields = Db_types.ttypes.User_DB_record()
          self.user_fields.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.enable_intermediate_replies = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.optional_param = Biofinger_types.ttypes.Biofinger_enroll_optional_param()
          self.optional_param.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('biofinger_enroll_args')
    if self.database_id is not None:
      oprot.writeFieldBegin('database_id', TType.BYTE, 1)
      oprot.writeByte(self.database_id)
      oprot.writeFieldEnd()
    if self.timeout_in_sec is not None:
      oprot.writeFieldBegin('timeout_in_sec', TType.I32, 2)
      oprot.writeI32(self.timeout_in_sec)
      oprot.writeFieldEnd()
    if self.enrollment_type is not None:
      oprot.writeFieldBegin('enrollment_type', TType.I32, 3)
      oprot.writeI32(self.enrollment_type)
      oprot.writeFieldEnd()
    if self.nb_of_finger is not None:
      oprot.writeFieldBegin('nb_of_finger', TType.BYTE, 4)
      oprot.writeByte(self.nb_of_finger)
      oprot.writeFieldEnd()
    if self.user_id_UTF8 is not None:
      oprot.writeFieldBegin('user_id_UTF8', TType.STRING, 5)
      oprot.writeString(self.user_id_UTF8)
      oprot.writeFieldEnd()
    if self.user_fields is not None:
      oprot.writeFieldBegin('user_fields', TType.STRUCT, 6)
      self.user_fields.write(oprot)
      oprot.writeFieldEnd()
    if self.enable_intermediate_replies is not None:
      oprot.writeFieldBegin('enable_intermediate_replies', TType.BOOL, 7)
      oprot.writeBool(self.enable_intermediate_replies)
      oprot.writeFieldEnd()
    if self.optional_param is not None:
      oprot.writeFieldBegin('optional_param', TType.STRUCT, 8)
      self.optional_param.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class biofinger_enroll_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - incompatbile_ref_xcept: A captured template does not match sensor security policy
   - timeout_xcept: No finger was detected during process
   - invalid_argument_xcept: Invalid parameter
   - cancelled_xcept: Command is cancelled by distant command
   - duplicate_record_xcept: User ID already exists in terminal database
   - DB_full_xcept: Failure due to missing available space in the database
   - unavailable_field_xcept: The user record is containing a field which is not supported by the terminal database
   - duplicated_finger_xcept: User uses a finger more than once
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Biofinger_types.ttypes.Biofinger_enroll_operation_reply, Biofinger_types.ttypes.Biofinger_enroll_operation_reply.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'incompatbile_ref_xcept', (Biofinger_types.ttypes.Incompatible_ref_error, Biofinger_types.ttypes.Incompatible_ref_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'timeout_xcept', (Generic_types.ttypes.Timeout_error, Generic_types.ttypes.Timeout_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'cancelled_xcept', (Generic_types.ttypes.Cancelled_error, Generic_types.ttypes.Cancelled_error.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'duplicate_record_xcept', (Db_types.ttypes.DB_duplicate_record_error, Db_types.ttypes.DB_duplicate_record_error.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'DB_full_xcept', (Db_types.ttypes.DB_full_error, Db_types.ttypes.DB_full_error.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'unavailable_field_xcept', (Db_types.ttypes.User_DB_unavailable_field, Db_types.ttypes.User_DB_unavailable_field.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'duplicated_finger_xcept', (Biofinger_types.ttypes.Duplicated_finger_error, Biofinger_types.ttypes.Duplicated_finger_error.thrift_spec), None, ), # 9
  )

  def __init__(self, success=None, generic_xcept=None, incompatbile_ref_xcept=None, timeout_xcept=None, invalid_argument_xcept=None, cancelled_xcept=None, duplicate_record_xcept=None, DB_full_xcept=None, unavailable_field_xcept=None, duplicated_finger_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.incompatbile_ref_xcept = incompatbile_ref_xcept
    self.timeout_xcept = timeout_xcept
    self.invalid_argument_xcept = invalid_argument_xcept
    self.cancelled_xcept = cancelled_xcept
    self.duplicate_record_xcept = duplicate_record_xcept
    self.DB_full_xcept = DB_full_xcept
    self.unavailable_field_xcept = unavailable_field_xcept
    self.duplicated_finger_xcept = duplicated_finger_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Biofinger_types.ttypes.Biofinger_enroll_operation_reply()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.incompatbile_ref_xcept = Biofinger_types.ttypes.Incompatible_ref_error()
          self.incompatbile_ref_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.timeout_xcept = Generic_types.ttypes.Timeout_error()
          self.timeout_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.cancelled_xcept = Generic_types.ttypes.Cancelled_error()
          self.cancelled_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.duplicate_record_xcept = Db_types.ttypes.DB_duplicate_record_error()
          self.duplicate_record_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.DB_full_xcept = Db_types.ttypes.DB_full_error()
          self.DB_full_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.unavailable_field_xcept = Db_types.ttypes.User_DB_unavailable_field()
          self.unavailable_field_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.duplicated_finger_xcept = Biofinger_types.ttypes.Duplicated_finger_error()
          self.duplicated_finger_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('biofinger_enroll_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.incompatbile_ref_xcept is not None:
      oprot.writeFieldBegin('incompatbile_ref_xcept', TType.STRUCT, 2)
      self.incompatbile_ref_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.timeout_xcept is not None:
      oprot.writeFieldBegin('timeout_xcept', TType.STRUCT, 3)
      self.timeout_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 4)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.cancelled_xcept is not None:
      oprot.writeFieldBegin('cancelled_xcept', TType.STRUCT, 5)
      self.cancelled_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.duplicate_record_xcept is not None:
      oprot.writeFieldBegin('duplicate_record_xcept', TType.STRUCT, 6)
      self.duplicate_record_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.DB_full_xcept is not None:
      oprot.writeFieldBegin('DB_full_xcept', TType.STRUCT, 7)
      self.DB_full_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable_field_xcept is not None:
      oprot.writeFieldBegin('unavailable_field_xcept', TType.STRUCT, 8)
      self.unavailable_field_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.duplicated_finger_xcept is not None:
      oprot.writeFieldBegin('duplicated_finger_xcept', TType.STRUCT, 9)
      self.duplicated_finger_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PIN_authenticate_db_args:
  """
  Attributes:
   - timeout_in_sec: Max. duration of authentication process<br>
  Limited to 60s.
   - user_id_UTF8: User ID to authenticate (UTF8 string)
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'timeout_in_sec', None, None, ), # 1
    (2, TType.STRING, 'user_id_UTF8', None, None, ), # 2
  )

  def __init__(self, timeout_in_sec=None, user_id_UTF8=None,):
    self.timeout_in_sec = timeout_in_sec
    self.user_id_UTF8 = user_id_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.timeout_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user_id_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PIN_authenticate_db_args')
    if self.timeout_in_sec is not None:
      oprot.writeFieldBegin('timeout_in_sec', TType.I32, 1)
      oprot.writeI32(self.timeout_in_sec)
      oprot.writeFieldEnd()
    if self.user_id_UTF8 is not None:
      oprot.writeFieldBegin('user_id_UTF8', TType.STRING, 2)
      oprot.writeString(self.user_id_UTF8)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PIN_authenticate_db_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Tried to enroll using duplicate fingers
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, invalid_argument_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PIN_authenticate_db_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reset_factory_settings_args:
  """
  Attributes:
   - list_of_settings: List of the settings to reset.
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'list_of_settings', (TType.I32,None), None, ), # 1
  )

  def __init__(self, list_of_settings=None,):
    self.list_of_settings = list_of_settings

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.list_of_settings = []
          (_etype121, _size118) = iprot.readListBegin()
          for _i122 in xrange(_size118):
            _elem123 = iprot.readI32();
            self.list_of_settings.append(_elem123)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reset_factory_settings_args')
    if self.list_of_settings is not None:
      oprot.writeFieldBegin('list_of_settings', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.list_of_settings))
      for iter124 in self.list_of_settings:
        oprot.writeI32(iter124)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reset_factory_settings_result:
  """
  Attributes:
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, generic_xcept=None,):
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reset_factory_settings_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_DB_get_status_args:
  """
  Attributes:
   - type: Type of user to retrieve status
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
  )

  def __init__(self, type=None,):
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_DB_get_status_args')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_DB_get_status_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Db_types.ttypes.DB_status, Db_types.ttypes.DB_status.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Db_types.ttypes.DB_status()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_DB_get_status_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_DB_get_fields_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_DB_get_fields_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_DB_get_fields_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype128, _size125) = iprot.readSetBegin()
          for _i129 in xrange(_size125):
            _elem130 = iprot.readI32();
            self.success.add(_elem130)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_DB_get_fields_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I32, len(self.success))
      for iter131 in self.success:
        oprot.writeI32(iter131)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_DB_set_users_args:
  """
  Attributes:
   - users: Mapping of User IDs (UTF8 string) to their database fields
   - enable_similar_finger_check: If set to true,  checks  on  reference  templates  are performed:  same  finger  cannot  be  used  twice,<br>
  and  the  person  must  not  be  already  enrolled.<br>
  If set to false, these checks are not performed.<br>
  This  option  is  useful  to  reduce  the  time  taken  to  fill  large databases.<br>
  In this case, the database coherence must be previously checked.
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'users', (TType.STRING,None,TType.STRUCT,(Db_types.ttypes.User_DB_record, Db_types.ttypes.User_DB_record.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'enable_similar_finger_check', None, None, ), # 2
  )

  def __init__(self, users=None, enable_similar_finger_check=None,):
    self.users = users
    self.enable_similar_finger_check = enable_similar_finger_check

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.users = {}
          (_ktype133, _vtype134, _size132 ) = iprot.readMapBegin()
          for _i136 in xrange(_size132):
            _key137 = iprot.readString();
            _val138 = Db_types.ttypes.User_DB_record()
            _val138.read(iprot)
            self.users[_key137] = _val138
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.enable_similar_finger_check = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_DB_set_users_args')
    if self.users is not None:
      oprot.writeFieldBegin('users', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.users))
      for kiter139,viter140 in self.users.items():
        oprot.writeString(kiter139)
        viter140.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.enable_similar_finger_check is not None:
      oprot.writeFieldBegin('enable_similar_finger_check', TType.BOOL, 2)
      oprot.writeBool(self.enable_similar_finger_check)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_DB_set_users_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - DB_full_xcept: Not all of the user records have been added or modified due to missing available space in the database
   - unavailable_field_xcept: One of the user record is containing a field which is not supported by the terminal database
   - invalid_argument_xcept
   - duplicate_finger_xcept: Tried to enroll using duplicate fingers
   - duplicate_user_xcept: Other user is already enrolled using the same fingers
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'DB_full_xcept', (Db_types.ttypes.DB_full_error, Db_types.ttypes.DB_full_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'unavailable_field_xcept', (Db_types.ttypes.User_DB_unavailable_field, Db_types.ttypes.User_DB_unavailable_field.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'duplicate_finger_xcept', (Biofinger_types.ttypes.Duplicated_finger_error, Biofinger_types.ttypes.Duplicated_finger_error.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'duplicate_user_xcept', (Db_types.ttypes.DB_duplicate_record_error, Db_types.ttypes.DB_duplicate_record_error.thrift_spec), None, ), # 6
  )

  def __init__(self, generic_xcept=None, DB_full_xcept=None, unavailable_field_xcept=None, invalid_argument_xcept=None, duplicate_finger_xcept=None, duplicate_user_xcept=None,):
    self.generic_xcept = generic_xcept
    self.DB_full_xcept = DB_full_xcept
    self.unavailable_field_xcept = unavailable_field_xcept
    self.invalid_argument_xcept = invalid_argument_xcept
    self.duplicate_finger_xcept = duplicate_finger_xcept
    self.duplicate_user_xcept = duplicate_user_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.DB_full_xcept = Db_types.ttypes.DB_full_error()
          self.DB_full_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.unavailable_field_xcept = Db_types.ttypes.User_DB_unavailable_field()
          self.unavailable_field_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.duplicate_finger_xcept = Biofinger_types.ttypes.Duplicated_finger_error()
          self.duplicate_finger_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.duplicate_user_xcept = Db_types.ttypes.DB_duplicate_record_error()
          self.duplicate_user_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_DB_set_users_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.DB_full_xcept is not None:
      oprot.writeFieldBegin('DB_full_xcept', TType.STRUCT, 2)
      self.DB_full_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable_field_xcept is not None:
      oprot.writeFieldBegin('unavailable_field_xcept', TType.STRUCT, 3)
      self.unavailable_field_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 4)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.duplicate_finger_xcept is not None:
      oprot.writeFieldBegin('duplicate_finger_xcept', TType.STRUCT, 5)
      self.duplicate_finger_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.duplicate_user_xcept is not None:
      oprot.writeFieldBegin('duplicate_user_xcept', TType.STRUCT, 6)
      self.duplicate_user_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_DB_delete_records_args:
  """
  Attributes:
   - user_IDs_UTF8: User IDs (UTF8 string) of records to delete
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'user_IDs_UTF8', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, user_IDs_UTF8=None,):
    self.user_IDs_UTF8 = user_IDs_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.user_IDs_UTF8 = set()
          (_etype144, _size141) = iprot.readSetBegin()
          for _i145 in xrange(_size141):
            _elem146 = iprot.readString();
            self.user_IDs_UTF8.add(_elem146)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_DB_delete_records_args')
    if self.user_IDs_UTF8 is not None:
      oprot.writeFieldBegin('user_IDs_UTF8', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.user_IDs_UTF8))
      for iter147 in self.user_IDs_UTF8:
        oprot.writeString(iter147)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_DB_delete_records_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.BOOL,None), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype149, _vtype150, _size148 ) = iprot.readMapBegin()
          for _i152 in xrange(_size148):
            _key153 = iprot.readString();
            _val154 = iprot.readBool();
            self.success[_key153] = _val154
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_DB_delete_records_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.BOOL, len(self.success))
      for kiter155,viter156 in self.success.items():
        oprot.writeString(kiter155)
        oprot.writeBool(viter156)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_DB_delete_all_records_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_DB_delete_all_records_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_DB_delete_all_records_result:
  """
  Attributes:
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, generic_xcept=None,):
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_DB_delete_all_records_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_DB_get_users_args:
  """
  Attributes:
   - user_IDs_UTF8: List of User IDs to return
   - requested_fields: Fields to return in the DB_record structure. It can be empty if you just
  want to check for a User ID presence.
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'user_IDs_UTF8', (TType.STRING,None), None, ), # 1
    (2, TType.SET, 'requested_fields', (TType.I32,None), None, ), # 2
  )

  def __init__(self, user_IDs_UTF8=None, requested_fields=None,):
    self.user_IDs_UTF8 = user_IDs_UTF8
    self.requested_fields = requested_fields

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.user_IDs_UTF8 = set()
          (_etype160, _size157) = iprot.readSetBegin()
          for _i161 in xrange(_size157):
            _elem162 = iprot.readString();
            self.user_IDs_UTF8.add(_elem162)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.requested_fields = set()
          (_etype166, _size163) = iprot.readSetBegin()
          for _i167 in xrange(_size163):
            _elem168 = iprot.readI32();
            self.requested_fields.add(_elem168)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_DB_get_users_args')
    if self.user_IDs_UTF8 is not None:
      oprot.writeFieldBegin('user_IDs_UTF8', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.user_IDs_UTF8))
      for iter169 in self.user_IDs_UTF8:
        oprot.writeString(iter169)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.requested_fields is not None:
      oprot.writeFieldBegin('requested_fields', TType.SET, 2)
      oprot.writeSetBegin(TType.I32, len(self.requested_fields))
      for iter170 in self.requested_fields:
        oprot.writeI32(iter170)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_DB_get_users_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid argument
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Db_types.ttypes.User_DB_record, Db_types.ttypes.User_DB_record.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, invalid_argument_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype172, _vtype173, _size171 ) = iprot.readMapBegin()
          for _i175 in xrange(_size171):
            _key176 = iprot.readString();
            _val177 = Db_types.ttypes.User_DB_record()
            _val177.read(iprot)
            self.success[_key176] = _val177
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_DB_get_users_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter178,viter179 in self.success.items():
        oprot.writeString(kiter178)
        viter179.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_DB_get_user_IDs_args:
  """
  Attributes:
   - type: Kind of user to retrieve
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
  )

  def __init__(self, type=None,):
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_DB_get_user_IDs_args')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_DB_get_user_IDs_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype183, _size180) = iprot.readSetBegin()
          for _i184 in xrange(_size180):
            _elem185 = iprot.readString();
            self.success.add(_elem185)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_DB_get_user_IDs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter186 in self.success:
        oprot.writeString(iter186)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dynamic_message_set_args:
  """
  Attributes:
   - dm_list: Mapping of User IDs (UTF8 string) to their dynamic message database fields
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'dm_list', (TType.STRING,None,TType.STRUCT,(Db_types.ttypes.Dynamic_msg_DB_record, Db_types.ttypes.Dynamic_msg_DB_record.thrift_spec)), None, ), # 1
  )

  def __init__(self, dm_list=None,):
    self.dm_list = dm_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.dm_list = {}
          (_ktype188, _vtype189, _size187 ) = iprot.readMapBegin()
          for _i191 in xrange(_size187):
            _key192 = iprot.readString();
            _val193 = Db_types.ttypes.Dynamic_msg_DB_record()
            _val193.read(iprot)
            self.dm_list[_key192] = _val193
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dynamic_message_set_args')
    if self.dm_list is not None:
      oprot.writeFieldBegin('dm_list', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.dm_list))
      for kiter194,viter195 in self.dm_list.items():
        oprot.writeString(kiter194)
        viter195.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dynamic_message_set_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid argument
   - sd_card_not_found_xcept: SD card not found
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'sd_card_not_found_xcept', (Generic_types.ttypes.SD_card_not_found, Generic_types.ttypes.SD_card_not_found.thrift_spec), None, ), # 3
  )

  def __init__(self, generic_xcept=None, invalid_argument_xcept=None, sd_card_not_found_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept
    self.sd_card_not_found_xcept = sd_card_not_found_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.sd_card_not_found_xcept = Generic_types.ttypes.SD_card_not_found()
          self.sd_card_not_found_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dynamic_message_set_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.sd_card_not_found_xcept is not None:
      oprot.writeFieldBegin('sd_card_not_found_xcept', TType.STRUCT, 3)
      self.sd_card_not_found_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dynamic_message_get_args:
  """
  Attributes:
   - user_IDs_UTF8: Set of User IDs to return
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'user_IDs_UTF8', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, user_IDs_UTF8=None,):
    self.user_IDs_UTF8 = user_IDs_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.user_IDs_UTF8 = set()
          (_etype199, _size196) = iprot.readSetBegin()
          for _i200 in xrange(_size196):
            _elem201 = iprot.readString();
            self.user_IDs_UTF8.add(_elem201)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dynamic_message_get_args')
    if self.user_IDs_UTF8 is not None:
      oprot.writeFieldBegin('user_IDs_UTF8', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.user_IDs_UTF8))
      for iter202 in self.user_IDs_UTF8:
        oprot.writeString(iter202)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dynamic_message_get_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid argument
   - sd_card_not_found_xcept: SD card not found
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Db_types.ttypes.Dynamic_msg_DB_record, Db_types.ttypes.Dynamic_msg_DB_record.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'sd_card_not_found_xcept', (Generic_types.ttypes.SD_card_not_found, Generic_types.ttypes.SD_card_not_found.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, generic_xcept=None, invalid_argument_xcept=None, sd_card_not_found_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept
    self.sd_card_not_found_xcept = sd_card_not_found_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype204, _vtype205, _size203 ) = iprot.readMapBegin()
          for _i207 in xrange(_size203):
            _key208 = iprot.readString();
            _val209 = Db_types.ttypes.Dynamic_msg_DB_record()
            _val209.read(iprot)
            self.success[_key208] = _val209
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.sd_card_not_found_xcept = Generic_types.ttypes.SD_card_not_found()
          self.sd_card_not_found_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dynamic_message_get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter210,viter211 in self.success.items():
        oprot.writeString(kiter210)
        viter211.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.sd_card_not_found_xcept is not None:
      oprot.writeFieldBegin('sd_card_not_found_xcept', TType.STRUCT, 3)
      self.sd_card_not_found_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dynamic_message_reset_args:
  """
  Attributes:
   - user_IDs_UTF8: Set of User IDs whose dynamic message have to be reset
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'user_IDs_UTF8', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, user_IDs_UTF8=None,):
    self.user_IDs_UTF8 = user_IDs_UTF8

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.user_IDs_UTF8 = set()
          (_etype215, _size212) = iprot.readSetBegin()
          for _i216 in xrange(_size212):
            _elem217 = iprot.readString();
            self.user_IDs_UTF8.add(_elem217)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dynamic_message_reset_args')
    if self.user_IDs_UTF8 is not None:
      oprot.writeFieldBegin('user_IDs_UTF8', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.user_IDs_UTF8))
      for iter218 in self.user_IDs_UTF8:
        oprot.writeString(iter218)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dynamic_message_reset_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid argument
   - sd_card_not_found_xcept: SD card not found
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'sd_card_not_found_xcept', (Generic_types.ttypes.SD_card_not_found, Generic_types.ttypes.SD_card_not_found.thrift_spec), None, ), # 3
  )

  def __init__(self, generic_xcept=None, invalid_argument_xcept=None, sd_card_not_found_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept
    self.sd_card_not_found_xcept = sd_card_not_found_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.sd_card_not_found_xcept = Generic_types.ttypes.SD_card_not_found()
          self.sd_card_not_found_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dynamic_message_reset_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.sd_card_not_found_xcept is not None:
      oprot.writeFieldBegin('sd_card_not_found_xcept', TType.STRUCT, 3)
      self.sd_card_not_found_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dynamic_message_get_user_IDs_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dynamic_message_get_user_IDs_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dynamic_message_get_user_IDs_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - sd_card_not_found_xcept: SD card not found
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'sd_card_not_found_xcept', (Generic_types.ttypes.SD_card_not_found, Generic_types.ttypes.SD_card_not_found.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, sd_card_not_found_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.sd_card_not_found_xcept = sd_card_not_found_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype222, _size219) = iprot.readSetBegin()
          for _i223 in xrange(_size219):
            _elem224 = iprot.readString();
            self.success.add(_elem224)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sd_card_not_found_xcept = Generic_types.ttypes.SD_card_not_found()
          self.sd_card_not_found_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dynamic_message_get_user_IDs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter225 in self.success:
        oprot.writeString(iter225)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.sd_card_not_found_xcept is not None:
      oprot.writeFieldBegin('sd_card_not_found_xcept', TType.STRUCT, 2)
      self.sd_card_not_found_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class external_db_get_id_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('external_db_get_id_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class external_db_get_id_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('external_db_get_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class external_db_verify_user_args:
  """
  Attributes:
   - user_id_UTF8: User ID
   - user_data: User data
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user_id_UTF8', None, None, ), # 1
    (2, TType.STRUCT, 'user_data', (Db_types.ttypes.User_DB_record, Db_types.ttypes.User_DB_record.thrift_spec), None, ), # 2
  )

  def __init__(self, user_id_UTF8=None, user_data=None,):
    self.user_id_UTF8 = user_id_UTF8
    self.user_data = user_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user_id_UTF8 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user_data = Db_types.ttypes.User_DB_record()
          self.user_data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('external_db_verify_user_args')
    if self.user_id_UTF8 is not None:
      oprot.writeFieldBegin('user_id_UTF8', TType.STRING, 1)
      oprot.writeString(self.user_id_UTF8)
      oprot.writeFieldEnd()
    if self.user_data is not None:
      oprot.writeFieldBegin('user_data', TType.STRUCT, 2)
      self.user_data.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class external_db_verify_user_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('external_db_verify_user_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class external_db_clear_id_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('external_db_clear_id_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class external_db_clear_id_result:
  """
  Attributes:
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, generic_xcept=None,):
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('external_db_clear_id_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_get_info_args:
  """
  Attributes:
   - timeout_in_sec: Duration max. of the operation in seconds
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'timeout_in_sec', None, None, ), # 1
  )

  def __init__(self, timeout_in_sec=None,):
    self.timeout_in_sec = timeout_in_sec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.timeout_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_get_info_args')
    if self.timeout_in_sec is not None:
      oprot.writeFieldBegin('timeout_in_sec', TType.I32, 1)
      oprot.writeI32(self.timeout_in_sec)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_get_info_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - ex1: No suitable cards were detected during the defined duration
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Cls_types.ttypes.Cls_info, Cls_types.ttypes.Cls_info.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex1', (Generic_types.ttypes.Timeout_error, Generic_types.ttypes.Timeout_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, ex1=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.ex1 = ex1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Cls_types.ttypes.Cls_info()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex1 = Generic_types.ttypes.Timeout_error()
          self.ex1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_get_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.ex1 is not None:
      oprot.writeFieldBegin('ex1', TType.STRUCT, 2)
      self.ex1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_read_args:
  """
  Attributes:
   - timeout_in_sec: Duration max. of the operation in seconds
   - cards: List of card to support
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'timeout_in_sec', None, None, ), # 1
    (2, TType.STRUCT, 'cards', (Cls_types.ttypes.Cls_cards_definition, Cls_types.ttypes.Cls_cards_definition.thrift_spec), None, ), # 2
  )

  def __init__(self, timeout_in_sec=None, cards=None,):
    self.timeout_in_sec = timeout_in_sec
    self.cards = cards

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.timeout_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.cards = Cls_types.ttypes.Cls_cards_definition()
          self.cards.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_read_args')
    if self.timeout_in_sec is not None:
      oprot.writeFieldBegin('timeout_in_sec', TType.I32, 1)
      oprot.writeI32(self.timeout_in_sec)
      oprot.writeFieldEnd()
    if self.cards is not None:
      oprot.writeFieldBegin('cards', TType.STRUCT, 2)
      self.cards.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_read_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - ex1: Timeout has been reached
   - ex2: Invalid argument
   - ex3: One of the specified contactless key is invalid
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex1', (Generic_types.ttypes.Timeout_error, Generic_types.ttypes.Timeout_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex2', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ex3', (Cls_types.ttypes.Cls_invalid_key_error, Cls_types.ttypes.Cls_invalid_key_error.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, generic_xcept=None, ex1=None, ex2=None, ex3=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.ex1 = ex1
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype229, _size226) = iprot.readListBegin()
          for _i230 in xrange(_size226):
            _elem231 = iprot.readString();
            self.success.append(_elem231)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex1 = Generic_types.ttypes.Timeout_error()
          self.ex1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex2 = Generic_types.ttypes.Invalid_argument_error()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ex3 = Cls_types.ttypes.Cls_invalid_key_error()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_read_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter232 in self.success:
        oprot.writeString(iter232)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.ex1 is not None:
      oprot.writeFieldBegin('ex1', TType.STRUCT, 2)
      self.ex1.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 3)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 4)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_write_args:
  """
  Attributes:
   - timeout_in_sec: Duration max. of the operation in seconds
   - cards: List of card to support
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'timeout_in_sec', None, None, ), # 1
    (2, TType.STRUCT, 'cards', (Cls_types.ttypes.Cls_cards_definition, Cls_types.ttypes.Cls_cards_definition.thrift_spec), None, ), # 2
  )

  def __init__(self, timeout_in_sec=None, cards=None,):
    self.timeout_in_sec = timeout_in_sec
    self.cards = cards

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.timeout_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.cards = Cls_types.ttypes.Cls_cards_definition()
          self.cards.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_write_args')
    if self.timeout_in_sec is not None:
      oprot.writeFieldBegin('timeout_in_sec', TType.I32, 1)
      oprot.writeI32(self.timeout_in_sec)
      oprot.writeFieldEnd()
    if self.cards is not None:
      oprot.writeFieldBegin('cards', TType.STRUCT, 2)
      self.cards.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_write_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - ex1: Timeout has been reached
   - ex2: Invalid argument
   - ex3: One of the specified contactless key is invalid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex1', (Generic_types.ttypes.Timeout_error, Generic_types.ttypes.Timeout_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex2', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ex3', (Cls_types.ttypes.Cls_invalid_key_error, Cls_types.ttypes.Cls_invalid_key_error.thrift_spec), None, ), # 4
  )

  def __init__(self, generic_xcept=None, ex1=None, ex2=None, ex3=None,):
    self.generic_xcept = generic_xcept
    self.ex1 = ex1
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex1 = Generic_types.ttypes.Timeout_error()
          self.ex1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex2 = Generic_types.ttypes.Invalid_argument_error()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ex3 = Cls_types.ttypes.Cls_invalid_key_error()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_write_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.ex1 is not None:
      oprot.writeFieldBegin('ex1', TType.STRUCT, 2)
      self.ex1.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 3)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 4)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_write_user_card_args:
  """
  Attributes:
   - timeout_in_sec: Duration max. of the operation in seconds
   - card_data
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'timeout_in_sec', None, None, ), # 1
    (2, TType.STRUCT, 'card_data', (Cls_types.ttypes.Cls_user_card, Cls_types.ttypes.Cls_user_card.thrift_spec), None, ), # 2
  )

  def __init__(self, timeout_in_sec=None, card_data=None,):
    self.timeout_in_sec = timeout_in_sec
    self.card_data = card_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.timeout_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.card_data = Cls_types.ttypes.Cls_user_card()
          self.card_data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_write_user_card_args')
    if self.timeout_in_sec is not None:
      oprot.writeFieldBegin('timeout_in_sec', TType.I32, 1)
      oprot.writeI32(self.timeout_in_sec)
      oprot.writeFieldEnd()
    if self.card_data is not None:
      oprot.writeFieldBegin('card_data', TType.STRUCT, 2)
      self.card_data.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_write_user_card_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - ex1: Timeout has been reached
   - ex2: Invalid argument
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex1', (Generic_types.ttypes.Timeout_error, Generic_types.ttypes.Timeout_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex2', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 3
  )

  def __init__(self, generic_xcept=None, ex1=None, ex2=None,):
    self.generic_xcept = generic_xcept
    self.ex1 = ex1
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex1 = Generic_types.ttypes.Timeout_error()
          self.ex1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex2 = Generic_types.ttypes.Invalid_argument_error()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_write_user_card_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.ex1 is not None:
      oprot.writeFieldBegin('ex1', TType.STRUCT, 2)
      self.ex1.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 3)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_write_admin_card_args:
  """
  Attributes:
   - timeout_in_sec: Duration max. of the operation in seconds
   - card_type: Admin card type to encode
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'timeout_in_sec', None, None, ), # 1
    (2, TType.I32, 'card_type', None, None, ), # 2
  )

  def __init__(self, timeout_in_sec=None, card_type=None,):
    self.timeout_in_sec = timeout_in_sec
    self.card_type = card_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.timeout_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.card_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_write_admin_card_args')
    if self.timeout_in_sec is not None:
      oprot.writeFieldBegin('timeout_in_sec', TType.I32, 1)
      oprot.writeI32(self.timeout_in_sec)
      oprot.writeFieldEnd()
    if self.card_type is not None:
      oprot.writeFieldBegin('card_type', TType.I32, 2)
      oprot.writeI32(self.card_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_write_admin_card_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - ex1: Timeout has been reached
   - ex2: Invalid argument
   - ex3: The card detected by the terminal is not a card of input parameter card_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex1', (Generic_types.ttypes.Timeout_error, Generic_types.ttypes.Timeout_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex2', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ex3', (Cls_types.ttypes.Cls_invalid_card_type_error, Cls_types.ttypes.Cls_invalid_card_type_error.thrift_spec), None, ), # 4
  )

  def __init__(self, generic_xcept=None, ex1=None, ex2=None, ex3=None,):
    self.generic_xcept = generic_xcept
    self.ex1 = ex1
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex1 = Generic_types.ttypes.Timeout_error()
          self.ex1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex2 = Generic_types.ttypes.Invalid_argument_error()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ex3 = Cls_types.ttypes.Cls_invalid_card_type_error()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_write_admin_card_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.ex1 is not None:
      oprot.writeFieldBegin('ex1', TType.STRUCT, 2)
      self.ex1.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 3)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 4)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_erase_args:
  """
  Attributes:
   - timeout_in_sec: Duration max. of the operation in seconds
   - cards: List of card to support
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'timeout_in_sec', None, None, ), # 1
    (2, TType.STRUCT, 'cards', (Cls_types.ttypes.Cls_cards_definition, Cls_types.ttypes.Cls_cards_definition.thrift_spec), None, ), # 2
  )

  def __init__(self, timeout_in_sec=None, cards=None,):
    self.timeout_in_sec = timeout_in_sec
    self.cards = cards

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.timeout_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.cards = Cls_types.ttypes.Cls_cards_definition()
          self.cards.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_erase_args')
    if self.timeout_in_sec is not None:
      oprot.writeFieldBegin('timeout_in_sec', TType.I32, 1)
      oprot.writeI32(self.timeout_in_sec)
      oprot.writeFieldEnd()
    if self.cards is not None:
      oprot.writeFieldBegin('cards', TType.STRUCT, 2)
      self.cards.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cls_erase_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - ex1: Timeout has been reached
   - ex2: Invalid argument
   - ex3: One of the specified contactless key is invalid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex1', (Generic_types.ttypes.Timeout_error, Generic_types.ttypes.Timeout_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex2', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ex3', (Cls_types.ttypes.Cls_invalid_key_error, Cls_types.ttypes.Cls_invalid_key_error.thrift_spec), None, ), # 4
  )

  def __init__(self, generic_xcept=None, ex1=None, ex2=None, ex3=None,):
    self.generic_xcept = generic_xcept
    self.ex1 = ex1
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex1 = Generic_types.ttypes.Timeout_error()
          self.ex1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex2 = Generic_types.ttypes.Invalid_argument_error()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ex3 = Cls_types.ttypes.Cls_invalid_key_error()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cls_erase_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.ex1 is not None:
      oprot.writeFieldBegin('ex1', TType.STRUCT, 2)
      self.ex1.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 3)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 4)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class key_load_args:
  """
  Attributes:
   - crypto_keys: Crypto key object
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'crypto_keys', (Cls_types.ttypes.Crypto_keys, Cls_types.ttypes.Crypto_keys.thrift_spec), None, ), # 1
  )

  def __init__(self, crypto_keys=None,):
    self.crypto_keys = crypto_keys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.crypto_keys = Cls_types.ttypes.Crypto_keys()
          self.crypto_keys.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('key_load_args')
    if self.crypto_keys is not None:
      oprot.writeFieldBegin('crypto_keys', TType.STRUCT, 1)
      self.crypto_keys.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class key_load_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - ex1: One of the specified contactless key is invalid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex1', (Cls_types.ttypes.Cls_invalid_key_error, Cls_types.ttypes.Cls_invalid_key_error.thrift_spec), None, ), # 2
  )

  def __init__(self, generic_xcept=None, ex1=None,):
    self.generic_xcept = generic_xcept
    self.ex1 = ex1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex1 = Cls_types.ttypes.Cls_invalid_key_error()
          self.ex1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('key_load_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.ex1 is not None:
      oprot.writeFieldBegin('ex1', TType.STRUCT, 2)
      self.ex1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class key_reset_args:
  """
  Attributes:
   - types: List of keys to reset to default value
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'types', (TType.I32,None), None, ), # 1
  )

  def __init__(self, types=None,):
    self.types = types

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.types = []
          (_etype236, _size233) = iprot.readListBegin()
          for _i237 in xrange(_size233):
            _elem238 = iprot.readI32();
            self.types.append(_elem238)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('key_reset_args')
    if self.types is not None:
      oprot.writeFieldBegin('types', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.types))
      for iter239 in self.types:
        oprot.writeI32(iter239)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class key_reset_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - ex1: Invalid argument
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex1', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, generic_xcept=None, ex1=None,):
    self.generic_xcept = generic_xcept
    self.ex1 = ex1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex1 = Generic_types.ttypes.Invalid_argument_error()
          self.ex1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('key_reset_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.ex1 is not None:
      oprot.writeFieldBegin('ex1', TType.STRUCT, 2)
      self.ex1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class terminal_reboot_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('terminal_reboot_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class terminal_reboot_result:
  """
  Attributes:
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, generic_xcept=None,):
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('terminal_reboot_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class terminal_echo_args:
  """
  Attributes:
   - buffer: Buffer to be repeated
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'buffer', None, None, ), # 1
  )

  def __init__(self, buffer=None,):
    self.buffer = buffer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.buffer = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('terminal_echo_args')
    if self.buffer is not None:
      oprot.writeFieldBegin('buffer', TType.STRING, 1)
      oprot.writeString(self.buffer)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class terminal_echo_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - out_of_memory_xcept: The input parameter's size is over size limit (64 bytes)
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'out_of_memory_xcept', (Generic_types.ttypes.Out_of_memory_error, Generic_types.ttypes.Out_of_memory_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, out_of_memory_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.out_of_memory_xcept = out_of_memory_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.out_of_memory_xcept = Generic_types.ttypes.Out_of_memory_error()
          self.out_of_memory_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('terminal_echo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.out_of_memory_xcept is not None:
      oprot.writeFieldBegin('out_of_memory_xcept', TType.STRUCT, 2)
      self.out_of_memory_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class terminal_get_configuration_args:
  """
  Attributes:
   - terminal_settings_type: Terminal setting options
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'terminal_settings_type', (Generic_types.ttypes.Terminal_configuration_type, Generic_types.ttypes.Terminal_configuration_type.thrift_spec), None, ), # 1
  )

  def __init__(self, terminal_settings_type=None,):
    self.terminal_settings_type = terminal_settings_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.terminal_settings_type = Generic_types.ttypes.Terminal_configuration_type()
          self.terminal_settings_type.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('terminal_get_configuration_args')
    if self.terminal_settings_type is not None:
      oprot.writeFieldBegin('terminal_settings_type', TType.STRUCT, 1)
      self.terminal_settings_type.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class terminal_get_configuration_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - ethernet_config_xcept: Failed to get Ethernet configuration
   - WIFI_mod_xcept: WIFI module not connected
   - license_not_xcept: License not found exception
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Generic_types.ttypes.Terminal_configuration, Generic_types.ttypes.Terminal_configuration.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ethernet_config_xcept', (Generic_types.ttypes.Ethernet_config_not_found, Generic_types.ttypes.Ethernet_config_not_found.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'WIFI_mod_xcept', (Generic_types.ttypes.WIFI_module_not_connected, Generic_types.ttypes.WIFI_module_not_connected.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'license_not_xcept', (Generic_types.ttypes.License_not_found, Generic_types.ttypes.License_not_found.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, generic_xcept=None, ethernet_config_xcept=None, WIFI_mod_xcept=None, license_not_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.ethernet_config_xcept = ethernet_config_xcept
    self.WIFI_mod_xcept = WIFI_mod_xcept
    self.license_not_xcept = license_not_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Generic_types.ttypes.Terminal_configuration()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ethernet_config_xcept = Generic_types.ttypes.Ethernet_config_not_found()
          self.ethernet_config_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.WIFI_mod_xcept = Generic_types.ttypes.WIFI_module_not_connected()
          self.WIFI_mod_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.license_not_xcept = Generic_types.ttypes.License_not_found()
          self.license_not_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('terminal_get_configuration_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.ethernet_config_xcept is not None:
      oprot.writeFieldBegin('ethernet_config_xcept', TType.STRUCT, 2)
      self.ethernet_config_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.WIFI_mod_xcept is not None:
      oprot.writeFieldBegin('WIFI_mod_xcept', TType.STRUCT, 3)
      self.WIFI_mod_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.license_not_xcept is not None:
      oprot.writeFieldBegin('license_not_xcept', TType.STRUCT, 4)
      self.license_not_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class terminal_set_configuration_args:
  """
  Attributes:
   - terminal_config: Structure that contains configuration to apply. <br>
  It can contain several configurations.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'terminal_config', (Generic_types.ttypes.Terminal_configuration, Generic_types.ttypes.Terminal_configuration.thrift_spec), None, ), # 1
  )

  def __init__(self, terminal_config=None,):
    self.terminal_config = terminal_config

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.terminal_config = Generic_types.ttypes.Terminal_configuration()
          self.terminal_config.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('terminal_set_configuration_args')
    if self.terminal_config is not None:
      oprot.writeFieldBegin('terminal_config', TType.STRUCT, 1)
      self.terminal_config.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class terminal_set_configuration_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_arg_xcept: Invalid parameter set
   - ethernet_config_xcept: Failed to configure Ethernet settings
   - WIFI_mod_xcept: WIFI module not connected
   - license_not_xcept: License not found exception
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_arg_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ethernet_config_xcept', (Generic_types.ttypes.Ethernet_configuration_failed, Generic_types.ttypes.Ethernet_configuration_failed.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'WIFI_mod_xcept', (Generic_types.ttypes.WIFI_module_not_connected, Generic_types.ttypes.WIFI_module_not_connected.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'license_not_xcept', (Generic_types.ttypes.License_not_found, Generic_types.ttypes.License_not_found.thrift_spec), None, ), # 5
  )

  def __init__(self, generic_xcept=None, invalid_arg_xcept=None, ethernet_config_xcept=None, WIFI_mod_xcept=None, license_not_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_arg_xcept = invalid_arg_xcept
    self.ethernet_config_xcept = ethernet_config_xcept
    self.WIFI_mod_xcept = WIFI_mod_xcept
    self.license_not_xcept = license_not_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_arg_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_arg_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ethernet_config_xcept = Generic_types.ttypes.Ethernet_configuration_failed()
          self.ethernet_config_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.WIFI_mod_xcept = Generic_types.ttypes.WIFI_module_not_connected()
          self.WIFI_mod_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.license_not_xcept = Generic_types.ttypes.License_not_found()
          self.license_not_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('terminal_set_configuration_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_arg_xcept is not None:
      oprot.writeFieldBegin('invalid_arg_xcept', TType.STRUCT, 2)
      self.invalid_arg_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.ethernet_config_xcept is not None:
      oprot.writeFieldBegin('ethernet_config_xcept', TType.STRUCT, 3)
      self.ethernet_config_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.WIFI_mod_xcept is not None:
      oprot.writeFieldBegin('WIFI_mod_xcept', TType.STRUCT, 4)
      self.WIFI_mod_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.license_not_xcept is not None:
      oprot.writeFieldBegin('license_not_xcept', TType.STRUCT, 5)
      self.license_not_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time_get_predefined_time_zone_list_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time_get_predefined_time_zone_list_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time_get_predefined_time_zone_list_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype243, _size240) = iprot.readSetBegin()
          for _i244 in xrange(_size240):
            _elem245 = iprot.readString();
            self.success.add(_elem245)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time_get_predefined_time_zone_list_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter246 in self.success:
        oprot.writeString(iter246)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class distant_session_set_state_args:
  """
  Attributes:
   - state: Open or Close the distant session
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'state', None, None, ), # 1
  )

  def __init__(self, state=None,):
    self.state = state

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.state = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('distant_session_set_state_args')
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 1)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class distant_session_set_state_result:
  """
  Attributes:
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, generic_xcept=None,):
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('distant_session_set_state_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class distant_session_get_state_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('distant_session_get_state_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class distant_session_get_state_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('distant_session_get_state_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancel_operation_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancel_operation_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancel_operation_result:
  """
  Attributes:
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, generic_xcept=None,):
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancel_operation_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class terminal_get_version_args:
  """
  Attributes:
   - firmware_type: Board to retrieve firmware version from
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'firmware_type', None, None, ), # 1
  )

  def __init__(self, firmware_type=None,):
    self.firmware_type = firmware_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.firmware_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('terminal_get_version_args')
    if self.firmware_type is not None:
      oprot.writeFieldBegin('firmware_type', TType.I32, 1)
      oprot.writeI32(self.firmware_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class terminal_get_version_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('terminal_get_version_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class terminal_retrieve_peripherals_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('terminal_retrieve_peripherals_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class terminal_retrieve_peripherals_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype250, _size247) = iprot.readListBegin()
          for _i251 in xrange(_size247):
            _elem252 = iprot.readI32();
            self.success.append(_elem252)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('terminal_retrieve_peripherals_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter253 in self.success:
        oprot.writeI32(iter253)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class product_get_info_args:
  """
  Attributes:
   - info_type: List of requested information
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'info_type', (TType.I32,None), None, ), # 1
  )

  def __init__(self, info_type=None,):
    self.info_type = info_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.info_type = set()
          (_etype257, _size254) = iprot.readSetBegin()
          for _i258 in xrange(_size254):
            _elem259 = iprot.readI32();
            self.info_type.add(_elem259)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('product_get_info_args')
    if self.info_type is not None:
      oprot.writeFieldBegin('info_type', TType.SET, 1)
      oprot.writeSetBegin(TType.I32, len(self.info_type))
      for iter260 in self.info_type:
        oprot.writeI32(iter260)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class product_get_info_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid parameter
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Generic_types.ttypes.Product_info, Generic_types.ttypes.Product_info.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, invalid_argument_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Generic_types.ttypes.Product_info()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('product_get_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_terminal_capabilities_args:
  """
  Attributes:
   - capability_list: List of the capabilities required
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'capability_list', (TType.I32,None), None, ), # 1
  )

  def __init__(self, capability_list=None,):
    self.capability_list = capability_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.capability_list = set()
          (_etype264, _size261) = iprot.readSetBegin()
          for _i265 in xrange(_size261):
            _elem266 = iprot.readI32();
            self.capability_list.add(_elem266)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_terminal_capabilities_args')
    if self.capability_list is not None:
      oprot.writeFieldBegin('capability_list', TType.SET, 1)
      oprot.writeSetBegin(TType.I32, len(self.capability_list))
      for iter267 in self.capability_list:
        oprot.writeI32(iter267)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_terminal_capabilities_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.LIST,(TType.STRUCT,(Generic_types.ttypes.Variant, Generic_types.ttypes.Variant.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype269, _vtype270, _size268 ) = iprot.readMapBegin()
          for _i272 in xrange(_size268):
            _key273 = iprot.readI32();
            _val274 = []
            (_etype278, _size275) = iprot.readListBegin()
            for _i279 in xrange(_size275):
              _elem280 = Generic_types.ttypes.Variant()
              _elem280.read(iprot)
              _val274.append(_elem280)
            iprot.readListEnd()
            self.success[_key273] = _val274
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_terminal_capabilities_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.success))
      for kiter281,viter282 in self.success.items():
        oprot.writeI32(kiter281)
        oprot.writeListBegin(TType.STRUCT, len(viter282))
        for iter283 in viter282:
          iter283.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class wiegand_clock_data_send_string_args:
  """
  Attributes:
   - data_to_send: binary wiegand or clock & data data to send
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'data_to_send', None, None, ), # 1
  )

  def __init__(self, data_to_send=None,):
    self.data_to_send = data_to_send

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data_to_send = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('wiegand_clock_data_send_string_args')
    if self.data_to_send is not None:
      oprot.writeFieldBegin('data_to_send', TType.STRING, 1)
      oprot.writeString(self.data_to_send)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class wiegand_clock_data_send_string_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_wiegand_string_exception
   - wiegand_out_disable_exception
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_wiegand_string_exception', (Generic_types.ttypes.Invalid_wiegand_string, Generic_types.ttypes.Invalid_wiegand_string.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'wiegand_out_disable_exception', (Generic_types.ttypes.Wiegand_output_disabled, Generic_types.ttypes.Wiegand_output_disabled.thrift_spec), None, ), # 3
  )

  def __init__(self, generic_xcept=None, invalid_wiegand_string_exception=None, wiegand_out_disable_exception=None,):
    self.generic_xcept = generic_xcept
    self.invalid_wiegand_string_exception = invalid_wiegand_string_exception
    self.wiegand_out_disable_exception = wiegand_out_disable_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_wiegand_string_exception = Generic_types.ttypes.Invalid_wiegand_string()
          self.invalid_wiegand_string_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.wiegand_out_disable_exception = Generic_types.ttypes.Wiegand_output_disabled()
          self.wiegand_out_disable_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('wiegand_clock_data_send_string_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_wiegand_string_exception is not None:
      oprot.writeFieldBegin('invalid_wiegand_string_exception', TType.STRUCT, 2)
      self.invalid_wiegand_string_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.wiegand_out_disable_exception is not None:
      oprot.writeFieldBegin('wiegand_out_disable_exception', TType.STRUCT, 3)
      self.wiegand_out_disable_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class picture_capture_args:
  """
  Attributes:
   - input_interface: Interface that will capture the picture (Cameras or screen)
   - format: Format of the picture to retrieve (JPEG, BMP ...)
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'input_interface', None, None, ), # 1
    (2, TType.I32, 'format', None, None, ), # 2
  )

  def __init__(self, input_interface=None, format=None,):
    self.input_interface = input_interface
    self.format = format

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.input_interface = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.format = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('picture_capture_args')
    if self.input_interface is not None:
      oprot.writeFieldBegin('input_interface', TType.I32, 1)
      oprot.writeI32(self.input_interface)
      oprot.writeFieldEnd()
    if self.format is not None:
      oprot.writeFieldBegin('format', TType.I32, 2)
      oprot.writeI32(self.format)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class picture_capture_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('picture_capture_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class picture_display_args:
  """
  Attributes:
   - format: Format of the picture to display (JPEG, BMP ...)
   - picture_data: Raw data of the picture file
   - coordinates: Screen coordinates of the right-upper corner of the picture
   - duration_in_sec: Duration in seconds during which the picture is displayed
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'format', None, None, ), # 1
    (2, TType.STRING, 'picture_data', None, None, ), # 2
    (3, TType.STRUCT, 'coordinates', (Generic_types.ttypes.XY_coordinates, Generic_types.ttypes.XY_coordinates.thrift_spec), None, ), # 3
    (4, TType.I32, 'duration_in_sec', None, None, ), # 4
  )

  def __init__(self, format=None, picture_data=None, coordinates=None, duration_in_sec=None,):
    self.format = format
    self.picture_data = picture_data
    self.coordinates = coordinates
    self.duration_in_sec = duration_in_sec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.picture_data = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.coordinates = Generic_types.ttypes.XY_coordinates()
          self.coordinates.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.duration_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('picture_display_args')
    if self.format is not None:
      oprot.writeFieldBegin('format', TType.I32, 1)
      oprot.writeI32(self.format)
      oprot.writeFieldEnd()
    if self.picture_data is not None:
      oprot.writeFieldBegin('picture_data', TType.STRING, 2)
      oprot.writeString(self.picture_data)
      oprot.writeFieldEnd()
    if self.coordinates is not None:
      oprot.writeFieldBegin('coordinates', TType.STRUCT, 3)
      self.coordinates.write(oprot)
      oprot.writeFieldEnd()
    if self.duration_in_sec is not None:
      oprot.writeFieldBegin('duration_in_sec', TType.I32, 4)
      oprot.writeI32(self.duration_in_sec)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class picture_display_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid argument
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, generic_xcept=None, invalid_argument_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('picture_display_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class display_text_args:
  """
  Attributes:
   - message_text: String message text to be display on terminal screen
   - coordinates: Screen coordinates of the right-upper corner of the message text
   - duration_in_sec: Duration in seconds during which the text message is displayed
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message_text', None, None, ), # 1
    (2, TType.STRUCT, 'coordinates', (Generic_types.ttypes.XY_coordinates, Generic_types.ttypes.XY_coordinates.thrift_spec), None, ), # 2
    (3, TType.I32, 'duration_in_sec', None, None, ), # 3
  )

  def __init__(self, message_text=None, coordinates=None, duration_in_sec=None,):
    self.message_text = message_text
    self.coordinates = coordinates
    self.duration_in_sec = duration_in_sec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message_text = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.coordinates = Generic_types.ttypes.XY_coordinates()
          self.coordinates.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.duration_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('display_text_args')
    if self.message_text is not None:
      oprot.writeFieldBegin('message_text', TType.STRING, 1)
      oprot.writeString(self.message_text)
      oprot.writeFieldEnd()
    if self.coordinates is not None:
      oprot.writeFieldBegin('coordinates', TType.STRUCT, 2)
      self.coordinates.write(oprot)
      oprot.writeFieldEnd()
    if self.duration_in_sec is not None:
      oprot.writeFieldBegin('duration_in_sec', TType.I32, 3)
      oprot.writeI32(self.duration_in_sec)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class display_text_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid parameter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, generic_xcept=None, invalid_argument_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('display_text_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class file_load_args:
  """
  Attributes:
   - file_details: In cases where file name is required, the file shall be uploaded with the same name as the file name provided
   - chunk: The chunk of the file
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'file_details', (File_types.ttypes.File_details, File_types.ttypes.File_details.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'chunk', (File_types.ttypes.File_chunk, File_types.ttypes.File_chunk.thrift_spec), None, ), # 2
  )

  def __init__(self, file_details=None, chunk=None,):
    self.file_details = file_details
    self.chunk = chunk

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.file_details = File_types.ttypes.File_details()
          self.file_details.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.chunk = File_types.ttypes.File_chunk()
          self.chunk.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('file_load_args')
    if self.file_details is not None:
      oprot.writeFieldBegin('file_details', TType.STRUCT, 1)
      self.file_details.write(oprot)
      oprot.writeFieldEnd()
    if self.chunk is not None:
      oprot.writeFieldBegin('chunk', TType.STRUCT, 2)
      self.chunk.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class file_load_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - file_inexistent_xcept: The specified file does not exist or insufficient data provided
   - file_large_xcept: The speficied file or chunk exceeds its maximum limit
   - file_name_missing_xcept: The file-name is missing
   - invalid_file_ext_xcept: The particular type of file with the specified extension is not allowed
   - SD_card_not_found_xcept: The SD card not found (might be required for specific files)
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'file_inexistent_xcept', (Generic_types.ttypes.File_inexistent_error, Generic_types.ttypes.File_inexistent_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'file_large_xcept', (Generic_types.ttypes.File_too_large_error, Generic_types.ttypes.File_too_large_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'file_name_missing_xcept', (Generic_types.ttypes.File_name_missing_error, Generic_types.ttypes.File_name_missing_error.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'invalid_file_ext_xcept', (Generic_types.ttypes.Invalid_file_extension_error, Generic_types.ttypes.Invalid_file_extension_error.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'SD_card_not_found_xcept', (Generic_types.ttypes.SD_card_not_found, Generic_types.ttypes.SD_card_not_found.thrift_spec), None, ), # 6
  )

  def __init__(self, generic_xcept=None, file_inexistent_xcept=None, file_large_xcept=None, file_name_missing_xcept=None, invalid_file_ext_xcept=None, SD_card_not_found_xcept=None,):
    self.generic_xcept = generic_xcept
    self.file_inexistent_xcept = file_inexistent_xcept
    self.file_large_xcept = file_large_xcept
    self.file_name_missing_xcept = file_name_missing_xcept
    self.invalid_file_ext_xcept = invalid_file_ext_xcept
    self.SD_card_not_found_xcept = SD_card_not_found_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.file_inexistent_xcept = Generic_types.ttypes.File_inexistent_error()
          self.file_inexistent_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.file_large_xcept = Generic_types.ttypes.File_too_large_error()
          self.file_large_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.file_name_missing_xcept = Generic_types.ttypes.File_name_missing_error()
          self.file_name_missing_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.invalid_file_ext_xcept = Generic_types.ttypes.Invalid_file_extension_error()
          self.invalid_file_ext_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.SD_card_not_found_xcept = Generic_types.ttypes.SD_card_not_found()
          self.SD_card_not_found_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('file_load_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.file_inexistent_xcept is not None:
      oprot.writeFieldBegin('file_inexistent_xcept', TType.STRUCT, 2)
      self.file_inexistent_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.file_large_xcept is not None:
      oprot.writeFieldBegin('file_large_xcept', TType.STRUCT, 3)
      self.file_large_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.file_name_missing_xcept is not None:
      oprot.writeFieldBegin('file_name_missing_xcept', TType.STRUCT, 4)
      self.file_name_missing_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_file_ext_xcept is not None:
      oprot.writeFieldBegin('invalid_file_ext_xcept', TType.STRUCT, 5)
      self.invalid_file_ext_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.SD_card_not_found_xcept is not None:
      oprot.writeFieldBegin('SD_card_not_found_xcept', TType.STRUCT, 6)
      self.SD_card_not_found_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class file_get_args:
  """
  Attributes:
   - file_details: File details of the file to obtain
  (<code>File_types.File_details.name_UTF8</code> shall be ignored except where multiple files exist)
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'file_details', (File_types.ttypes.File_details, File_types.ttypes.File_details.thrift_spec), None, ), # 1
  )

  def __init__(self, file_details=None,):
    self.file_details = file_details

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.file_details = File_types.ttypes.File_details()
          self.file_details.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('file_get_args')
    if self.file_details is not None:
      oprot.writeFieldBegin('file_details', TType.STRUCT, 1)
      self.file_details.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class file_get_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - file_inexistent_xcept: The specified file does not exist or insufficient data provided
   - SD_card_not_found_xcept: The SD card not found (might be required for specific files)
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (File_types.ttypes.File_chunk, File_types.ttypes.File_chunk.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'file_inexistent_xcept', (Generic_types.ttypes.File_inexistent_error, Generic_types.ttypes.File_inexistent_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'SD_card_not_found_xcept', (Generic_types.ttypes.SD_card_not_found, Generic_types.ttypes.SD_card_not_found.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, generic_xcept=None, file_inexistent_xcept=None, SD_card_not_found_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.file_inexistent_xcept = file_inexistent_xcept
    self.SD_card_not_found_xcept = SD_card_not_found_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = File_types.ttypes.File_chunk()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.file_inexistent_xcept = Generic_types.ttypes.File_inexistent_error()
          self.file_inexistent_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.SD_card_not_found_xcept = Generic_types.ttypes.SD_card_not_found()
          self.SD_card_not_found_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('file_get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.file_inexistent_xcept is not None:
      oprot.writeFieldBegin('file_inexistent_xcept', TType.STRUCT, 2)
      self.file_inexistent_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.SD_card_not_found_xcept is not None:
      oprot.writeFieldBegin('SD_card_not_found_xcept', TType.STRUCT, 3)
      self.SD_card_not_found_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class file_get_filenames_args:
  """
  Attributes:
   - file_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'file_type', None, None, ), # 1
  )

  def __init__(self, file_type=None,):
    self.file_type = file_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.file_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('file_get_filenames_args')
    if self.file_type is not None:
      oprot.writeFieldBegin('file_type', TType.I32, 1)
      oprot.writeI32(self.file_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class file_get_filenames_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - file_inexistent_xcept: Invalid file type specified
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(File_types.ttypes.File_details, File_types.ttypes.File_details.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'file_inexistent_xcept', (Generic_types.ttypes.File_inexistent_error, Generic_types.ttypes.File_inexistent_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, file_inexistent_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.file_inexistent_xcept = file_inexistent_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype287, _size284) = iprot.readListBegin()
          for _i288 in xrange(_size284):
            _elem289 = File_types.ttypes.File_details()
            _elem289.read(iprot)
            self.success.append(_elem289)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.file_inexistent_xcept = Generic_types.ttypes.File_inexistent_error()
          self.file_inexistent_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('file_get_filenames_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter290 in self.success:
        iter290.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.file_inexistent_xcept is not None:
      oprot.writeFieldBegin('file_inexistent_xcept', TType.STRUCT, 2)
      self.file_inexistent_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class file_erase_args:
  """
  Attributes:
   - file_details
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'file_details', (File_types.ttypes.File_details, File_types.ttypes.File_details.thrift_spec), None, ), # 1
  )

  def __init__(self, file_details=None,):
    self.file_details = file_details

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.file_details = File_types.ttypes.File_details()
          self.file_details.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('file_erase_args')
    if self.file_details is not None:
      oprot.writeFieldBegin('file_details', TType.STRUCT, 1)
      self.file_details.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class file_erase_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - file_inexistent_xcept: The specified file does not exist or insufficient data provided
   - SD_card_not_found_xcept: The SD card not found (might be required for specific files)
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'file_inexistent_xcept', (Generic_types.ttypes.File_inexistent_error, Generic_types.ttypes.File_inexistent_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'SD_card_not_found_xcept', (Generic_types.ttypes.SD_card_not_found, Generic_types.ttypes.SD_card_not_found.thrift_spec), None, ), # 3
  )

  def __init__(self, generic_xcept=None, file_inexistent_xcept=None, SD_card_not_found_xcept=None,):
    self.generic_xcept = generic_xcept
    self.file_inexistent_xcept = file_inexistent_xcept
    self.SD_card_not_found_xcept = SD_card_not_found_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.file_inexistent_xcept = Generic_types.ttypes.File_inexistent_error()
          self.file_inexistent_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.SD_card_not_found_xcept = Generic_types.ttypes.SD_card_not_found()
          self.SD_card_not_found_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('file_erase_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.file_inexistent_xcept is not None:
      oprot.writeFieldBegin('file_inexistent_xcept', TType.STRUCT, 2)
      self.file_inexistent_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.SD_card_not_found_xcept is not None:
      oprot.writeFieldBegin('SD_card_not_found_xcept', TType.STRUCT, 3)
      self.SD_card_not_found_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_sdac_status_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_sdac_status_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_sdac_status_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Generic_types.ttypes.Sdac_status, Generic_types.ttypes.Sdac_status.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Generic_types.ttypes.Sdac_status()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_sdac_status_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class trigger_relay_args:
  """
  Attributes:
   - duration_in_sec: duration in second for relay activation
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'duration_in_sec', None, None, ), # 1
  )

  def __init__(self, duration_in_sec=None,):
    self.duration_in_sec = duration_in_sec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.duration_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('trigger_relay_args')
    if self.duration_in_sec is not None:
      oprot.writeFieldBegin('duration_in_sec', TType.I32, 1)
      oprot.writeI32(self.duration_in_sec)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class trigger_relay_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid parameter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, generic_xcept=None, invalid_argument_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('trigger_relay_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authorized_IP_get_list_args:
  """
  Attributes:
   - ip_protocol_type: IP protocol type i.e. v4, v6 or all
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ip_protocol_type', None, None, ), # 1
  )

  def __init__(self, ip_protocol_type=None,):
    self.ip_protocol_type = ip_protocol_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ip_protocol_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authorized_IP_get_list_args')
    if self.ip_protocol_type is not None:
      oprot.writeFieldBegin('ip_protocol_type', TType.I32, 1)
      oprot.writeI32(self.ip_protocol_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authorized_IP_get_list_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype294, _size291) = iprot.readListBegin()
          for _i295 in xrange(_size291):
            _elem296 = iprot.readString();
            self.success.append(_elem296)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authorized_IP_get_list_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter297 in self.success:
        oprot.writeString(iter297)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authorized_IP_add_args:
  """
  Attributes:
   - str_ip: UTF8 string containing authorized IP
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'str_ip', None, None, ), # 1
  )

  def __init__(self, str_ip=None,):
    self.str_ip = str_ip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.str_ip = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authorized_IP_add_args')
    if self.str_ip is not None:
      oprot.writeFieldBegin('str_ip', TType.STRING, 1)
      oprot.writeString(self.str_ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authorized_IP_add_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - DB_full_xcept: The database memory of authorized IP range list is full
   - invalid_argument_xcept: Invalid parameter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'DB_full_xcept', (Db_types.ttypes.DB_full_error, Db_types.ttypes.DB_full_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 3
  )

  def __init__(self, generic_xcept=None, DB_full_xcept=None, invalid_argument_xcept=None,):
    self.generic_xcept = generic_xcept
    self.DB_full_xcept = DB_full_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.DB_full_xcept = Db_types.ttypes.DB_full_error()
          self.DB_full_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authorized_IP_add_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.DB_full_xcept is not None:
      oprot.writeFieldBegin('DB_full_xcept', TType.STRUCT, 2)
      self.DB_full_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 3)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authorized_IP_delete_args:
  """
  Attributes:
   - str_ip: UTF8 string containing authorized IP to be deleted
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'str_ip', None, None, ), # 1
  )

  def __init__(self, str_ip=None,):
    self.str_ip = str_ip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.str_ip = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authorized_IP_delete_args')
    if self.str_ip is not None:
      oprot.writeFieldBegin('str_ip', TType.STRING, 1)
      oprot.writeString(self.str_ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authorized_IP_delete_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid parameter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, generic_xcept=None, invalid_argument_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authorized_IP_delete_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authorized_IP_get_range_list_args:
  """
  Attributes:
   - ip_protocol_type: IP protocol type i.e. v4, v6 or all
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ip_protocol_type', None, None, ), # 1
  )

  def __init__(self, ip_protocol_type=None,):
    self.ip_protocol_type = ip_protocol_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ip_protocol_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authorized_IP_get_range_list_args')
    if self.ip_protocol_type is not None:
      oprot.writeFieldBegin('ip_protocol_type', TType.I32, 1)
      oprot.writeI32(self.ip_protocol_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authorized_IP_get_range_list_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype301, _size298) = iprot.readListBegin()
          for _i302 in xrange(_size298):
            _elem303 = iprot.readString();
            self.success.append(_elem303)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authorized_IP_get_range_list_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter304 in self.success:
        oprot.writeString(iter304)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authorized_IP_add_range_args:
  """
  Attributes:
   - str_start_ip: UTF8 string containing authorized IP range start address
   - str_end_ip: UTF8 string containing authorized IP range end address
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'str_start_ip', None, None, ), # 1
    (2, TType.STRING, 'str_end_ip', None, None, ), # 2
  )

  def __init__(self, str_start_ip=None, str_end_ip=None,):
    self.str_start_ip = str_start_ip
    self.str_end_ip = str_end_ip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.str_start_ip = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.str_end_ip = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authorized_IP_add_range_args')
    if self.str_start_ip is not None:
      oprot.writeFieldBegin('str_start_ip', TType.STRING, 1)
      oprot.writeString(self.str_start_ip)
      oprot.writeFieldEnd()
    if self.str_end_ip is not None:
      oprot.writeFieldBegin('str_end_ip', TType.STRING, 2)
      oprot.writeString(self.str_end_ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authorized_IP_add_range_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - DB_full_xcept: The database memory of IP authorized range list is full
   - invalid_argument_xcept: Invalid parameter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'DB_full_xcept', (Db_types.ttypes.DB_full_error, Db_types.ttypes.DB_full_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 3
  )

  def __init__(self, generic_xcept=None, DB_full_xcept=None, invalid_argument_xcept=None,):
    self.generic_xcept = generic_xcept
    self.DB_full_xcept = DB_full_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.DB_full_xcept = Db_types.ttypes.DB_full_error()
          self.DB_full_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authorized_IP_add_range_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.DB_full_xcept is not None:
      oprot.writeFieldBegin('DB_full_xcept', TType.STRUCT, 2)
      self.DB_full_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 3)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authorized_IP_delete_range_args:
  """
  Attributes:
   - str_start_ip: UTF8 string containing an authorized IP range start address to be deleted
   - str_end_ip: UTF8 string containing an authorized IP range end address to be deleted
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'str_start_ip', None, None, ), # 1
    (2, TType.STRING, 'str_end_ip', None, None, ), # 2
  )

  def __init__(self, str_start_ip=None, str_end_ip=None,):
    self.str_start_ip = str_start_ip
    self.str_end_ip = str_end_ip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.str_start_ip = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.str_end_ip = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authorized_IP_delete_range_args')
    if self.str_start_ip is not None:
      oprot.writeFieldBegin('str_start_ip', TType.STRING, 1)
      oprot.writeString(self.str_start_ip)
      oprot.writeFieldEnd()
    if self.str_end_ip is not None:
      oprot.writeFieldBegin('str_end_ip', TType.STRING, 2)
      oprot.writeString(self.str_end_ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authorized_IP_delete_range_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid parameter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, generic_xcept=None, invalid_argument_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authorized_IP_delete_range_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class password_set_args:
  """
  Attributes:
   - id: password ID<br>
  Must be 0 (terminal password)
   - password_old: old password
   - password_new: new password
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, None, ), # 1
    (2, TType.STRING, 'password_old', None, None, ), # 2
    (3, TType.STRING, 'password_new', None, None, ), # 3
  )

  def __init__(self, id=None, password_old=None, password_new=None,):
    self.id = id
    self.password_old = password_old
    self.password_new = password_new

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password_old = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.password_new = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('password_set_args')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.password_old is not None:
      oprot.writeFieldBegin('password_old', TType.STRING, 2)
      oprot.writeString(self.password_old)
      oprot.writeFieldEnd()
    if self.password_new is not None:
      oprot.writeFieldBegin('password_new', TType.STRING, 3)
      oprot.writeString(self.password_new)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class password_set_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - default_password_xcept: A default password detected
   - invalid_argument_xcept: Invalid parameter
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'default_password_xcept', (Generic_types.ttypes.Security_default_password, Generic_types.ttypes.Security_default_password.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, generic_xcept=None, default_password_xcept=None, invalid_argument_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.default_password_xcept = default_password_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.default_password_xcept = Generic_types.ttypes.Security_default_password()
          self.default_password_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('password_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.default_password_xcept is not None:
      oprot.writeFieldBegin('default_password_xcept', TType.STRUCT, 2)
      self.default_password_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 3)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class password_verify_args:
  """
  Attributes:
   - id: password ID<br>
  Must be 0 (terminal password)
   - password: password to be verified with stored password
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, None, ), # 1
    (2, TType.STRING, 'password', None, None, ), # 2
  )

  def __init__(self, id=None, password=None,):
    self.id = id
    self.password = password

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('password_verify_args')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 2)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class password_verify_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid parameter
   - default_password_xcept: A default password detected
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'default_password_xcept', (Generic_types.ttypes.Security_default_password, Generic_types.ttypes.Security_default_password.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, generic_xcept=None, invalid_argument_xcept=None, default_password_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept
    self.default_password_xcept = default_password_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.default_password_xcept = Generic_types.ttypes.Security_default_password()
          self.default_password_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('password_verify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.default_password_xcept is not None:
      oprot.writeFieldBegin('default_password_xcept', TType.STRUCT, 3)
      self.default_password_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class password_reset_args:
  """
  Attributes:
   - id: password ID<br>
  Must be 0 (terminal password)
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, None, ), # 1
  )

  def __init__(self, id=None,):
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('password_reset_args')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class password_reset_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid parameter
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, invalid_argument_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('password_reset_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class passphrase_set_args:
  """
  Attributes:
   - id: passphrase ID
   - passphrase: passphrase
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, None, ), # 1
    (2, TType.STRING, 'passphrase', None, None, ), # 2
  )

  def __init__(self, id=None, passphrase=None,):
    self.id = id
    self.passphrase = passphrase

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.passphrase = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('passphrase_set_args')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.passphrase is not None:
      oprot.writeFieldBegin('passphrase', TType.STRING, 2)
      oprot.writeString(self.passphrase)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class passphrase_set_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid parameter
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, invalid_argument_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('passphrase_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class passphrase_reset_args:
  """
  Attributes:
   - id: passphrase ID
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, None, ), # 1
  )

  def __init__(self, id=None,):
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('passphrase_reset_args')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class passphrase_reset_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid parameter
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, invalid_argument_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('passphrase_reset_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class retrieve_keypad_input_args:
  """
  Attributes:
   - timeout_in_sec: timeout in second for getting input
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'timeout_in_sec', None, None, ), # 1
  )

  def __init__(self, timeout_in_sec=None,):
    self.timeout_in_sec = timeout_in_sec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.timeout_in_sec = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('retrieve_keypad_input_args')
    if self.timeout_in_sec is not None:
      oprot.writeFieldBegin('timeout_in_sec', TType.I32, 1)
      oprot.writeI32(self.timeout_in_sec)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class retrieve_keypad_input_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - cancelled_xcept: Command is cancelled by user
   - timeout_xcept: User input form timed out
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'cancelled_xcept', (Generic_types.ttypes.Cancelled_error, Generic_types.ttypes.Cancelled_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'timeout_xcept', (Generic_types.ttypes.Timeout_error, Generic_types.ttypes.Timeout_error.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, generic_xcept=None, cancelled_xcept=None, timeout_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.cancelled_xcept = cancelled_xcept
    self.timeout_xcept = timeout_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.cancelled_xcept = Generic_types.ttypes.Cancelled_error()
          self.cancelled_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.timeout_xcept = Generic_types.ttypes.Timeout_error()
          self.timeout_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('retrieve_keypad_input_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.cancelled_xcept is not None:
      oprot.writeFieldBegin('cancelled_xcept', TType.STRUCT, 2)
      self.cancelled_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.timeout_xcept is not None:
      oprot.writeFieldBegin('timeout_xcept', TType.STRUCT, 3)
      self.timeout_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class access_schedule_retrieve_args:
  """
  Attributes:
   - schedule_index: access schedule index. Value should be between 1 to 58.
  Schedule 0 is never allowed schedule.
  Schedule 63 is always allowed schedule.
  Schedule 59 to 62 are reserved schedule.
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'schedule_index', (TType.BYTE,None), None, ), # 1
  )

  def __init__(self, schedule_index=None,):
    self.schedule_index = schedule_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.schedule_index = []
          (_etype308, _size305) = iprot.readListBegin()
          for _i309 in xrange(_size305):
            _elem310 = iprot.readByte();
            self.schedule_index.append(_elem310)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('access_schedule_retrieve_args')
    if self.schedule_index is not None:
      oprot.writeFieldBegin('schedule_index', TType.LIST, 1)
      oprot.writeListBegin(TType.BYTE, len(self.schedule_index))
      for iter311 in self.schedule_index:
        oprot.writeByte(iter311)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class access_schedule_retrieve_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - invalid_schedule_index_ex: Invalid schedule index exception
   - inexistant_param_xcept: Access schedule parameter not present in database
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Db_types.ttypes.Access_schedule, Db_types.ttypes.Access_schedule.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_schedule_index_ex', (Db_types.ttypes.Invalid_schedule_index, Db_types.ttypes.Invalid_schedule_index.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'inexistant_param_xcept', (Config_types.ttypes.Config_inexistent_parameter_error, Config_types.ttypes.Config_inexistent_parameter_error.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, generic_xcept=None, invalid_schedule_index_ex=None, inexistant_param_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.invalid_schedule_index_ex = invalid_schedule_index_ex
    self.inexistant_param_xcept = inexistant_param_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype315, _size312) = iprot.readListBegin()
          for _i316 in xrange(_size312):
            _elem317 = Db_types.ttypes.Access_schedule()
            _elem317.read(iprot)
            self.success.append(_elem317)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_schedule_index_ex = Db_types.ttypes.Invalid_schedule_index()
          self.invalid_schedule_index_ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.inexistant_param_xcept = Config_types.ttypes.Config_inexistent_parameter_error()
          self.inexistant_param_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('access_schedule_retrieve_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter318 in self.success:
        iter318.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_schedule_index_ex is not None:
      oprot.writeFieldBegin('invalid_schedule_index_ex', TType.STRUCT, 2)
      self.invalid_schedule_index_ex.write(oprot)
      oprot.writeFieldEnd()
    if self.inexistant_param_xcept is not None:
      oprot.writeFieldBegin('inexistant_param_xcept', TType.STRUCT, 3)
      self.inexistant_param_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class access_schedule_store_args:
  """
  Attributes:
   - schedule_data: access schedule data. List of Access_schedule takes data from sunday to saturday
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'schedule_data', (TType.STRUCT,(Db_types.ttypes.Access_schedule, Db_types.ttypes.Access_schedule.thrift_spec)), None, ), # 1
  )

  def __init__(self, schedule_data=None,):
    self.schedule_data = schedule_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.schedule_data = []
          (_etype322, _size319) = iprot.readListBegin()
          for _i323 in xrange(_size319):
            _elem324 = Db_types.ttypes.Access_schedule()
            _elem324.read(iprot)
            self.schedule_data.append(_elem324)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('access_schedule_store_args')
    if self.schedule_data is not None:
      oprot.writeFieldBegin('schedule_data', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.schedule_data))
      for iter325 in self.schedule_data:
        iter325.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class access_schedule_store_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_schedule_index_ex: Invalid schedule index exception
   - inexistant_param_xcept: Access schedule parameter not present in database
   - invalid_value_xcept: Access schedule data invalid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_schedule_index_ex', (Db_types.ttypes.Invalid_schedule_index, Db_types.ttypes.Invalid_schedule_index.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'inexistant_param_xcept', (Config_types.ttypes.Config_inexistent_parameter_error, Config_types.ttypes.Config_inexistent_parameter_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'invalid_value_xcept', (Config_types.ttypes.Config_invalid_value_error, Config_types.ttypes.Config_invalid_value_error.thrift_spec), None, ), # 4
  )

  def __init__(self, generic_xcept=None, invalid_schedule_index_ex=None, inexistant_param_xcept=None, invalid_value_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_schedule_index_ex = invalid_schedule_index_ex
    self.inexistant_param_xcept = inexistant_param_xcept
    self.invalid_value_xcept = invalid_value_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_schedule_index_ex = Db_types.ttypes.Invalid_schedule_index()
          self.invalid_schedule_index_ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.inexistant_param_xcept = Config_types.ttypes.Config_inexistent_parameter_error()
          self.inexistant_param_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.invalid_value_xcept = Config_types.ttypes.Config_invalid_value_error()
          self.invalid_value_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('access_schedule_store_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_schedule_index_ex is not None:
      oprot.writeFieldBegin('invalid_schedule_index_ex', TType.STRUCT, 2)
      self.invalid_schedule_index_ex.write(oprot)
      oprot.writeFieldEnd()
    if self.inexistant_param_xcept is not None:
      oprot.writeFieldBegin('inexistant_param_xcept', TType.STRUCT, 3)
      self.inexistant_param_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_value_xcept is not None:
      oprot.writeFieldBegin('invalid_value_xcept', TType.STRUCT, 4)
      self.invalid_value_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class access_schedule_delete_args:
  """
  Attributes:
   - schedule_index: access schedule index. Value should be between 1 to 58.
  Schedule 0 is never allowed schedule.
  Schedule 63 is always allowed schedule.
  Schedule 59 to 62 are reserved schedule.
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'schedule_index', (TType.BYTE,None), None, ), # 1
  )

  def __init__(self, schedule_index=None,):
    self.schedule_index = schedule_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.schedule_index = []
          (_etype329, _size326) = iprot.readListBegin()
          for _i330 in xrange(_size326):
            _elem331 = iprot.readByte();
            self.schedule_index.append(_elem331)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('access_schedule_delete_args')
    if self.schedule_index is not None:
      oprot.writeFieldBegin('schedule_index', TType.LIST, 1)
      oprot.writeListBegin(TType.BYTE, len(self.schedule_index))
      for iter332 in self.schedule_index:
        oprot.writeByte(iter332)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class access_schedule_delete_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_schedule_index_ex: Invalid schedule index exception
   - inexistant_param_xcept: Access schedule parameter not present in database
   - invalid_value_xcept: Access schedule data invalid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_schedule_index_ex', (Db_types.ttypes.Invalid_schedule_index, Db_types.ttypes.Invalid_schedule_index.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'inexistant_param_xcept', (Config_types.ttypes.Config_inexistent_parameter_error, Config_types.ttypes.Config_inexistent_parameter_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'invalid_value_xcept', (Config_types.ttypes.Config_invalid_value_error, Config_types.ttypes.Config_invalid_value_error.thrift_spec), None, ), # 4
  )

  def __init__(self, generic_xcept=None, invalid_schedule_index_ex=None, inexistant_param_xcept=None, invalid_value_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_schedule_index_ex = invalid_schedule_index_ex
    self.inexistant_param_xcept = inexistant_param_xcept
    self.invalid_value_xcept = invalid_value_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_schedule_index_ex = Db_types.ttypes.Invalid_schedule_index()
          self.invalid_schedule_index_ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.inexistant_param_xcept = Config_types.ttypes.Config_inexistent_parameter_error()
          self.inexistant_param_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.invalid_value_xcept = Config_types.ttypes.Config_invalid_value_error()
          self.invalid_value_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('access_schedule_delete_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_schedule_index_ex is not None:
      oprot.writeFieldBegin('invalid_schedule_index_ex', TType.STRUCT, 2)
      self.invalid_schedule_index_ex.write(oprot)
      oprot.writeFieldEnd()
    if self.inexistant_param_xcept is not None:
      oprot.writeFieldBegin('inexistant_param_xcept', TType.STRUCT, 3)
      self.inexistant_param_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_value_xcept is not None:
      oprot.writeFieldBegin('invalid_value_xcept', TType.STRUCT, 4)
      self.invalid_value_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class door_open_schedule_retrieve_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('door_open_schedule_retrieve_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class door_open_schedule_retrieve_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - inexistant_param_xcept: Door open schedule parameter not present in database
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Db_types.ttypes.Door_open_schedule, Db_types.ttypes.Door_open_schedule.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'inexistant_param_xcept', (Config_types.ttypes.Config_inexistent_parameter_error, Config_types.ttypes.Config_inexistent_parameter_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, inexistant_param_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.inexistant_param_xcept = inexistant_param_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype336, _size333) = iprot.readListBegin()
          for _i337 in xrange(_size333):
            _elem338 = Db_types.ttypes.Door_open_schedule()
            _elem338.read(iprot)
            self.success.append(_elem338)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.inexistant_param_xcept = Config_types.ttypes.Config_inexistent_parameter_error()
          self.inexistant_param_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('door_open_schedule_retrieve_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter339 in self.success:
        iter339.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.inexistant_param_xcept is not None:
      oprot.writeFieldBegin('inexistant_param_xcept', TType.STRUCT, 2)
      self.inexistant_param_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class door_open_schedule_store_args:
  """
  Attributes:
   - schedule_data: door open schedule data. List of Door_open_schedule takes data from sunday to saturday.
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'schedule_data', (TType.STRUCT,(Db_types.ttypes.Door_open_schedule, Db_types.ttypes.Door_open_schedule.thrift_spec)), None, ), # 1
  )

  def __init__(self, schedule_data=None,):
    self.schedule_data = schedule_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.schedule_data = []
          (_etype343, _size340) = iprot.readListBegin()
          for _i344 in xrange(_size340):
            _elem345 = Db_types.ttypes.Door_open_schedule()
            _elem345.read(iprot)
            self.schedule_data.append(_elem345)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('door_open_schedule_store_args')
    if self.schedule_data is not None:
      oprot.writeFieldBegin('schedule_data', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.schedule_data))
      for iter346 in self.schedule_data:
        iter346.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class door_open_schedule_store_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - inexistant_param_xcept: Door open schedule parameter not present in database
   - invalid_value_xcept: Door open schedule data invalid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'inexistant_param_xcept', (Config_types.ttypes.Config_inexistent_parameter_error, Config_types.ttypes.Config_inexistent_parameter_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'invalid_value_xcept', (Config_types.ttypes.Config_invalid_value_error, Config_types.ttypes.Config_invalid_value_error.thrift_spec), None, ), # 3
  )

  def __init__(self, generic_xcept=None, inexistant_param_xcept=None, invalid_value_xcept=None,):
    self.generic_xcept = generic_xcept
    self.inexistant_param_xcept = inexistant_param_xcept
    self.invalid_value_xcept = invalid_value_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.inexistant_param_xcept = Config_types.ttypes.Config_inexistent_parameter_error()
          self.inexistant_param_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.invalid_value_xcept = Config_types.ttypes.Config_invalid_value_error()
          self.invalid_value_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('door_open_schedule_store_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.inexistant_param_xcept is not None:
      oprot.writeFieldBegin('inexistant_param_xcept', TType.STRUCT, 2)
      self.inexistant_param_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_value_xcept is not None:
      oprot.writeFieldBegin('invalid_value_xcept', TType.STRUCT, 3)
      self.invalid_value_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class door_open_schedule_delete_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('door_open_schedule_delete_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class door_open_schedule_delete_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - inexistant_param_xcept: Door open schedule parameter not present in database
   - invalid_value_xcept: Door open schedule data invalid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'inexistant_param_xcept', (Config_types.ttypes.Config_inexistent_parameter_error, Config_types.ttypes.Config_inexistent_parameter_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'invalid_value_xcept', (Config_types.ttypes.Config_invalid_value_error, Config_types.ttypes.Config_invalid_value_error.thrift_spec), None, ), # 3
  )

  def __init__(self, generic_xcept=None, inexistant_param_xcept=None, invalid_value_xcept=None,):
    self.generic_xcept = generic_xcept
    self.inexistant_param_xcept = inexistant_param_xcept
    self.invalid_value_xcept = invalid_value_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.inexistant_param_xcept = Config_types.ttypes.Config_inexistent_parameter_error()
          self.inexistant_param_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.invalid_value_xcept = Config_types.ttypes.Config_invalid_value_error()
          self.invalid_value_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('door_open_schedule_delete_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.inexistant_param_xcept is not None:
      oprot.writeFieldBegin('inexistant_param_xcept', TType.STRUCT, 2)
      self.inexistant_param_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_value_xcept is not None:
      oprot.writeFieldBegin('invalid_value_xcept', TType.STRUCT, 3)
      self.invalid_value_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class holiday_schedule_retrieve_args:
  """
  Attributes:
   - schedule_index: holiday schedule index .  Value should be between 0 to 63
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'schedule_index', (TType.BYTE,None), None, ), # 1
  )

  def __init__(self, schedule_index=None,):
    self.schedule_index = schedule_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.schedule_index = []
          (_etype350, _size347) = iprot.readListBegin()
          for _i351 in xrange(_size347):
            _elem352 = iprot.readByte();
            self.schedule_index.append(_elem352)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('holiday_schedule_retrieve_args')
    if self.schedule_index is not None:
      oprot.writeFieldBegin('schedule_index', TType.LIST, 1)
      oprot.writeListBegin(TType.BYTE, len(self.schedule_index))
      for iter353 in self.schedule_index:
        oprot.writeByte(iter353)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class holiday_schedule_retrieve_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - invalid_schedule_index_ex: Invalid schedule index exception
   - inexistant_param_xcept: Access schedule parameter not present in database
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Db_types.ttypes.Holiday_schedule, Db_types.ttypes.Holiday_schedule.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_schedule_index_ex', (Db_types.ttypes.Invalid_schedule_index, Db_types.ttypes.Invalid_schedule_index.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'inexistant_param_xcept', (Config_types.ttypes.Config_inexistent_parameter_error, Config_types.ttypes.Config_inexistent_parameter_error.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, generic_xcept=None, invalid_schedule_index_ex=None, inexistant_param_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.invalid_schedule_index_ex = invalid_schedule_index_ex
    self.inexistant_param_xcept = inexistant_param_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype357, _size354) = iprot.readListBegin()
          for _i358 in xrange(_size354):
            _elem359 = Db_types.ttypes.Holiday_schedule()
            _elem359.read(iprot)
            self.success.append(_elem359)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_schedule_index_ex = Db_types.ttypes.Invalid_schedule_index()
          self.invalid_schedule_index_ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.inexistant_param_xcept = Config_types.ttypes.Config_inexistent_parameter_error()
          self.inexistant_param_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('holiday_schedule_retrieve_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter360 in self.success:
        iter360.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_schedule_index_ex is not None:
      oprot.writeFieldBegin('invalid_schedule_index_ex', TType.STRUCT, 2)
      self.invalid_schedule_index_ex.write(oprot)
      oprot.writeFieldEnd()
    if self.inexistant_param_xcept is not None:
      oprot.writeFieldBegin('inexistant_param_xcept', TType.STRUCT, 3)
      self.inexistant_param_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class holiday_schedule_store_args:
  """
  Attributes:
   - schedule_data: holiday schedule data
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'schedule_data', (TType.STRUCT,(Db_types.ttypes.Holiday_schedule, Db_types.ttypes.Holiday_schedule.thrift_spec)), None, ), # 1
  )

  def __init__(self, schedule_data=None,):
    self.schedule_data = schedule_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.schedule_data = []
          (_etype364, _size361) = iprot.readListBegin()
          for _i365 in xrange(_size361):
            _elem366 = Db_types.ttypes.Holiday_schedule()
            _elem366.read(iprot)
            self.schedule_data.append(_elem366)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('holiday_schedule_store_args')
    if self.schedule_data is not None:
      oprot.writeFieldBegin('schedule_data', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.schedule_data))
      for iter367 in self.schedule_data:
        iter367.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class holiday_schedule_store_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_schedule_index_ex: Invalid schedule index exception
   - inexistant_param_xcept: Access schedule parameter not present in database
   - invalid_value_xcept: Access schedule data invalid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_schedule_index_ex', (Db_types.ttypes.Invalid_schedule_index, Db_types.ttypes.Invalid_schedule_index.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'inexistant_param_xcept', (Config_types.ttypes.Config_inexistent_parameter_error, Config_types.ttypes.Config_inexistent_parameter_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'invalid_value_xcept', (Config_types.ttypes.Config_invalid_value_error, Config_types.ttypes.Config_invalid_value_error.thrift_spec), None, ), # 4
  )

  def __init__(self, generic_xcept=None, invalid_schedule_index_ex=None, inexistant_param_xcept=None, invalid_value_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_schedule_index_ex = invalid_schedule_index_ex
    self.inexistant_param_xcept = inexistant_param_xcept
    self.invalid_value_xcept = invalid_value_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_schedule_index_ex = Db_types.ttypes.Invalid_schedule_index()
          self.invalid_schedule_index_ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.inexistant_param_xcept = Config_types.ttypes.Config_inexistent_parameter_error()
          self.inexistant_param_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.invalid_value_xcept = Config_types.ttypes.Config_invalid_value_error()
          self.invalid_value_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('holiday_schedule_store_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_schedule_index_ex is not None:
      oprot.writeFieldBegin('invalid_schedule_index_ex', TType.STRUCT, 2)
      self.invalid_schedule_index_ex.write(oprot)
      oprot.writeFieldEnd()
    if self.inexistant_param_xcept is not None:
      oprot.writeFieldBegin('inexistant_param_xcept', TType.STRUCT, 3)
      self.inexistant_param_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_value_xcept is not None:
      oprot.writeFieldBegin('invalid_value_xcept', TType.STRUCT, 4)
      self.invalid_value_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class holiday_schedule_delete_args:
  """
  Attributes:
   - schedule_index: holiday schedule index . Value should be between 0 to 63
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'schedule_index', (TType.BYTE,None), None, ), # 1
  )

  def __init__(self, schedule_index=None,):
    self.schedule_index = schedule_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.schedule_index = []
          (_etype371, _size368) = iprot.readListBegin()
          for _i372 in xrange(_size368):
            _elem373 = iprot.readByte();
            self.schedule_index.append(_elem373)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('holiday_schedule_delete_args')
    if self.schedule_index is not None:
      oprot.writeFieldBegin('schedule_index', TType.LIST, 1)
      oprot.writeListBegin(TType.BYTE, len(self.schedule_index))
      for iter374 in self.schedule_index:
        oprot.writeByte(iter374)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class holiday_schedule_delete_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_schedule_index_ex: Invalid schedule index exception
   - inexistant_param_xcept: Access schedule parameter not present in database
   - invalid_value_xcept: Access schedule data invalid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_schedule_index_ex', (Db_types.ttypes.Invalid_schedule_index, Db_types.ttypes.Invalid_schedule_index.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'inexistant_param_xcept', (Config_types.ttypes.Config_inexistent_parameter_error, Config_types.ttypes.Config_inexistent_parameter_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'invalid_value_xcept', (Config_types.ttypes.Config_invalid_value_error, Config_types.ttypes.Config_invalid_value_error.thrift_spec), None, ), # 4
  )

  def __init__(self, generic_xcept=None, invalid_schedule_index_ex=None, inexistant_param_xcept=None, invalid_value_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_schedule_index_ex = invalid_schedule_index_ex
    self.inexistant_param_xcept = inexistant_param_xcept
    self.invalid_value_xcept = invalid_value_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_schedule_index_ex = Db_types.ttypes.Invalid_schedule_index()
          self.invalid_schedule_index_ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.inexistant_param_xcept = Config_types.ttypes.Config_inexistent_parameter_error()
          self.inexistant_param_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.invalid_value_xcept = Config_types.ttypes.Config_invalid_value_error()
          self.invalid_value_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('holiday_schedule_delete_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_schedule_index_ex is not None:
      oprot.writeFieldBegin('invalid_schedule_index_ex', TType.STRUCT, 2)
      self.invalid_schedule_index_ex.write(oprot)
      oprot.writeFieldEnd()
    if self.inexistant_param_xcept is not None:
      oprot.writeFieldBegin('inexistant_param_xcept', TType.STRUCT, 3)
      self.inexistant_param_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_value_xcept is not None:
      oprot.writeFieldBegin('invalid_value_xcept', TType.STRUCT, 4)
      self.invalid_value_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class scan_WIFI_networks_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('scan_WIFI_networks_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class scan_WIFI_networks_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - WIFI_module_connect_xcept: WIFI module not connected
   - license_not_xcept: License not found exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Generic_types.ttypes.WIFI_network_info, Generic_types.ttypes.WIFI_network_info.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'WIFI_module_connect_xcept', (Generic_types.ttypes.WIFI_module_not_connected, Generic_types.ttypes.WIFI_module_not_connected.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'license_not_xcept', (Generic_types.ttypes.License_not_found, Generic_types.ttypes.License_not_found.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, generic_xcept=None, WIFI_module_connect_xcept=None, license_not_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.WIFI_module_connect_xcept = WIFI_module_connect_xcept
    self.license_not_xcept = license_not_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype378, _size375) = iprot.readListBegin()
          for _i379 in xrange(_size375):
            _elem380 = Generic_types.ttypes.WIFI_network_info()
            _elem380.read(iprot)
            self.success.append(_elem380)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.WIFI_module_connect_xcept = Generic_types.ttypes.WIFI_module_not_connected()
          self.WIFI_module_connect_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.license_not_xcept = Generic_types.ttypes.License_not_found()
          self.license_not_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('scan_WIFI_networks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter381 in self.success:
        iter381.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.WIFI_module_connect_xcept is not None:
      oprot.writeFieldBegin('WIFI_module_connect_xcept', TType.STRUCT, 2)
      self.WIFI_module_connect_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.license_not_xcept is not None:
      oprot.writeFieldBegin('license_not_xcept', TType.STRUCT, 3)
      self.license_not_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class events_set_config_args:
  """
  Attributes:
   - events: Mapping of Event IDs to their config structure fields
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'events', (TType.I32,None,TType.STRUCT,(Generic_types.ttypes.Event_config, Generic_types.ttypes.Event_config.thrift_spec)), None, ), # 1
  )

  def __init__(self, events=None,):
    self.events = events

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.events = {}
          (_ktype383, _vtype384, _size382 ) = iprot.readMapBegin()
          for _i386 in xrange(_size382):
            _key387 = iprot.readI32();
            _val388 = Generic_types.ttypes.Event_config()
            _val388.read(iprot)
            self.events[_key387] = _val388
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('events_set_config_args')
    if self.events is not None:
      oprot.writeFieldBegin('events', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.events))
      for kiter389,viter390 in self.events.items():
        oprot.writeI32(kiter389)
        viter390.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class events_set_config_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_argument_xcept
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, generic_xcept=None, invalid_argument_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('events_set_config_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class events_get_config_args:
  """
  Attributes:
   - event_IDs: List of Event IDs to return
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'event_IDs', (TType.I32,None), None, ), # 1
  )

  def __init__(self, event_IDs=None,):
    self.event_IDs = event_IDs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.event_IDs = set()
          (_etype394, _size391) = iprot.readSetBegin()
          for _i395 in xrange(_size391):
            _elem396 = iprot.readI32();
            self.event_IDs.add(_elem396)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('events_get_config_args')
    if self.event_IDs is not None:
      oprot.writeFieldBegin('event_IDs', TType.SET, 1)
      oprot.writeSetBegin(TType.I32, len(self.event_IDs))
      for iter397 in self.event_IDs:
        oprot.writeI32(iter397)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class events_get_config_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
   - invalid_argument_xcept
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.STRUCT,(Generic_types.ttypes.Event_config, Generic_types.ttypes.Event_config.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, generic_xcept=None, invalid_argument_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype399, _vtype400, _size398 ) = iprot.readMapBegin()
          for _i402 in xrange(_size398):
            _key403 = iprot.readI32();
            _val404 = Generic_types.ttypes.Event_config()
            _val404.read(iprot)
            self.success[_key403] = _val404
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('events_get_config_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.success))
      for kiter405,viter406 in self.success.items():
        oprot.writeI32(kiter405)
        viter406.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class licenses_add_args:
  """
  Attributes:
   - license: License file content
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'license', None, None, ), # 1
  )

  def __init__(self, license=None,):
    self.license = license

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.license = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('licenses_add_args')
    if self.license is not None:
      oprot.writeFieldBegin('license', TType.STRING, 1)
      oprot.writeString(self.license)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class licenses_add_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid parameter
   - sd_card_not_found_xcept: SD card not found
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'sd_card_not_found_xcept', (Generic_types.ttypes.SD_card_not_found, Generic_types.ttypes.SD_card_not_found.thrift_spec), None, ), # 3
  )

  def __init__(self, generic_xcept=None, invalid_argument_xcept=None, sd_card_not_found_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept
    self.sd_card_not_found_xcept = sd_card_not_found_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.sd_card_not_found_xcept = Generic_types.ttypes.SD_card_not_found()
          self.sd_card_not_found_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('licenses_add_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.sd_card_not_found_xcept is not None:
      oprot.writeFieldBegin('sd_card_not_found_xcept', TType.STRUCT, 3)
      self.sd_card_not_found_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class licenses_get_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('licenses_get_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class licenses_get_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype410, _size407) = iprot.readListBegin()
          for _i411 in xrange(_size407):
            _elem412 = iprot.readString();
            self.success.append(_elem412)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('licenses_get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter413 in self.success:
        oprot.writeString(iter413)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class config_get_video_phone_params_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('config_get_video_phone_params_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class config_get_video_phone_params_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Generic_types.ttypes.Video_phone_params, Generic_types.ttypes.Video_phone_params.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype417, _size414) = iprot.readListBegin()
          for _i418 in xrange(_size414):
            _elem419 = Generic_types.ttypes.Video_phone_params()
            _elem419.read(iprot)
            self.success.append(_elem419)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('config_get_video_phone_params_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter420 in self.success:
        iter420.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class config_set_video_phone_params_args:
  """
  Attributes:
   - params_video_phone: The list of video phone parameters. The list size to be maximum 20.
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'params_video_phone', (TType.STRUCT,(Generic_types.ttypes.Video_phone_params, Generic_types.ttypes.Video_phone_params.thrift_spec)), None, ), # 1
  )

  def __init__(self, params_video_phone=None,):
    self.params_video_phone = params_video_phone

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.params_video_phone = []
          (_etype424, _size421) = iprot.readListBegin()
          for _i425 in xrange(_size421):
            _elem426 = Generic_types.ttypes.Video_phone_params()
            _elem426.read(iprot)
            self.params_video_phone.append(_elem426)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('config_set_video_phone_params_args')
    if self.params_video_phone is not None:
      oprot.writeFieldBegin('params_video_phone', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.params_video_phone))
      for iter427 in self.params_video_phone:
        iter427.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class config_set_video_phone_params_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - xcept_invalid_IP: Invalid IP string provided in <code>Video_phone_params.address_IP</code>.
   - xcept_invalid_size: The number of profiles provided exceeded the maximum limit of 20.
   - xcept_invalid_value: For any profile, incomplete information provided, i.e., both of the following conditions fail:
  <ul>
    <li> All the parameters of the profile provided.
    <li> None of the parameters of the profile provided (blank profile).
  </ul>
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'xcept_invalid_IP', (Generic_types.ttypes.Invalid_IP_error, Generic_types.ttypes.Invalid_IP_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'xcept_invalid_size', (Generic_types.ttypes.Invalid_size_error, Generic_types.ttypes.Invalid_size_error.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'xcept_invalid_value', (Config_types.ttypes.Config_invalid_value_error, Config_types.ttypes.Config_invalid_value_error.thrift_spec), None, ), # 4
  )

  def __init__(self, generic_xcept=None, xcept_invalid_IP=None, xcept_invalid_size=None, xcept_invalid_value=None,):
    self.generic_xcept = generic_xcept
    self.xcept_invalid_IP = xcept_invalid_IP
    self.xcept_invalid_size = xcept_invalid_size
    self.xcept_invalid_value = xcept_invalid_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.xcept_invalid_IP = Generic_types.ttypes.Invalid_IP_error()
          self.xcept_invalid_IP.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.xcept_invalid_size = Generic_types.ttypes.Invalid_size_error()
          self.xcept_invalid_size.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.xcept_invalid_value = Config_types.ttypes.Config_invalid_value_error()
          self.xcept_invalid_value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('config_set_video_phone_params_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.xcept_invalid_IP is not None:
      oprot.writeFieldBegin('xcept_invalid_IP', TType.STRUCT, 2)
      self.xcept_invalid_IP.write(oprot)
      oprot.writeFieldEnd()
    if self.xcept_invalid_size is not None:
      oprot.writeFieldBegin('xcept_invalid_size', TType.STRUCT, 3)
      self.xcept_invalid_size.write(oprot)
      oprot.writeFieldEnd()
    if self.xcept_invalid_value is not None:
      oprot.writeFieldBegin('xcept_invalid_value', TType.STRUCT, 4)
      self.xcept_invalid_value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class send_to_host_args:
  """
  Attributes:
   - host_config: Structure that contains configuration of host channel. <br>
  It can contain several configurations.
   - data: data to send on host channel
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'host_config', (Generic_types.ttypes.Host_configuration, Generic_types.ttypes.Host_configuration.thrift_spec), None, ), # 1
    (2, TType.STRING, 'data', None, None, ), # 2
  )

  def __init__(self, host_config=None, data=None,):
    self.host_config = host_config
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.host_config = Generic_types.ttypes.Host_configuration()
          self.host_config.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.data = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('send_to_host_args')
    if self.host_config is not None:
      oprot.writeFieldBegin('host_config', TType.STRUCT, 1)
      self.host_config.write(oprot)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 2)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class send_to_host_result:
  """
  Attributes:
   - generic_xcept: Generic exception
   - invalid_argument_xcept: Invalid parameter
   - host_not_found_xcept: controller not found
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'invalid_argument_xcept', (Generic_types.ttypes.Invalid_argument_error, Generic_types.ttypes.Invalid_argument_error.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'host_not_found_xcept', (Generic_types.ttypes.Host_not_found, Generic_types.ttypes.Host_not_found.thrift_spec), None, ), # 3
  )

  def __init__(self, generic_xcept=None, invalid_argument_xcept=None, host_not_found_xcept=None,):
    self.generic_xcept = generic_xcept
    self.invalid_argument_xcept = invalid_argument_xcept
    self.host_not_found_xcept = host_not_found_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.invalid_argument_xcept = Generic_types.ttypes.Invalid_argument_error()
          self.invalid_argument_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.host_not_found_xcept = Generic_types.ttypes.Host_not_found()
          self.host_not_found_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('send_to_host_result')
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.invalid_argument_xcept is not None:
      oprot.writeFieldBegin('invalid_argument_xcept', TType.STRUCT, 2)
      self.invalid_argument_xcept.write(oprot)
      oprot.writeFieldEnd()
    if self.host_not_found_xcept is not None:
      oprot.writeFieldBegin('host_not_found_xcept', TType.STRUCT, 3)
      self.host_not_found_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class retrieve_language_file_list_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('retrieve_language_file_list_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class retrieve_language_file_list_result:
  """
  Attributes:
   - success
   - generic_xcept: Generic exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_xcept', (Generic_types.ttypes.Generic_error, Generic_types.ttypes.Generic_error.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, generic_xcept=None,):
    self.success = success
    self.generic_xcept = generic_xcept

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype431, _size428) = iprot.readListBegin()
          for _i432 in xrange(_size428):
            _elem433 = iprot.readString();
            self.success.append(_elem433)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_xcept = Generic_types.ttypes.Generic_error()
          self.generic_xcept.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('retrieve_language_file_list_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter434 in self.success:
        oprot.writeString(iter434)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_xcept is not None:
      oprot.writeFieldBegin('generic_xcept', TType.STRUCT, 1)
      self.generic_xcept.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
